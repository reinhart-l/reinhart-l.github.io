<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LEETCODE问题集 | Across the Cosmos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="4. 寻找两个正序数组的中位数思路二分查找 把问题转换为找两个数组中第k大的数，当n+m为奇数，中位数是两个数组中第$(m+n+1)&#x2F;2$个元素，当n+m为偶数，中位数是第$(m+n)&#x2F;2$和$(m+n)&#x2F;2+1$个数的平均数。  实现比较恶心，每个数组分别定义一个偏移量offs1和offs2，令mid1&#x3D;offs1+k&#x2F;2-1,mid2&#x3D;offs2+k&#x2F;2-1每次比">
<meta property="og:type" content="article">
<meta property="og:title" content="LEETCODE问题集">
<meta property="og:url" content="http://example.com/2022/02/25/LEETCODE%E9%97%AE%E9%A2%98%E9%9B%86/index.html">
<meta property="og:site_name" content="Across the Cosmos">
<meta property="og:description" content="4. 寻找两个正序数组的中位数思路二分查找 把问题转换为找两个数组中第k大的数，当n+m为奇数，中位数是两个数组中第$(m+n+1)&#x2F;2$个元素，当n+m为偶数，中位数是第$(m+n)&#x2F;2$和$(m+n)&#x2F;2+1$个数的平均数。  实现比较恶心，每个数组分别定义一个偏移量offs1和offs2，令mid1&#x3D;offs1+k&#x2F;2-1,mid2&#x3D;offs2+k&#x2F;2-1每次比">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203012113696.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203100958658.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251401401.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281121048.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251328471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172112336.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172149246.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251505396.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281517760.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281519688.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281518532.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251503559.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251801080.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802499.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802054.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802879.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802987.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802218.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802264.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802457.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803573.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803797.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240325224319278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240326110105688.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/1711265135869.png">
<meta property="article:published_time" content="2022-02-24T16:00:52.000Z">
<meta property="article:modified_time" content="2025-01-21T03:25:22.806Z">
<meta property="article:author" content="Reinhart">
<meta property="article:tag" content="个人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203012113696.png">
  
    <link rel="alternate" href="/atom.xml" title="Across the Cosmos" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Across the Cosmos</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-LEETCODE问题集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/25/LEETCODE%E9%97%AE%E9%A2%98%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2022-02-24T16:00:52.000Z" itemprop="datePublished">2022-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LEETCODE问题集
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找</p>
<p>把问题转换为找两个数组中第k大的数，当n+m为奇数，中位数是两个数组中第$(m+n+1)&#x2F;2$个元素，当n+m为偶数，中位数是第$(m+n)&#x2F;2$和$(m+n)&#x2F;2+1$个数的平均数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203012113696.png"></p>
<p>实现比较恶心，每个数组分别定义一个偏移量offs1和offs2，令<code>mid1=offs1+k/2-1,mid2=offs2+k/2-1</code>每次比较<code>a[mid1]</code>和<code>b[mid2]</code>，根据上面的思路，<code>a[mid1]&gt;=b[mid2]</code>那<code>mid1及以前的数字</code>都可被排除了，<code>偏移量offset1+=k/2</code>(因为包括<code>a[mid1]</code>所以是<code>k/2-1+1</code>)。因为现在已经排除了<code>k/2</code>个数字，<code>k-=k/2</code>。反之亦然。</p>
<p>现在还有一个需要考虑的就是边界情况，有可能<code>offs1+k/2-1</code>已经超过数组范围，所以要和数组长度<code>n</code>取一个<code>min</code>，同理在更新<code>offs1</code>和<code>k</code>的时候也要取<code>min</code>，因为如果<code>mid1</code>超过数组范围的话可以排除的数的个数就不是<code>k/2</code>个，而是<code>n</code>个。我们知道当<code>k==1</code>时答案就是此时<code>a[offs1],b[offs2]</code>的最小值。因为到这一步意味着我们已经排除了<code>k-1</code>个数字，只差最后一个就能找到第k大的元素。但如果k还没到1就有一边数组超出边界了呢？如果a数组二分到头了，那就直接返回<code>b[offs2+k-1]</code>就是答案了。考虑a数组为空的情况，<code>offs2=0</code>，就相当于直接找<code>b[k-1]</code>（下标从0开始）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k,vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> offs1=<span class="number">0</span>,offs2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid1,mid2;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cout&lt;&lt;offs1&lt;&lt;&#x27; &#x27;&lt;&lt;offs2&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;mid1&lt;&lt;&#x27; &#x27;&lt;&lt;mid2&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            <span class="keyword">if</span>(offs1&gt;=n)<span class="keyword">return</span> nums2[offs2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(offs2&gt;=m)<span class="keyword">return</span> nums1[offs1+k<span class="number">-1</span>];      </span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">min</span>(nums1[offs1],nums2[offs2]);</span><br><span class="line">            mid1=<span class="built_in">min</span>(offs1+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>),mid2=<span class="built_in">min</span>(offs2+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[mid1]&lt;=nums2[mid2])&#123;</span><br><span class="line">                offs1+=<span class="built_in">min</span>(k/<span class="number">2</span>,n);</span><br><span class="line">                k=k-<span class="built_in">min</span>(k/<span class="number">2</span>,n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                offs2+=<span class="built_in">min</span>(k/<span class="number">2</span>,m);  </span><br><span class="line">                k=k-<span class="built_in">min</span>(k/<span class="number">2</span>,m);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans,k;</span><br><span class="line">        n=nums1.<span class="built_in">size</span>(),m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>((n+m+<span class="number">1</span>)/<span class="number">2</span>,nums1,nums2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">double</span>(<span class="built_in">check</span>((n+m)/<span class="number">2</span>,nums1,nums2))+<span class="built_in">double</span>(<span class="built_in">check</span>((n+m)/<span class="number">2</span>+<span class="number">1</span>,nums1,nums2)))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>$f[i][j]$表示s的前i个字符和p的前j个字符匹配情况。</p>
</li>
<li><p>$p[j]!&#x3D;’*’$</p>
<ul>
<li>$f[i][j]&#x3D;f[i-1][j-1]&amp;&amp;(s[i]&#x3D;&#x3D;p[j]||p[j]&#x3D;&#x3D;’.’)$</li>
<li>当$i,j$前面的都相等，并且当前$s[i]&#x3D;p[j]$或者$p[j]$为’.’说明$f[i][j]&#x3D;true$</li>
</ul>
</li>
<li><p>$p[j]&#x3D;&#x3D;’*’$</p>
<ul>
<li>$f[i][j]&#x3D;f[i][j-2]||f[i-1][j-2]&amp;&amp;s[i]&#x3D;&#x3D;p[j]||f[i-2][j-2]&amp;&amp;s[i]&#x3D;&#x3D;p[j]&amp;&amp;s[i-1]&#x3D;&#x3D;p[j]$</li>
<li>‘*’可以代表多个字符，第一项意味着*前面的字符有0个(相当于*和前面的字符共两个字符一起消去了所以是$f[i][j-2]$)，第二项是*可以代表一个它前面的字符，以此类推。</li>
</ul>
</li>
<li><p>但遍历一遍*的可能情况是$O(n)$的，考虑优化。</p>
<ul>
<li>$f[i][j]&#x3D;f[i][j-2]||f[i-1][j-2]&amp;&amp;s[i]&#x3D;&#x3D;p[j-1]||f[i-2][j-2]&amp;&amp;s[i]&#x3D;&#x3D;p[j-1]&amp;&amp;s[i-1]&#x3D;&#x3D;p[j-1]$</li>
<li>$f[i-1][j]&#x3D;f[i-1][j-2]||f[i-2][j-2]&amp;&amp;s[i-1]&#x3D;&#x3D;p[j-1]||f[i-3][j-2]&amp;&amp;s[i-1]&#x3D;&#x3D;p[j-1]&amp;&amp;s[i-2]&#x3D;&#x3D;p[j-1]$</li>
<li>综上可得$f[i][j]&#x3D;f[i][j-2]||f[i-1][j]&amp;&amp;(s[i]&#x3D;&#x3D;p[j-1])$,只需要保留上一层循环的结果即可。时间复杂度$O(1)$,(这里为什么是$p[j-1]$是因为$p[j]$是’*’)</li>
<li>类似于完全背包的优化方案</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">char</span> a,<span class="type">char</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b||b==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> dp[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=p.<span class="built_in">length</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//空串可以和空串匹配</span></span><br><span class="line">        s=<span class="string">&quot; &quot;</span>+s,p=<span class="string">&quot; &quot;</span>+p;<span class="comment">//下标从1开始方便计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="comment">//j从1开始，因为j=0意味着p是空串，空串一定不会和s匹配，所以j=0没有意义</span></span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=m&amp;&amp;p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//如果这个字符后一个是*直接跳过它</span></span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;p[j]!=<span class="string">&#x27;*&#x27;</span>)&#123;<span class="comment">//因为i是从0开始的，所以要i大于1才能进行这一步</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&amp;&amp;<span class="built_in">judge</span>(s[i],p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j]==<span class="string">&#x27;*&#x27;</span>)&#123;<span class="comment">//这里对i的判断写在了里面，是因为当i=0的时候同样要进行dp[i][j]=dp[i][j-2]的转移（当p可以匹配空串时）</span></span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-2</span>]||i&amp;&amp;dp[i<span class="number">-1</span>][j]&amp;&amp;<span class="built_in">judge</span>(s[i],p[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(r-l)*<span class="built_in">min</span>(h[l],h[r]));</span><br><span class="line">            <span class="keyword">if</span>(h[l]&lt;=h[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt;v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string path,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;n||r&gt;n||r&gt;l)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==n&amp;&amp;r==n)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(path+<span class="string">&#x27;(&#x27;</span>,l+<span class="number">1</span>,r,n);</span><br><span class="line">        <span class="built_in">dfs</span>(path+<span class="string">&#x27;)&#x27;</span>,l,r+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203100958658.png" alt="image-20220310095806090"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123; <span class="string">&quot;()&quot;</span> &#125;;</span><br><span class="line">		vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">		dp[<span class="number">0</span>] = &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">		dp[<span class="number">1</span>] = &#123; <span class="string">&quot;()&quot;</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;i; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (string p : dp[j])</span><br><span class="line">					<span class="keyword">for</span> (string q : dp[i - j - <span class="number">1</span>]) &#123;</span><br><span class="line">						string str = <span class="string">&quot;(&quot;</span> + p + <span class="string">&quot;)&quot;</span> + q;</span><br><span class="line">						dp[i].<span class="built_in">push_back</span>(str);</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251401401.png" alt="img"></p>
<p>栈里面存的是最后一个没有被匹配的括号的下标。</p>
<ul>
<li>如果是’(‘直接入栈。</li>
<li>是’)’如果栈内有元素就将栈顶弹出。弹出后栈空了说明该右括号失配</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="comment">//栈空了说明能匹配的都匹配完了还多出当前这个失配的右括号</span></span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                  	<span class="comment">//存最后一个没有被匹配的&#x27;)&#x27;的下标。</span></span><br><span class="line">                    st.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,i-st.<span class="built_in">top</span>());<span class="comment">//取每一段的最大值</span></span><br><span class="line">              <span class="comment">//当前位置减去上一个失配的位置就是这一段有效括号序列的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>左指针和右指针分别从两端开始，维护一个lmax和rmax，分别代表左右两边当前的最高高度。注意如果$h[l]&lt;h[r]$移动左指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> lmax=<span class="number">0</span>,rmax=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(h[l]&lt;=h[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(lmax&gt;h[l])ans+=lmax-h[l];</span><br><span class="line">                lmax=<span class="built_in">max</span>(lmax,h[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rmax&gt;h[r])ans+=rmax-h[r];</span><br><span class="line">                rmax=<span class="built_in">max</span>(rmax,h[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281121048.png" alt="截屏2022-02-28 11.21.09"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;h[i]&gt;h[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> t=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> l=st.<span class="built_in">top</span>();</span><br><span class="line">                ans+=(i-l<span class="number">-1</span>)*<span class="built_in">max</span>(<span class="number">0</span>,(<span class="built_in">min</span>(h[i],h[l])-h[t]));</span><br><span class="line">            &#125;<span class="comment">//这里和max取一个0是为了特判h[t]比min(h[i],h[l])大的情况</span></span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>螺旋矩阵2改一改，考虑一下行列不同的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector &lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m=a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> N=n,M=m;</span><br><span class="line">        n--;</span><br><span class="line">        m--;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= N * M) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= m; i++) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[c][i]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = c + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[i][m]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= c; i--) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[n][i]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= c + <span class="number">1</span>; i--) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[i][c]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251328471.png" alt="image-20220225132826296" style="zoom: 25%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));<span class="comment">//静态vector</span></span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>,l=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=n*n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=c;i&lt;=l;i++)&#123;</span><br><span class="line">                a[c][i]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=c+<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">                a[i][l]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=c;i--)&#123;</span><br><span class="line">                a[l][i]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=c+<span class="number">1</span>;i--)&#123;</span><br><span class="line">                a[i][c]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">            l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84.柱状图中最大的矩形</a></h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172112336.png" alt="image-20240329172112336"></p>
<p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172149246.png" alt="image-20240329172149246"></p>
<p>详细解释：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/">https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);<span class="comment">//处理边界情况</span></span><br><span class="line">        <span class="type">int</span> n=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i]&lt;heights[st.<span class="built_in">top</span>()])&#123;<span class="comment">//当前高度小于栈顶高度 说明以栈顶为高度的长方形的右边界找到了</span></span><br><span class="line">                <span class="type">int</span> h=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;=h)&#123;<span class="comment">//找右边界</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=i-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组遍历完了栈里还有剩的</span></span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> h=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;=h)&#123;<span class="comment">//找右边界</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=n-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85.最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85.最大矩形</a></h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>给定一个<code>heights[i][j]</code>记录第<code>j</code>列连续的1的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0               1 0 1 0 0 </span><br><span class="line">1 0 1 1 1     --&gt;       2 0 2 1 1 </span><br><span class="line">1 1 1 1 1     --&gt;       3 1 3 2 2 </span><br><span class="line">1 0 0 1 0               4 0 0 3 0 	</span><br></pre></td></tr></table></figure>

<p>有了<code>heights[i][j]</code>后就相当于对每一层<code>i</code>求柱状图中最大的矩形(上一题)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heights[<span class="number">205</span>][<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(heights[i<span class="number">-1</span>][j])heights[i][j]=heights[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            heights[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for(int j=0;j&lt;n;j++)&#123;</span></span><br><span class="line">            <span class="comment">//     cout&lt;&lt;heights[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][j]&lt;heights[i][st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    <span class="type">int</span> h=heights[i][st.<span class="built_in">top</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][st.<span class="built_in">top</span>()]&gt;=h)&#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> w=j-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> h=heights[i][st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][st.<span class="built_in">top</span>()]&gt;=h)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=n-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="88-合并两个有序数组-https-leetcode-cn-problems-merge-sorted-array-description"><a href="#88-合并两个有序数组-https-leetcode-cn-problems-merge-sorted-array-description" class="headerlink" title="[88.合并两个有序数组][https://leetcode.cn/problems/merge-sorted-array/description/]"></a>[88.合并两个有序数组][<a href="https://leetcode.cn/problems/merge-sorted-array/description/]">https://leetcode.cn/problems/merge-sorted-array/description/]</a></h2><ul>
<li>用双指针倒着插入可以不用多开一个数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> idx=m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)nums1=nums2;</span><br><span class="line">        <span class="keyword">while</span>(idx&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;=nums2[j])&#123;</span><br><span class="line">                    nums1[idx]=nums2[j];</span><br><span class="line">                    idx--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nums1[idx]=nums1[i];</span><br><span class="line">                    nums1[i]=<span class="number">0</span>;</span><br><span class="line">                    idx--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[idx]=nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[idx]=nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>对于这颗二叉树，可能的路径情况有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a</span><br><span class="line"> / \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure>

<ol>
<li>b + a + c</li>
<li>b + a + a 的父结点</li>
<li>a + c + a 的父结点</li>
</ol>
<p>把b节点思考成一坨左子树，c节点思考成一坨右子树。</p>
<p>如果b整体比0小那直接不用选了，c同理。</p>
<p>考虑从小往上递归。对于每一个节点，他都有可能作为一个”转折点”，或者作为一个单边继续向上递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxx=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;left));<span class="comment">//u的左子树，如果u的左子树比0还小那就直接不选了</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;right));<span class="comment">//u的右子树，如果u的右子树比0还小那就直接不选了</span></span><br><span class="line">            maxx=<span class="built_in">max</span>(maxx,u-&gt;val+l+r);<span class="comment">//选u作为那个&quot;转折点&quot;</span></span><br><span class="line">            <span class="keyword">return</span> u-&gt;val+<span class="built_in">max</span>(l,r);<span class="comment">// 返回经过u的&quot;单边&quot;最大分支给当前u的父节点计算使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LCR-153-二叉树中和为目标的值"><a href="#LCR-153-二叉树中和为目标的值" class="headerlink" title="LCR 153.二叉树中和为目标的值"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/description/">LCR 153.二叉树中和为目标的值</a></h2><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>dfs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>&amp;&amp;sum==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,sum);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathTarget</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="124-二叉树中的最大路径和-1"><a href="#124-二叉树中的最大路径和-1" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>对于这颗二叉树，可能的路径情况有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a</span><br><span class="line"> / \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure>

<ol>
<li>b + a + c</li>
<li>b + a + a 的父结点</li>
<li>a + c + a 的父结点</li>
</ol>
<p>把b节点思考成一坨左子树，c节点思考成一坨右子树。</p>
<p>如果b整体比0小那直接不用选了，c同理。</p>
<p>考虑从小往上递归。对于每一个节点，他都有可能作为一个”转折点”，或者作为一个单边继续向上递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxx=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;left));<span class="comment">//u的左子树，如果u的左子树比0还小那就直接不选了</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;right));<span class="comment">//u的右子树，如果u的右子树比0还小那就直接不选了</span></span><br><span class="line">            maxx=<span class="built_in">max</span>(maxx,u-&gt;val+l+r);<span class="comment">//选u作为那个&quot;转折点&quot;</span></span><br><span class="line">            <span class="keyword">return</span> u-&gt;val+<span class="built_in">max</span>(l,r);<span class="comment">// 返回经过u的&quot;单边&quot;最大分支给当前u的父节点计算使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉树的最近公共祖先</a></h2><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>用到了后序遍历的特点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>||root==p||root==q)<span class="keyword">return</span> root;<span class="comment">//只要当前根节点是p和q中的任意一个，就返回（因为不能比这个更深了，再深p和q中的一个就没了）</span></span><br><span class="line">        <span class="comment">//根节点不是p和q中的任意一个，那么就继续分别往左子树和右子树找p和q</span></span><br><span class="line">        TreeNode *l=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *r=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">nullptr</span>)<span class="keyword">return</span> r;<span class="comment">//左子树都找完了都没找到p和q,那p和q肯定都在右子树里</span></span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)<span class="keyword">return</span> l;<span class="comment">//右子树都找完了都没找到p和q,那p和q肯定都在左子树里</span></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//p和q分别存在在左右子树中, 这时候root也搜到最近的公共父节点了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>事先存一个空节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *curr=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;<span class="comment">//当前节点的指针指向上一个元素</span></span><br><span class="line">            pre=head;<span class="comment">//更新上一个元素</span></span><br><span class="line">            head=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>$O(2*n)$</p>
<p>找到left的前一个节点，left节点，right的后一个节点，right节点。对left到right这一段链表进行反转操作，然后再接回去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dnode-&gt;next=head;</span><br><span class="line">        ListNode *pre=dnode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l=pre;<span class="comment">//left的前一个节点</span></span><br><span class="line">        ListNode *r=pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r:right的后一个节点</span></span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//st:left节点</span></span><br><span class="line">        ListNode *st=pre-&gt;next;</span><br><span class="line">        ListNode *ed=pre-&gt;next;</span><br><span class="line">        ListNode *last=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//null-&gt;2-&gt;3-&gt;4 ----&gt; null&lt;-2&lt;-3&lt;-4</span></span><br><span class="line">        <span class="keyword">while</span>(ed!=r)&#123;</span><br><span class="line">            ListNode *curr=ed-&gt;next;</span><br><span class="line">            ed-&gt;next=last;</span><br><span class="line">            last=ed;</span><br><span class="line">            ed=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//last:right节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转后left变成了right，right变成了left</span></span><br><span class="line">        l-&gt;next=last;</span><br><span class="line">        <span class="comment">//last是反转后的头</span></span><br><span class="line">        st-&gt;next=r;</span><br><span class="line">        <span class="comment">//st是反转后尾，所以st的next要指向r（right的后一个节点）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>$O(n)$</p>
<p>头插法</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251505396.png" alt="image-20220425150558317"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281517760.png" alt="截屏2022-02-28 15.15.40"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281519688.png" alt="截屏2022-02-28 15.16.30"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281518532.png" alt="截屏2022-02-28 15.16.30"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251503559.png" alt="image-20220425150336331"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dnode-&gt;next=head;</span><br><span class="line">        ListNode *pre=dnode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        ListNode *cur=pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">     	  <span class="comment">//pre-&gt;next永远指向反转的第一个节点</span></span><br><span class="line">     		<span class="comment">//cur其实一直是left节点，只是在被不停的头插，挤到了后面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            <span class="comment">//首先,next永远指向cur的下一个</span></span><br><span class="line">             next=cur-&gt;next;</span><br><span class="line">          	<span class="comment">//当前节点的下一个节点变成next的下一个节点(要把next拿去头插了)</span></span><br><span class="line">             cur-&gt;next=next-&gt;next;</span><br><span class="line">          	<span class="comment">//cur的下一个节点(next)指向第一个节点，那它就变成了第一个节点(头插)</span></span><br><span class="line">             next-&gt;next=pre-&gt;next;</span><br><span class="line">          	<span class="comment">//更新第一个节点为next</span></span><br><span class="line">             pre-&gt;next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dnode-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251801080.png" alt="image-20220425180147001"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802499.png" alt="image-20220425180200422"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802054.png" alt="image-20220425180212978"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802879.png" alt="image-20220425180221773"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802987.png" alt="image-20220425180232876"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802218.png" alt="image-20220425180241094"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802264.png" alt="image-20220425180249157"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802457.png" alt="image-20220425180256346"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803573.png" alt="image-20220425180314490"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803797.png" alt="image-20220425180322689"></p>
<p>temp对应代码中的pre</p>
<p>node1对应head</p>
<p>node2对应nxt</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">break</span>;<span class="comment">//不是双数个节点的情况(单个节点找不到换的)</span></span><br><span class="line">            pre-&gt;next=head-&gt;next;</span><br><span class="line">            ListNode *nxt=head-&gt;next;</span><br><span class="line">            head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">            nxt-&gt;next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h4><p>一开始写成了这样（没有新建nxt节点保存head-&gt;next），会进入死循环。因为head-&gt;next已经被更新为head-&gt;next-&gt;next了，所以head-&gt;next-&gt;next相当于是(head-&gt;next-&gt;next)-&gt;next</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">break</span>;</span><br><span class="line">            pre-&gt;next=head-&gt;next;   </span><br><span class="line">            head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        retur</span><br></pre></td></tr></table></figure>



<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><p>先记录链表的总长度记为<code>remain</code>用<code>92. 反转链表 II</code>的头插法，每次头插k个，插完k个将pre置换成上一组翻转的最后一个，也就是<code>cur</code>，因为<code>cur</code>本来是第一个节点，一直被头插插到最后一个了。同时也要更新<code>cur</code>为<code>pre-&gt;next</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* cntNode=head;</span><br><span class="line">        <span class="type">int</span> remain=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cntNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cntNode=cntNode-&gt;next;</span><br><span class="line">            remain++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        ListNode *nxt;</span><br><span class="line">        <span class="keyword">while</span>(remain&gt;=k)&#123;      </span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>;<span class="comment">//翻转k个节点需要翻转k-1次，所以cnt从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;k)&#123;</span><br><span class="line">                nxt=cur-&gt;next;</span><br><span class="line">                cur-&gt;next=nxt-&gt;next;</span><br><span class="line">                nxt-&gt;next=cur;</span><br><span class="line">                nxt-&gt;next=pre-&gt;next;</span><br><span class="line">                pre-&gt;next=nxt;          </span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=pre-&gt;next;</span><br><span class="line">            remain-=k;<span class="comment">//翻转了k个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><p>1.用一个map记录队列中数的情况，入队value，<code>mp[value]++</code>。出队q.front()，<code>mp[q.front()]--</code>，这里需要注意当mp[q.front()]为0时，要把<code>mp.erase(q.front());</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        it=mp.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        mp[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            mp[t]--;</span><br><span class="line">            <span class="keyword">if</span>(!mp[t])mp.<span class="built_in">erase</span>(t);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>2.一个双端单调队列记录最大值，一个普通队列记录队列真实的出入顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> d.<span class="built_in">front</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (!d.<span class="built_in">empty</span>() &amp;&amp; d.<span class="built_in">back</span>() &lt; value) &#123;</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_back</span>(value);</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">front</span>()==t)&#123;</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s1,s2;</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t=s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a></h2><h3 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h3><p>贪心</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minn=<span class="number">100005</span>;</span><br><span class="line">        <span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minn=<span class="built_in">min</span>(minn,prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)maxx=<span class="built_in">max</span>(maxx,prices[i]-minn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122.买卖股票的最佳时机2"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机2</a></h2><h3 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h3><p>状态机DP</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//f[i][0]未持有股票</span></span><br><span class="line">        <span class="comment">//f[i][1]持有股票</span></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);<span class="comment">//没股票的前一次可以是没股票和卖了一支股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//有股票的前一次可以是有股票或者买了一支股票</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123.买卖股票的最佳时机3"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机3</a></h2><h3 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h3><p>状态机DP</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//f[i][0]:从来没有买过股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][1]:第一次买股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][2]:卖掉一次股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][3]:卖掉一次股票，又买了一次的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][4]:卖掉两次股票的最大收益</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=dp[<span class="number">0</span>][<span class="number">3</span>]=dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">-1e6</span>;<span class="comment">//这三种情况在第一支股票时均不可能发生</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">3</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">                dp[i][<span class="number">4</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[i][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][1]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][2]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][3]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][4]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="124-买卖股票的最佳时机4"><a href="#124-买卖股票的最佳时机4" class="headerlink" title="124.买卖股票的最佳时机4"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">124.买卖股票的最佳时机4</a></h2><h3 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h3><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240325224319278.png" alt="image-20240325224319278"></p>
<p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240326110105688.png" alt="image-20240326110105688"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k,vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">105</span>][<span class="number">2</span>];<span class="comment">//考虑前i支股票，买卖了j次，当前没有/有股票的最大收益（以买作为一次交易，因为买了肯定要卖）</span></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);<span class="comment">//没股票的前一次可以是没股票和卖了一支股票</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);<span class="comment">//有股票的前一次可以是有股票或者买了一支股票</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;=n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;=k;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;dp[i][j][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][j][1]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[n][i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="146-LRU缓存-https-leetcode-cn-problems-lru-cache-description"><a href="#146-LRU缓存-https-leetcode-cn-problems-lru-cache-description" class="headerlink" title="[146.LRU缓存][https://leetcode.cn/problems/lru-cache/description/]"></a>[146.LRU缓存][<a href="https://leetcode.cn/problems/lru-cache/description/]">https://leetcode.cn/problems/lru-cache/description/]</a></h2><h3 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h3><p>unordered_map+双链表，主要复习stl的用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;lis;</span><br><span class="line">    <span class="comment">//存iterator指向链表</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt;mp;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//find()返回的是一个iterator,所以这里要先—&gt;再.</span></span><br><span class="line">            <span class="comment">//更新key再链表中的位置</span></span><br><span class="line">            lis.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key].second=(--lis.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&gt;=cap)&#123;</span><br><span class="line">                <span class="type">int</span> rmkey=lis.<span class="built_in">front</span>();</span><br><span class="line">                lis.<span class="built_in">pop_front</span>();</span><br><span class="line">                mp.<span class="built_in">erase</span>(rmkey);</span><br><span class="line">            &#125;</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key]=&#123;value,--lis.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//修改了已有key的value，更新该key在链表中的位置</span></span><br><span class="line">            lis.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key]=&#123;value,--lis.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a><a href="https://leetcode.cn/problems/majority-element/description">169.多数元素</a></h2><h3 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h3><p>候选人(<code>cand_num</code>)初始化为 <code>nums[0]</code>，票数 <code>count</code> 初始化为 1。<br>当遇到与 <code>cand_num</code> 相同的数，则票数 <code>count = count + 1</code>，否则票数 <code>count = count - 1</code>。<br>当票数 <code>count</code> 为 0 时，更换候选人，并将票数 <code>count</code> 重置为 1。<br>遍历完数组后，<code>cand_num</code> 即为最终答案。</p>
<p>为何这行得通呢？<br>投票法是遇到相同的则 <code>票数 + 1</code>，遇到不同的则 <code>票数 - 1</code>。<br>且“多数元素”的个数 &gt; ⌊ n&#x2F;2 ⌋，其余元素的个数总和 &lt;&#x3D; ⌊ n&#x2F;2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;&#x3D; 1。<br>这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素“。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cand_num=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==cand_num)cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)cand_num=i,cnt=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/description/">189.轮转数组</a></h2><ul>
<li>循环数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           nums[i]=curr[(i+n-k%n)%n];</span><br><span class="line">           <span class="comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;(i+n-k%n)%n&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>O(1)空间</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+k,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300.最长上升子序列</a></h2><h3 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h3><p><code>dp[i]</code>意为以<code>nums[i]</code>这个数字结尾的最长上升子序列长度，所以转移方程考虑<code>dp[i]=max(dp[k]+1) if nums[i]&gt;nums[k] k=0...i-1</code></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对于每一个长度的上升子序列，只有结尾最小的是有用的。例如<code>3 1 2 1 8 5 6</code>，以3和1结尾的都是长度为1的最长上升子序列，但是1比3更好，所以3就没用了。</p>
<ul>
<li>一个猜想：随着最长上升子序列长度的增加，不同长度的上升子序列的最小结尾也是单调递增的（反证法可得）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/1711265135869.png" alt="1711265135869"></p>
<ul>
<li>由上存储一个数组<code>q[i]</code>（存的是所有长度为i的上升子序列的结尾最小值），假设一个数a，要求它的最长上升子序列，只需找到<code>q</code>中比它小的数中最大的数，假设为<code>q[j]</code>，因为<code>q[j]</code>是小于a的最大的数，那么<code>q[j+1]</code>一定是大于等于a的，所以可以用a去更新<code>q[j+1]</code></li>
<li>不懂就去看调试</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> q[<span class="number">2505</span>]; <span class="comment">//q[i]代表最长上升子序列长度为i时的结尾最小值</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        q[<span class="number">0</span>]=<span class="number">-2e4</span>;<span class="comment">//求的是小于某个数最大的数，保证小于的数一定存在</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=len;</span><br><span class="line">            <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;q[mid])&#123;</span><br><span class="line">                    l=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="built_in">max</span>(len,r+<span class="number">1</span>);</span><br><span class="line">            q[r+<span class="number">1</span>]=nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">            <span class="comment">//     cout&lt;&lt;q[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;&#x27;\n&#x27;&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692.前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/description/">692.前K个高频单词</a></h2><h3 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h3><p>主要展示优先队列自定义运算符较为简单的一种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stru</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stru &amp;a)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.n!=n)<span class="keyword">return</span> a.n &gt; n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.id &lt; id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:words)&#123;</span><br><span class="line">            mp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;stru&gt;heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">            stru x=&#123;i.second,i.first&#125;;</span><br><span class="line">            heap.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt;ans;</span><br><span class="line">        <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> top=heap.<span class="built_in">top</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(top.id);</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(!k)<span class="keyword">break</span>;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是sort可以这么写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stru</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125; edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stru a, stru b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + n - <span class="number">1</span>, cmp);</span><br></pre></td></tr></table></figure>



<h2 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h2><h3 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h3><p>注意因为可以走回头路，所以不是DP，魔改dijkstra。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;g[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j, <span class="type">int</span> c,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;c&amp;&amp;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;r&amp;&amp;j&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> r = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> c = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;c;</span></span><br><span class="line">        <span class="comment">//先bfs一遍把图建出来</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(vis[t.first][t.second])<span class="keyword">continue</span>;</span><br><span class="line">            vis[t.first][t.second]=<span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">judge</span>(x,y,c,r)&amp;&amp;!vis[x][y])&#123;</span><br><span class="line">                    <span class="type">int</span> idx=t.first*r+t.second;</span><br><span class="line">                    <span class="type">int</span> idx2=x*r+y;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;idx&lt;&lt;&#x27; &#x27;&lt;&lt;idx2&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">                    <span class="type">int</span> di=<span class="built_in">abs</span>(heights[t.first][t.second]-heights[x][y]);</span><br><span class="line">                    g[idx].<span class="built_in">push_back</span>(&#123;idx2,di&#125;);</span><br><span class="line">                    g[idx2].<span class="built_in">push_back</span>(&#123;idx,di&#125;);</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;c*r;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto j:g[i])&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;j.second&lt;&lt;&#x27; &#x27;&lt;&lt;j.first&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;c*r;i++)cout&lt;&lt;dis[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">return</span> dis[c*r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])<span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[ver].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> j = g[ver][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j.first] &gt; <span class="built_in">max</span>(distance , j.second)) &#123;</span><br><span class="line">                dis[j.first] = <span class="built_in">max</span>(distance , j.second);</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j.first], j.first&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/25/LEETCODE%E9%97%AE%E9%A2%98%E9%9B%86/" data-id="cmb2ap95d000y48ucb5m96rhw" data-title="LEETCODE问题集" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据库知识点
        
      </div>
    </a>
  
  
    <a href="/2022/01/19/%E4%BD%BF%E7%94%A8hexo%E5%9F%BA%E4%BA%8Ecactus%E4%BB%99%E4%BA%BA%E6%8E%8C%E4%B8%BB%E9%A2%98%E6%9C%80%E5%85%A8%E7%BE%8E%E5%8C%96%E5%AE%A2%E5%88%B6%E6%95%99%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用hexo基于cactus仙人掌主题最全美化客制教程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/" rel="tag">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NPC/" rel="tag">NPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 14px;">AI</a> <a href="/tags/NPC/" style="font-size: 14px;">NPC</a> <a href="/tags/hexo/" style="font-size: 12px;">hexo</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 18px;">个人</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 16px;">教程</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E9%A2%98%E8%A7%A3/" style="font-size: 20px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/24/LARP%20LANGUAGE-AGENT%20ROLE%20PLAY%20FOR%20OPEN-WORLD%20GAMES/">LARP LANGUAGE-AGENT ROLE PLAY FOR OPEN-WORLD GAMES</a>
          </li>
        
          <li>
            <a href="/2025/05/24/saga_translation_with_images/">SAGA 面向代理的技能到行动生成框架</a>
          </li>
        
          <li>
            <a href="/2025/01/16/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%B0%8F%E9%95%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">斯坦福小镇阅读笔记</a>
          </li>
        
          <li>
            <a href="/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/">计算机网络知识点</a>
          </li>
        
          <li>
            <a href="/2023/11/08/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E5%9C%BA%E6%99%AF%E9%A2%98/">游戏研发场景题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Reinhart<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>