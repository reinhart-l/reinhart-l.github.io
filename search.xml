<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LARP LANGUAGE-AGENT ROLE PLAY FOR OPEN-WORLD GAMES</title>
      <link href="/2025/05/24/LARP%20LANGUAGE-AGENT%20ROLE%20PLAY%20FOR%20OPEN-WORLD%20GAMES/"/>
      <url>/2025/05/24/LARP%20LANGUAGE-AGENT%20ROLE%20PLAY%20FOR%20OPEN-WORLD%20GAMES/</url>
      
        <content type="html"><![CDATA[<h1 id="LARP-LANGUAGE-AGENT-ROLE-PLAY-FOR-OPEN-WORLD-GAMES"><a href="#LARP-LANGUAGE-AGENT-ROLE-PLAY-FOR-OPEN-WORLD-GAMES" class="headerlink" title="LARP: LANGUAGE-AGENT ROLE PLAY FOR OPEN-WORLD GAMES"></a>LARP: LANGUAGE-AGENT ROLE PLAY FOR OPEN-WORLD GAMES</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>语言智能体在特定场景和有限时间内展现出了令人赞叹的问题解决能力。然而，随着开放世界模拟的复杂性不断演变，迫切需要能够灵活适应复杂环境并持续保持长期记忆以确保连贯行动的智能体。为了弥合语言智能体与开放世界游戏之间的差距，我们推出了用于角色扮演的语言智能体（LARP），它包含一个涵盖记忆处理和决策辅助的认知架构、一个具有反馈驱动的可学习行动空间的环境交互模块，以及一种促进各种角色一致性的后处理方法。LARP 框架优化了具有独特背景和角色的用户与智能体之间的互动，最终提升了开放世界环境中的游戏体验。此外，它还凸显了语言模型在娱乐、教育及各种模拟场景等一系列领域的多样化应用。项目页面发布于<a href="https://miao-ai-lab.github.io/LARP/">https://miao-ai-lab.github.io/LARP/</a> 。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大型语言模型（LLMs）是一类机器学习模型，能够执行多种自然语言处理（NLP）任务，如文本生成、语言翻译以及以对话形式回答问题。“大型” 这一术语指的是语言模型在学习过程中能够更新的大量参数。随着预训练生成模型技术的发展以及大规模综合数据集的构建，一些表现优异的大型语言模型拥有多达数千亿个参数 [图夫龙等人，2023 年；拉德福德等人，2018 年、2019 年；布朗等人，2020 年；欧阳等人，2022 年；OpenAI，2023 年]。此外，由于大型语言模型的进步，人工智能实体近年来成为热门话题。这些人工智能实体通常被称为智能体 [罗素和诺维格，2010 年；伍尔德里奇和詹宁斯，1995 年]，是大规模人工智能系统的基本组成部分。通常，在通用人工智能领域，智能体是一种人造实体，它可以通过传感器感知周围环境、做出决策并通过执行器做出响应。随着大型语言模型和智能体的发展，出现了将它们结合为一个称为语言智能体的单一实体的新趋势。这些语言智能体是通过整合大型语言模型和智能体设计而构建的 [王等人，2023a；习等人，2023 年；苏默斯等人，2023 年]。</p><p>作为与计算机密切相关的行业，游戏与通用语言智能体的发展愈发紧密相连。大语言模型和智能体的应用也越来越广泛。在相关研究中，有大量文献探讨了语言智能体在文本游戏 [丹贝科迪等人，2020 年；辛格等人，2021 年；姚等人，2021 年；乌尔班内克等人，2019 年] 和对抗性游戏 [OpenAI 等人，2019 年；阿鲁库马兰等人，2019 年] 中的应用。与此同时，随着大语言模型能力的提升，开放世界游戏已成为语言智能体应用的前沿领域。这是因为开放世界游戏中存在独特且具有挑战性的场景，为通用语言智能体提供了丰富的实践土壤。开放世界游戏呈现出丰富、动态且引人入胜的环境，包含复杂的任务和故事情节。它们需要借助智能体为非玩家角色赋予多样化的行为。尽管众多研究已经提出了通用的架构</p><p>尽管语言智能体已应用于《我的世界》等开放世界游戏中（Lin 等人，2023 年；Park 等人，2023 年），但通用智能体与开放世界游戏的整体需求之间仍存在差距。通用语言智能体旨在解决现实环境中的各种问题，其主要要求是通用性和对人类行为的模拟。这些智能体能够适应各种环境和任务，不受固定角色的限制。然而，这些通用语言智能体在实际的开放世界环境中面临着重大挑战。这些挑战包括但不限于理解复杂环境、记忆长期事件、生成与角色和环境设定相符的表达，以及从与环境的交互中持续学习。</p><p>因此，在这项工作中，我们提出了一个面向开放世界游戏的、以游戏为导向的角色扮演智能体框架 —— 角色扮演语言智能体（LARP）。LARP 专注于将开放世界游戏与语言智能体相融合，采用模块化方法进行记忆处理、决策制定以及从交互中持续学习。在智能体的内部描述中，我们基于认知心理学设计了一个复杂的认知架构，赋予 LARP 框架下的智能体较高的可玩性和独特性。为了产生更逼真的角色扮演体验，我们利用开放世界游戏环境的数据和上下文、预先设定的个性、知识、规则、记忆以及后置约束对智能体进行规范，这可以看作是通用语言智能体中的一个特定案例。至于一般的智能体架构，它通常需要一个大规模语言模型。然而，我们的架构整合了一组较小的语言模型，每个模型针对不同领域进行微调，以分别处理各种任务。这种设计为开发用于开放世界角色扮演游戏的语言智能体带来了新的体验和视角。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250524144544244.png" alt="image-20250524144544244"></p><blockquote><p>图 1：LARP 的认知架构概述。</p></blockquote><p>本文余下部分的结构安排如下：第 2 节讨论了智能体框架和智能体组件方面的相关研究。在第 3 节中，我们介绍 LARP 的认知架构部分。在第 4 节中，我们重点介绍环境交互模块，在第 5 节中，我们介绍智能体多样化个性的校准。第 6 节进行讨论，随后在第 7 节对全文进行总结。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="智能体框架"><a href="#智能体框架" class="headerlink" title="智能体框架"></a>智能体框架</h3><p>首先，我们将介绍一些与语言智能体角色扮演和模拟相关的研究，这些研究旨在提升大语言模型的角色扮演能力并突出其独特特征。这些研究还旨在增强智能体与用户之间的交互能力，使智能体显得更具自我意识 [Wang 等人，2023b；Shao 等人，2023；Shanahan 等人，2023；Li 等人，2023a]。其他研究则聚焦于多个智能体之间的角色扮演与交互，其中包括协作完成任务 [Li 等人，2023b；Chen 等人，2023a；Qian 等人，2023；Li 等人，2023c；Wu 等人，2023]、模拟日常活动 [Lin 等人，2023；Park 等人，2023；Wang 等人，2023c；Liu 等人，2023a] 以及推动辩论进展 [Liang 等人，2023；Du 等人，2023；Chan 等人，2023] 等场景。</p><p>除此之外，语言智能体也应用于开放世界环境中。不仅在基于文本的游戏中有应用实例 [乌尔班内克等人，2019 年；科特等人，2019 年；豪斯克内希特等人，2020 年]，在诸如《我的世界》等开放世界环境的探索任务中也有应用 [王等人，2023 年 d、e；朱等人，2023 年]。</p><h3 id="智能体组件"><a href="#智能体组件" class="headerlink" title="智能体组件"></a>智能体组件</h3><p>在本节中，我们将介绍一些与语言智能体组件设计相关的研究。一个智能体系统通常分为三个部分：记忆、规划和行动（工具使用）[翁，2023]。记忆系统是事实、思考等内容的储存库，需要具备存储和检索能力。因此，记忆方面的研究主要涉及输入 / 输出功能，包括记忆压缩 [胡等人，2023]、存储和检索 [朴等人，2023；钟等人，2023；黄等人，2023]。</p><p>规划组件负责与智能体行为和语言相关的决策方面。智能体的能力在很大程度上取决于这一部分。规划能力 [Yao 等人，2023 年；Liu 等人，2023b；Yao 等人，2022 年；Shinn 等人，2023 年；Liu 等人，2023c；Wang 等人，2023f] 和推理能力 [Wei 等人，2022 年；Madaan 等人，2023 年] 在该组件中得以实现，相关工作通常围绕这两种能力展开。</p><p>最后一个部分是工具使用和行动，这意味着智能实体的能力得到了增强，帮助它们执行更复杂、更困难的任务。这部分的研究包括工具使用 [中野等人，2021 年] 和学习新行动 [席克等人，2023 年]。</p><h2 id="认知架构"><a href="#认知架构" class="headerlink" title="认知架构"></a>认知架构</h2><p>认知架构是开放世界游戏中角色扮演语言智能体的一个基本组成部分。它提供了一个逻辑框架，并使智能体能够进行自我识别。认知架构如图 2 所示。它由四个主要模块组成：长期记忆、工作记忆、记忆处理和决策。长期记忆模块是主要的存储库，具有巨大的存储容量来存放记忆。工作记忆则像一个空间有限的临时缓存来存储记忆。记忆处理模块是认知架构中最重要的单元。然后，决策模块根据检索到的信息推导出智能体的后续行动。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250524144606698.png" alt="image-20250524144606698"></p><blockquote><p>图 2：LARP 的认知工作流程。这代表一个循环：来自长期记忆和观察的信息在记忆处理模块中进行处理，然后传输到工作记忆模块。工作记忆模块中的信息与观察到的信息一起输入到决策辅助模块，最终生成决策或对话。记忆处理主要有三个阶段：编码、存储和回忆。编码是将信息转化为可存储在记忆中的形式的过程。存储是在记忆中保存信息的过程。回忆是从记忆中检索信息的过程。</p></blockquote><h3 id="长期记忆"><a href="#长期记忆" class="headerlink" title="长期记忆"></a>长期记忆</h3><p>在认知科学中，长期记忆（LTM）由两种类型的记忆组成：陈述性记忆和程序性记忆。陈述性记忆又进一步分为语义记忆和情景记忆 [莱尔德，2019 年，图尔文等人，1972 年]。语义记忆是指通过关于世界的概念性和事实性知识获得的一般性知识记忆。在开放世界游戏的背景下，它可以被视为封装游戏规则以及与相关世界观一致的记忆的部分。在该系统中，我们将语义记忆分为两部分。其中一部分通过外部数据库实现，因为其内容不经常变动。同时，一些语义记忆以符号语言的形式存储在长期记忆模块中。</p><p>情景记忆是指个体对自身经历的特定事件的记忆。这些记忆可能与其他玩家或智能体相关。在我们的记忆系统中，长期记忆模块采用了向量数据库来存储和检索这些记忆。由于记忆可能会被遗忘，因此引入了相关的衰减参数，随着时间的推移，关联度分数会降低。在与大语言模型进行推理时，可以通过向量查询轻松检索此类记忆内容。</p><p>程序性记忆指的是无需有意识思考就能执行的动作或技能 [罗迪格，1990]，比如游泳、骑自行车等。这些具有动作属性的技能，在我们的系统中被表示为动作空间中的应用程序编程接口（API）。动作空间分为公共 API 和个人 API。个人 API 可以通过学习来扩展 [苏默斯等人，2023]，这在第 4 节中有提及。</p><p>在长期记忆模块中，我们将所有感知到的记忆分别存储在语义记忆区和情景记忆区。我们提出了一种名为基于问题的查询方法，该方法生成自问问题作为查询语句，可用于向量相似度搜索和谓词逻辑搜索。这种方法有助于在回忆模块中检索语义记忆和情景记忆，从而提高记忆利用的整体效率。</p><h3 id="工作记忆"><a href="#工作记忆" class="headerlink" title="工作记忆"></a>工作记忆</h3><p>工作记忆主要保存执行复杂认知任务（如推理和学习）以及交互任务所需的观察信息和检索到的长期记忆【巴德利，2003 年；米勒等人，2017 年】。这些信息通常是通过智能体的观察获得的，以游戏方提供的自然语言数据形式呈现。短期记忆，顾名思义，代表了记忆的一个阶段，它在短时间内保留信息，一般只持续几秒到一分钟【阿特金森和希夫林，1968 年】。对于人类而言，短期记忆中保留项目的平均容量约为 7±2 个，保留时长约为 20 到 30 秒【米勒，1956 年】。在这项工作中，这两个概念被实现为同一个模块，统称为工作记忆。在我们的架构中，它作为一个数据缓存存在，信息从其中提取并放入提示的上下文环境中。其提取过程将在记忆处理和决策部分进一步详细说明。</p><h3 id="内存处理"><a href="#内存处理" class="headerlink" title="内存处理"></a>内存处理</h3><p>记忆处理模块主要负责处理已存储和即将存储的记忆。记忆的三个主要阶段是编码、存储和回忆 [梅尔顿，1963 年]。具体来说，感知到的输入信息被编码并转化为长期记忆中的内容，使其能够在长期记忆空间中被回忆起来。在实时角色扮演（LARP）中，我们通过处理游戏中提供的所有结构化观察信息，将其与检索到的内容相结合，并存储在工作记忆中来模拟这一过程。这些信息作为决策模块中一系列逻辑处理单元的输入，不断更新工作记忆中的内容。一旦工作记忆的长度达到一定阈值，就会触发反思，在此期间过滤掉无效记忆，并将处理后的自然语言记忆和符号语言记忆分别存储为情景记忆和语义记忆。</p><p>记忆编码的核心是语言转换系统。通过对齐语言模型和概率模型，自然语言被转换为概率编程语言（PPL）[Wong 等人，2023 年] 和逻辑编程语言。概率编程语言主要处理概率推理，而逻辑编程语言主要涉及事实推理。此外，记忆编码还应受到先验知识一致性的影响，这意味着过去的知识会影响当前的理解 [巴特利特，1995 年]。记忆的存储在长期记忆部分已经详细阐述。</p><p>对人类来说，回忆是指从过去检索信息的心理过程。而在我们的架构中，它是从长期记忆中检索信息的过程。它首先涉及从长期记忆中进行复合检索，包括通过向量相似性和谓词逻辑进行搜索。首先，我们采用自问策略来形成查询，促使大语言模型（LLM）提出有关智能体的观察、个性和经历的问题。在获得查询后，我们采用 3 种方法进行检索。对于逻辑编程搜索，大语言模型会用一种逻辑编程语言生成一个查询，根据可用的规则和事实来回答自问的问题。对于相似性搜索，有两种方法可用。一种方法是将自问的问题作为向量相似性搜索的查询，与情景记忆向量数据库中的问答对进行匹配。另一种方法是使用从自问问题中提取的关键词与同一数据库中的自然语言记忆进行匹配。这个过程将重复进行，直到获得最终答案，这也可以被视为语义检索 [普雷斯等人，2022 年]。图 3 展示了详细的控制流。</p><p>基于回忆能力，我们的架构采用思维链（CoT）[魏等人，2022年]对检索到的内容和观察到的信息进行推理，并执行记忆重建，即利用先验知识在一定程度上影响观察到的事实[洛夫特斯和帕尔默，1974年]，尽管重建的记忆可能会被扭曲。此外，我们还在回忆工作流程中模拟了人类遗忘的过程。当检索系统运行时，我们引入一个由威克尔格伦符号表示的衰减参数，来标记该记忆的遗忘概率[威克斯特德和卡瓦纳，2007年]。计算公式如下：<br>$$<br>\alpha = \alpha \lambda N (1 + \beta t)^{-\psi}<br>$$<br>在这里，$\lambda$表示重要度，由评分模型给出。$N$ 代表该记忆的检索次数，$t$ 是上次检索后经过的时间。$\psi$ 是每个字符的遗忘率，$\alpha$ 和 $\beta$ 分别是重要性和时间的缩放参数。通过多轮记忆重建和遗忘过程，我们的认知架构最终可以模拟记忆扭曲的实例。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250524144619144.png" alt="image-20250524144619144"></p><blockquote><p>图3：回忆心理过程的详细控制流程。首先针对观察内容进行自我提问，以得到自我提问的问题。将这些自我提问的问题作为查询内容，采用不同的检索方法。1. 基于查询内容，用逻辑编程语言和概率编程语言生成谓词逻辑语句。2. 从查询内容中提取关键词后，进行向量相似度搜索。3. 基于查询内容与问答对中的问题之间的句子相似度，搜索问答对。</p><p>$Q_{self-ask}$ 表示用作查询内容的自我提问的问题，$Q_{logic}$ 代表谓词逻辑查询语句，$Q_{key}$ 是提取的关键词，$Q’A$ 代表问答对。</p></blockquote><h3 id="决策制定"><a href="#决策制定" class="headerlink" title="决策制定"></a>决策制定</h3><p>决策模块在观察和工作记忆的共同作用下产生最终决策。决策模块的核心部分是一组有序的可编程单元。每个单元将处理工作记忆和上下文环境中的内容，并实时将结果更新到工作记忆中。这些单元可以是简单的信息处理单元，如进行情感计算的单元，也可以是配备了经过特定微调的大语言模型的复杂单元，如意向分析和输出格式化单元。这些单元具有无限的可扩展性，可以处理所有类型的记忆处理任务。当每个单元与工作记忆进行通信时，它会实时更新工作记忆，使智能体在过程中观察发生变化时能够及时做出反应。这些单元的执行顺序将由一个语言模型助手确定。决策模块的最终输出可以是给非玩家角色（NPC）的任务或对话内容。</p><h3 id="环境交互"><a href="#环境交互" class="headerlink" title="环境交互"></a>环境交互</h3><p>对于开放世界游戏中的角色扮演语言智能体而言，通过认知架构基于当前观察生成任务，仅能在智能体内部达成目标。然而，在具有自由行动和丰富游戏内容的开放世界游戏中，智能体需要通过连接内部与外部来与游戏环境进行交互。在运用语言智能体与开放世界游戏环境进行交互方面已有诸多研究成果 [Wang 等人，2023d；Zhu 等人，2023；Yang 等人，2023；Wang 等人，2023e]。例如，Voyager 采用自动课程的概念，通过向 GPT4 输入环境观察的内容和状态来获取目标。然后，促使 GPT4 生成实现这些目标的功能代码。该论文还提出了技能库方法，即将生成代码的描述作为键，代码本身作为值进行嵌入，从而实现较高的……</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250524144630600.png" alt="image-20250524144630600"></p><blockquote><p>图 4：环境交互</p></blockquote><p>通过添加键值对来融入新技能的可扩展性。章鱼（Octopus）利用视觉语言模型（VLM）来获取观察结果。然而，这种方法可能导致数据特征分布的维度较高，从而导致可控性较差。此外，视觉语言模型的运营成本较高，并且在游戏中收集数据集的先验知识也具有挑战性。</p><p>图 4 展示了基本交互流程。“内部” 指的是工作记忆以及根据当前情况需要执行的任务，这些任务由观察和认知架构生成。“行动空间” 是智能体在游戏世界中可执行的行动应用程序编程接口，包括公共和个人应用程序编程接口。个人应用程序编程接口库存储任务与应用程序编程接口对，而公共应用程序编程接口是基本行动。一个个人应用程序编程接口可以是一系列基本行动，有助于快速决策和应用程序编程接口的复用。</p><p>一旦我们在决策模块中生成了相应的计划，我们首先尝试将整体任务目标分解为几个子任务目标。这些子任务目标呈现为严格有序且对顺序敏感的安排。对于每个任务目标或子任务目标，整个系统会将其与工作记忆进行整合。然后，系统会使用检索器分别在个人 API 库和公共 API 库中进行搜索。如果任务对应的操作已存在于个人 API 库中，该操作将立即执行。否则，系统会使用整个动作空间和内部内容完成相应的提示，通过微调的大语言模型生成结构化代码。生成的代码块成功执行并验证后，将以（任务，API）的形式作为新接口存储在个人 API 库中以备将来使用。如果验证失败，反思单元将被激活以生成新的代码块 [申恩等人，2023 年]。</p><p>同时，我们还收集配对的提示和生成的代码，作为微调代码生成大语言模型的训练集 [帕蒂尔等人，2023 年]。在成功执行和验证后，结果通过基于人类反馈的强化学习进行反馈，以增强模型的能力。</p><h3 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h3><p>在角色扮演中，不同个性对于提升语言智能体的认知能力至关重要。协调可变的个性特征，能让语言模型更好地理解不同观点，并描绘出各种文化和社会群体。在复杂场景中扮演不同角色的语言模型，必须以其独特的方式进行深度理解、回应和表达。这就要求模型具备类似人类的思维过程，且拥有丰富多样的个性。理解多样化语言表达的生成方式、处理多元文化内容，以及展现不同的思想、观点、情感和态度，所有这些都需要模型适应这些独特的个性。因此，本节将深入探讨其实现方式。</p><p>LARP 采用模拟一组经过不同对齐方式微调的模型的策略，以应对智能体的多样化观点。这些模型可能应用于不同模块。在训练阶段，我们预训练了几个不同规模的基础模型。我们的预训练数据集包含不同文化和群体的观点。预训练后，这些基础模型在一系列关于人物角色和性格特点的指令数据集上进行有监督微调（SFT），以增强指令遵循和角色扮演能力 [Chen 等人，2023b；Dong 等人，2023]。这个指令数据集是通过基于 SOTA 模型生成的问答对进行数据提炼而建立的。然后，通过基于人类反馈的评估、修改和调整对该数据集进行优化。</p><p>可以创建多个数据集，并针对反思、代码生成和意图分析等能力对 LoRA（低秩自适应）进行微调。这些 LoRA 可以动态集成到不同规模的基础模型中，创建一个具有不同能力和特性的模型集群。这些能力涵盖语言风格、情感、动作生成、反思、记忆重构等任务。</p><p>然而，微调语言模型以构建不同的 LoRA 以进行角色扮演的主要挑战之一是获取质量数据。成功的微调需要高质量的自定义数据集，需要仔细构建这些数据集以捕获角色的各个方面，包括他们的语言风格、行为风格、个性特征、成语、背景故事等。数据集的构建需要大量的文学创作、剧本汇编和角色研究，以确保生成的语言不仅适合角色的角色和特征，而且以适当的方式与用户互动 [Wang et al.， 2023b]。</p><p>为丰富智能体的多样性，我们设立了多个后处理模块，包括行动验证模块和冲突识别模块。行动验证模块是环境交互模块的一部分，用于检查生成的行动能否在游戏中正确执行。相反，在认知架构中，冲突识别模块检查决策和对话是否与角色关系、个性和游戏世界观存在冲突。一旦检测到此类冲突，该模块将采取诸如拒绝结果或重写等措施，以防止智能体行为不符合角色设定。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="多智能体协作与智能体社会化"><a href="#多智能体协作与智能体社会化" class="headerlink" title="多智能体协作与智能体社会化"></a>多智能体协作与智能体社会化</h3><p>在本文所提出的框架下，单个语言智能体进行角色扮演，不足以解决开放世界游戏中创造丰富内容的问题。为了让由智能体支撑的每个角色栩栩如生，需要建立一个强大的社交网络。一种可行的方法是在大语言模型驱动的智能体之上构建合适的社会学机制和行为，以确保非玩家角色在经过大量的角色扮演推理后，仍能保持其理性和逻辑。</p><h3 id="模型集群的置信度与评估反馈系统"><a href="#模型集群的置信度与评估反馈系统" class="headerlink" title="模型集群的置信度与评估反馈系统"></a>模型集群的置信度与评估反馈系统</h3><p>将语言模型与认知科学相结合，能使语言智能体更贴近人类真实认知。这种方法有效缓解了单个大模型因数据不足而无法提升角色扮演效果的问题。同时，由于认知系统仅由领域任务构成，经过微调的小规模模型就能取得不错的性能，与微调大模型相比还节省了成本。然而，由于语言模型输出结果具有随机性，每个任务产生的结果累积偏差会如何影响整个认知架构的偏差难以预测，这很困难。可以说这样一个扭曲的智能体可被称为类人可信智能体。因此，需要一个相应的评估和测量框架，对认知系统的扭曲施加约束并使其收敛。为整个系统建立测量和反馈机制，以测量每个逻辑单元的逻辑偏差，能够优化系统的稳健性，并将单个系统扭曲对整体系统的影响降至最低。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本研究中，我们提出了一个面向开放世界游戏的语言智能体框架，并从认知架构、环境交互以及与不同价值视角的一致性这三个方面对该框架进行了详细阐述。在认知架构方面，我们运用了认知科学中更为复杂的技术，使智能体能够做出更合理的决策，同时实施后处理约束，以防止智能体出现过度自由的情况，从而使其在角色扮演场景中更接近真实的人类行为。我们设想，我们的工作在开放世界游戏领域具有巨大的潜力，能够为这一传统领域注入新的活力，并最终提供类似于《西部世界》的体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> NPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAGA 面向代理的技能到行动生成框架</title>
      <link href="/2025/05/24/saga_translation_with_images/"/>
      <url>/2025/05/24/saga_translation_with_images/</url>
      
        <content type="html"><![CDATA[<h1 id="SAGA-面向代理的技能到行动生成框架"><a href="#SAGA-面向代理的技能到行动生成框架" class="headerlink" title="SAGA: 面向代理的技能到行动生成框架"></a>SAGA: 面向代理的技能到行动生成框架</h1><h2 id="英文原文-Original-Text"><a href="#英文原文-Original-Text" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h1 id="Announcing-SAGA-Skill-to-Action-Generation-for-Agents"><a href="#Announcing-SAGA-Skill-to-Action-Generation-for-Agents" class="headerlink" title="Announcing SAGA: Skill to Action Generation for Agents."></a>Announcing SAGA: Skill to Action Generation for Agents.</h1><p>Demo Video of SAGA in Action</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Today, we are announcing SAGA: Skill to Action Generation for Agents, a generative AI framework that steers AI Agents toward successful goals through Actions. SAGA is inspired in part by Joon Park’s Generative Agents paper where Agents inhabit the 2D simulated town of Smallville. As well as the work on Voyager from Jim Fan, et al, in which Agents have a set of predefined Skills they can choose from but can also create new skills as they perform tasks in the 3D game, MineCraft.</p><p>You can <a href="https://github.com/fablestudio/fable-saga">find the code on GitHub</a>.</p><p>A Day in Thistle Gulch - Blackjack and Sheriff Cooper work to thwart each other’s plans</p><h2 id="中文翻译-Chinese-Translation"><a href="#中文翻译-Chinese-Translation" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h1 id="宣布SAGA：面向代理的技能到行动生成框架"><a href="#宣布SAGA：面向代理的技能到行动生成框架" class="headerlink" title="宣布SAGA：面向代理的技能到行动生成框架"></a>宣布SAGA：面向代理的技能到行动生成框架</h1><p>SAGA实际运行的演示视频</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天，我们宣布推出SAGA：面向代理的技能到行动生成框架（Skill to Action Generation for Agents），这是一个通过行动引导AI代理实现成功目标的生成式AI框架。SAGA的部分灵感来自Joon Park的生成式代理（Generative Agents）论文，该论文中的代理居住在名为Smallville的2D模拟小镇中。同时也受到Jim Fan等人开发的Voyager项目的启发，在该项目中，代理拥有一组预定义的技能可供选择，但也可以在执行3D游戏Minecraft中的任务时创建新技能。</p><p>您可以<a href="https://github.com/fablestudio/fable-saga">在GitHub上找到代码</a>。</p><p>蓟草峡谷的一天 - Blackjack和Sheriff Cooper努力阻挠彼此的计划</p><hr><h2 id="英文原文-Original-Text-1"><a href="#英文原文-Original-Text-1" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h3 id="Skills-in-Action"><a href="#Skills-in-Action" class="headerlink" title="Skills in Action"></a>Skills in Action</h3><p>With SAGA, Agents first tell SAGA contextual metadata about themselves and their world via a companion simulation: Who they are; What they know; What “Skills” they have; And what their goals are. Then, when an Agent is deciding what to do next, SAGA generates a set of “Actions” that best serve the Agent’s goals in that moment. These Action options are then scored and returned to the simulation in order to direct the Agent. This process repeats each time the Agent is deciding its next action and can be scaled to multiple agents running simultaneously.</p><p>An Action is just an implementation of a Skill as we will discuss. For now, think of Skills as a list of tools in a toolbox that the AI can employ in a specific way to advance a goal. For instance “Talk To” is a Skill, where an Agent can go talk to someone. If the Agent’s goal is to investigate a crime, then “Talk To <PERSON> about <TOPIC>“ forms a specific Action the Agent can then carry out.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>Examples of how Skills become Actions</p><h2 id="中文翻译-Chinese-Translation-1"><a href="#中文翻译-Chinese-Translation-1" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h3 id="技能付诸行动"><a href="#技能付诸行动" class="headerlink" title="技能付诸行动"></a>技能付诸行动</h3><p>通过SAGA，代理首先通过配套模拟向SAGA提供关于自身和所处世界的上下文元数据：他们是谁；他们知道什么；他们拥有哪些”技能”；以及他们的目标是什么。然后，当代理决定下一步行动时，SAGA会生成一系列最能满足代理当前目标的”行动”。这些行动选项随后会被评分并返回给模拟系统，以指导代理。每当代理决定其下一步行动时，这个过程就会重复一次，并且可以扩展到多个同时运行的代理。</p><p>正如我们将讨论的，行动只是技能的一种实现。现在，可以将技能视为AI可以以特定方式使用的工具箱中的工具列表，以推进目标。例如，”与某人交谈”是一种技能，代理可以去与某人交谈。如果代理的目标是调查犯罪，那么”与&lt;某人&gt;谈论&lt;某话题&gt;”就形成了一个特定的行动，代理随后可以执行这个行动。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>技能如何转变为行动的示例</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523115938242.png" alt="image-20250523115938242"></p><hr><h2 id="英文原文-Original-Text-2"><a href="#英文原文-Original-Text-2" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="Pairing-With-a-Simulation"><a href="#Pairing-With-a-Simulation" class="headerlink" title="Pairing With a Simulation"></a>Pairing With a Simulation</h2><p>SAGA is B.Y.O.S.: Bring Your Own Simulation</p><p>SAGA is a B.Y.O.S. or Bring Your Own Simulation framework.</p><p>After responding with Action options, SAGA’s work is mostly done. It still receives information from the paired simulation it is connected to, but simulating the action itself, including generating conversations, or moving around an environment is left to the simulation to implement.</p><p>A set of starter Skills that leverage parts of our proprietary simulation (not currently publicly available) is provided, but other simulations, even very simple ones with only a few Skills, can be used as an alternative via the python library or by connecting to the framework over a network via its built-in socket-io server. See the Github repository for more information on documentation and integrating with your own simulation.</p><p>Using a preview of our Thistle Gulch simulation, let’s explore a more contextual example of how SAGA works in practice. Note that Thistle Gulch is still in development, so the details and visuals here are all subject to change. We will be announcing more about Thistle Gulch and “The Simulation” framework it’s built upon in the future.</p><h2 id="中文翻译-Chinese-Translation-2"><a href="#中文翻译-Chinese-Translation-2" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="与模拟系统配对"><a href="#与模拟系统配对" class="headerlink" title="与模拟系统配对"></a>与模拟系统配对</h2><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120006872.png" alt="image-20250523120006872"></p><p>SAGA是B.Y.O.S.：自带模拟系统（Bring Your Own Simulation）</p><p>SAGA是一个B.Y.O.S.或自带模拟系统框架。</p><p>在响应行动选项后，SAGA的工作基本完成。它仍然接收来自所连接的配对模拟系统的信息，但模拟行动本身，包括生成对话或在环境中移动，都留给模拟系统来实现。</p><p>我们提供了一套利用我们专有模拟系统（目前尚未公开）部分功能的入门技能，但其他模拟系统，即使是只有少量技能的非常简单的系统，也可以通过Python库或通过网络连接到框架的内置socket-io服务器作为替代方案。有关文档和与您自己的模拟系统集成的更多信息，请参阅GitHub存储库。</p><p>使用我们的蓟草峡谷模拟预览版，让我们探索一个更具上下文的SAGA实际工作方式示例。请注意，蓟草峡谷仍在开发中，因此这里的细节和视觉效果都可能发生变化。我们将在未来宣布更多关于蓟草峡谷和它所基于的”The Simulation”框架的信息。</p><hr><h2 id="英文原文-Original-Text-3"><a href="#英文原文-Original-Text-3" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="Murder-in-Thistle-Gulch"><a href="#Murder-in-Thistle-Gulch" class="headerlink" title="Murder in Thistle Gulch"></a>Murder in Thistle Gulch</h2><p>Thistle Gulch is a simulation of a fictional 1800’s Wild-West Town by the same name. It’s currently inhabited by 17 or so characters, but we’ll mainly first focus on two of them.</p><h3 id="Personas"><a href="#Personas" class="headerlink" title="Personas"></a>Personas</h3><p>Let’s briefly explore Blackjack and Sheriff Cooper’s Personas. This is just a brief summary of their data. They also have detailed backstories and memories.</p><p>Blackjack vs Sheriff Cooper</p><h3 id="Meta-Memories"><a href="#Meta-Memories" class="headerlink" title="Meta-Memories"></a>Meta-Memories</h3><p>In order to generate Actions, the simulation needs to provide SAGA with relevant details we call “Meta-Memories”. These are the sum of all the relevant metadata surrounding the simulated world and its Agents. Some of this information will only be available to specific characters, like memories and observations. Other information is shared across characters like the locations, interactable objects, and summaries of other characters.</p><p>Meta-Memories are loaded just before the simulation starts or are streamed in while the simulation is running, as events unfold. This includes details about the activities other characters are performing, their conversations, and new memories that are formed as the simulation progresses.</p><h2 id="中文翻译-Chinese-Translation-3"><a href="#中文翻译-Chinese-Translation-3" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="蓟草峡谷中的谋杀案"><a href="#蓟草峡谷中的谋杀案" class="headerlink" title="蓟草峡谷中的谋杀案"></a>蓟草峡谷中的谋杀案</h2><p>蓟草峡谷是一个虚构的19世纪美国西部同名小镇的模拟。目前居住着约17个角色，但我们主要首先关注其中的两个。</p><h3 id="角色设定"><a href="#角色设定" class="headerlink" title="角色设定"></a>角色设定</h3><p>让我们简要探讨Blackjack和Sheriff Cooper的角色设定。这只是他们数据的简要总结。他们还有详细的背景故事和记忆。</p><p>Blackjack与Sheriff Cooper的对比</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120023216.png" alt="image-20250523120023216"></p><h3 id="元记忆"><a href="#元记忆" class="headerlink" title="元记忆"></a>元记忆</h3><p>为了生成行动，模拟系统需要向SAGA提供我们称为”元记忆”的相关细节。这些是围绕模拟世界及其代理的所有相关元数据的总和。某些信息只对特定角色可用，如记忆和观察结果。其他信息则在角色之间共享，如位置、可交互对象和其他角色的概述。</p><p>元记忆在模拟开始前加载，或者在模拟运行时随着事件的展开而流入。这包括其他角色正在执行的活动、他们的对话以及随着模拟进展而形成的新记忆等详细信息。</p><hr><h2 id="英文原文-Original-Text-4"><a href="#英文原文-Original-Text-4" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="The-Murder-Investigation"><a href="#The-Murder-Investigation" class="headerlink" title="The Murder Investigation"></a>The Murder Investigation</h2><p>The Sheriff considers what the evidence means</p><p>To test SAGA, we created an example scenario within Thistle Gulch where characters are forced to make choices about what to do next with clear and time sensitive goals, and constraints that confound those goals: The murder of a local native.</p><p>In our fictional scenario, a native from the local tribe was found dead just outside of town. The tribe’s chief has threatened to take things into his own hands if Sheriff Cooper doesn’t uncover the murderer quickly. Blackjack, the saloon owner and local gang leader, is also unsure who the murderer is, but he doesn’t want any investigation to blow back on him and ruin his plans to rob the stagecoach in a few weeks.</p><p>As the sun rises over Thistle Gulch on the start of Day 1, the Sheriff is standing next to the native’s remains and Blackjack is standing in his Saloon. Both are Agents and separately deciding what to do next via SAGA. The Meta-Memory of this 3 day window in which to solve the case encourages the characters to move forward in their own ways and achieve a timely conclusion.</p><h3 id="Sheriff-Cooper"><a href="#Sheriff-Cooper" class="headerlink" title="Sheriff Cooper"></a>Sheriff Cooper</h3><p>Sheriff Wyatt Cooper, choosing from the list of Actions provided by SAGA, first decides to do the “Search Near the Dead Native” Action, which uses his “interact” Skill. The “interact” Skill has access to a list of all interactable simulation objects and what interactions, often human authored, they afford the agent. Here, the generated Action becomes “<em>Interact with <Dead Native> and do the <Search Near the Dead Native> interaction that it provides</em>“.</p><p>After discovering blood and bullet casings during that interaction, SAGA uses yet another skill called “reflect”. The Action becomes “<em>Reflect on <The blood is fresh and there are bullet casings></em>“ where he decides to get to the bottom of this immediately, as seen in this conversation with himself within the Thistle Gulch UI.</p><h3 id="Saloon-Owner"><a href="#Saloon-Owner" class="headerlink" title="Saloon Owner"></a>Saloon Owner</h3><p>For Blackjack’s Agent, SAGA leverages the “Reflect” Skill to generate the “<em>Reflect on <Dead native situation affecting town stability></em>“ Action. He then resolves to steer the investigation’s outcome in a direction that benefits himself and his plans.</p><h2 id="中文翻译-Chinese-Translation-4"><a href="#中文翻译-Chinese-Translation-4" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="谋杀调查"><a href="#谋杀调查" class="headerlink" title="谋杀调查"></a>谋杀调查</h2><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120107338.png" alt="image-20250523120107338"></p><p>警长思考证据的含义</p><p>为了测试SAGA，我们在蓟草峡谷中创建了一个示例场景，角色被迫在明确且时间敏感的目标下做出关于下一步行动的选择，同时面临阻碍这些目标的约束条件：一名当地原住民被谋杀的案件。</p><p>在我们的虚构场景中，一名来自当地部落的原住民在镇外被发现死亡。部落酋长威胁说，如果Sheriff Cooper不能迅速找出凶手，他将亲自处理此事。酒馆老板兼当地帮派头目Blackjack也不确定谁是凶手，但他不希望任何调查影响到他几周后抢劫马车的计划。</p><p>在第一天开始时，当太阳升起在蓟草峡谷上空，警长站在原住民遗体旁，而Blackjack则站在他的酒馆里。两人都是代理，通过SAGA分别决定下一步行动。关于这个3天时间窗口内解决案件的元记忆鼓励角色们以自己的方式前进并及时得出结论。</p><h3 id="Sheriff-Cooper-1"><a href="#Sheriff-Cooper-1" class="headerlink" title="Sheriff Cooper"></a>Sheriff Cooper</h3><p>Sheriff Wyatt Cooper从SAGA提供的行动列表中选择，首先决定执行”搜索死去的原住民附近”的行动，这使用了他的”交互”技能。”交互”技能可以访问所有可交互的模拟对象列表以及它们提供给代理的交互方式，这些交互方式通常是由人类编写的。在这里，生成的行动变成了”与&lt;死去的原住民&gt;交互并执行它提供的&lt;搜索死去的原住民附近&gt;交互”。</p><p>在那次交互中发现血迹和弹壳后，SAGA使用了另一个名为”反思”的技能。行动变成了”反思&lt;血迹新鲜且有弹壳&gt;”，他决定立即深入调查这个案件，正如在蓟草峡谷UI中与自己的对话所示。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120133772.png" alt="image-20250523120133772"></p><h3 id="酒馆老板"><a href="#酒馆老板" class="headerlink" title="酒馆老板"></a>酒馆老板</h3><p>对于Blackjack的代理，SAGA利用”反思”技能生成了”反思&lt;死去原住民情况影响镇上稳定&gt;”的行动。然后他决定引导调查结果朝着有利于自己和计划的方向发展。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120145045.png" alt="image-20250523120145045"></p><hr><h2 id="英文原文-Original-Text-5"><a href="#英文原文-Original-Text-5" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><p>After Blackjack is done Reflecting, he needs to decide what skill to use next and how to use that skill. A request is sent to SAGA which returns the following Actions. Each Action has an associated Skill, as shown by the different icons in the image below. As each Action is generated, a given Skill’s parameters are filled in by SAGA’s generative model.</p><p>Action options generated for Blackjack</p><h2 id="Cooperation-and-Conflict"><a href="#Cooperation-and-Conflict" class="headerlink" title="Cooperation and Conflict"></a>Cooperation and Conflict</h2><p>Blackjack and Sheriff Cooper are now in conflict with each other. The Sheriff wants to solve the crime, and Blackjack wants to make sure the investigation doesn’t ruin his plans. They continue to navigate this situation and pursue their disparate goals by generating and then choosing Actions via SAGA as the simulation progresses.</p><p>As both Agents are pursuing their own ends, they are also cooperating with other Agents. The Sheriff talks to the townsfolk looking for leads and cooperation, while Blackjack conspires with his gang to plant evidence and spread rumors to throw him off.</p><p>They may also manipulate the world and not just people to their own ends. The Sheriff will move the native’s body into the jail to preserve the evidence or Blackjack and his goons will find something incriminating and plant that evidence in the scapegoat’s room to frame them for the murder.</p><p>The Thistle Gulch demo video above shows Blackjack cooperating with his gang to draw the sheriff’s attention away from his criminal schemes. While the dialogue is generated by our Simulation, who to talk to and what the topic and goal of the conversations are all generated via SAGA.</p><p>The sheriff and Blackjack are both leveraging SAGA to generate candidate Actions, but here the Sheriff is choosing the option with the highest score automatically. Blackjack pauses when SAGA returns the options so we can see them all. The top option is the highest scoring and is the default choice, but they can also be chosen manually as shown in the video. The video has been edited for time and viewability, but the run wasn’t cherry-picked.</p><h2 id="中文翻译-Chinese-Translation-5"><a href="#中文翻译-Chinese-Translation-5" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><p>在Blackjack完成反思后，他需要决定下一步使用什么技能以及如何使用该技能。向SAGA发送请求，SAGA返回以下行动。每个行动都有一个相关联的技能，如下图中不同图标所示。随着每个行动的生成，SAGA的生成模型会填充给定技能的参数。</p><p>为Blackjack生成的行动选项</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120159076.png" alt="image-20250523120159076"></p><h2 id="合作与冲突"><a href="#合作与冲突" class="headerlink" title="合作与冲突"></a>合作与冲突</h2><p>Blackjack和Sheriff Cooper现在处于相互冲突状态。警长想要解决犯罪，而Blackjack想确保调查不会破坏他的计划。他们继续在这种情况下导航并通过SAGA生成和选择行动来追求各自不同的目标，随着模拟的进行。</p><p>当两个代理追求各自的目标时，他们也在与其他代理合作。警长与镇民交谈寻找线索和合作，而Blackjack则与他的帮派密谋栽赃和散布谣言以转移注意力。</p><p>他们也可能操纵世界而不仅仅是人。警长会将原住民的尸体移到监狱以保存证据，或者Blackjack和他的手下会找到一些罪证并将其栽赃到替罪羊的房间以嫁祸他们谋杀。</p><p>上面的蓟草峡谷演示视频显示Blackjack与他的帮派合作，将警长的注意力从他的犯罪计划上转移开。虽然对话是由我们的模拟系统生成的，但与谁交谈以及对话的主题和目标都是通过SAGA生成的。</p><p>警长和Blackjack都在利用SAGA生成候选行动，但在这里，警长自动选择得分最高的选项。Blackjack在SAGA返回选项时暂停，以便我们可以看到所有选项。最高选项是得分最高的，是默认选择，但它们也可以如视频所示手动选择。视频已经为了时间和可观看性而编辑，但运行并非精心挑选。</p><hr><h2 id="英文原文-Original-Text-6"><a href="#英文原文-Original-Text-6" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><p>Sheriff Cooper convinces Sally McCarty to betray Blackjack</p><p>While most of the time it goes somewhere useful, it can make connections or assumptions that turn out to be counter productive. For instance, even though the murder of the old Sheriff happened a year ago and the case has now gone cold, Wyatt may try to connect the native’s murder investigation back to that old case in a way that feels like he’s getting distracted. As someone with ADD, I know this can be realistic, but the audience will likely question that abrupt change in focus, and result in a less interesting narrative outcome.</p><p>The variation between different iterations of the simulation is based on the SAGA prompt and the LLM settings, but with so much contextual information available, the Agents reliably stay true to their characterization. The Action options that are generated, the scores of those actions, and then of course the simulation itself all have impacts that create the main opportunities for variation.</p><p>We often call this phenomenon “hallucination” on the part of the LLM, but Karpathy made a great point recently that, “hallucination is all LLMs do.” So, hallucination is not really the problem we need to solve, but the nature of the tool we’re using and “it’s greatest feature”. It’s up to us to best guide the model and handle the responses it provides us without locking it down so much that we don’t get what we actually want from it.</p><p>Andrej Karpathy Tweet on the “Hallucination Problem”</p><p>When using a robust simulation like ours, we take the responses that come back from SAGA and do additional validation on them like making sure they are using valid entities in their parameters before even considering them as options. We can also score options and even outcomes through multiple runs of the simulation to generate data for RLHF and fine-tune custom models on the behavior we want it to focus on next time.</p><h2 id="中文翻译-Chinese-Translation-6"><a href="#中文翻译-Chinese-Translation-6" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><p>Sheriff Cooper说服Sally McCarty背叛Blackjack</p><p><img src="D:\Document\typorapic\saga_translation_with_images\image-20250523120214260.png" alt="image-20250523120214260"></p><p>虽然大多数时候它会产生有用的结果，但它也可能做出不利于生产力的连接或假设。例如，即使旧警长的谋杀案发生在一年前，案件现已冷却，Wyatt可能会尝试将原住民谋杀调查与那个旧案件以一种看起来像是分心的方式联系起来。作为一个有注意力缺陷障碍的人，我知道这可能是现实的，但观众可能会质疑那种突然的焦点转变，并导致叙事结果不那么有趣。</p><p>模拟不同迭代之间的变化基于SAGA提示和LLM设置，但有了如此多的上下文信息，代理可靠地保持其特征。生成的行动选项、这些行动的分数，当然还有模拟本身都有影响，创造了变化的主要机会。</p><p>我们经常称这种现象为LLM的”幻觉”，但Karpathy最近指出，”幻觉是所有LLM都会做的事”。所以，幻觉并不是我们需要解决的问题，而是工具的本质和”它最大的特点”。我们的任务是最好地引导模型并处理它提供的响应，而不是过度限制它以至于我们无法从中获得我们真正想要的东西。</p><p>Andrej Karpathy关于”幻觉问题”的推文</p><p><img src="D:\Document\typorapic\saga_translation_with_images\image-20250523120224356.png" alt="image-20250523120224356"></p><p>当使用像我们这样的强大模拟系统时，我们会对从SAGA返回的响应进行额外验证，比如确保它们在参数中使用有效实体，然后才考虑它们作为选项。我们还可以通过模拟的多次运行对选项甚至结果进行评分，以生成RLHF数据并微调自定义模型，关注我们希望它下次关注的行为。</p><hr><h2 id="英文原文-Original-Text-7"><a href="#英文原文-Original-Text-7" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>SAGA is leveraging a technique called “tool-use” popularized by the likes of AutoGPT and ChatGPT (Functions). Like these other projects, SAGA is a tool that builds upon the work of many others and shouldn’t be considered a research paper or fancy new model, but it does achieve very interesting results in a usable package for anyone to extend and experiment with.</p><p>In fact, the Skills definitions can be expanded to other domains like “Search The Web”, “Generate an Image”, or “Recall from Vector Database” if you like. Here, we are focusing on Actions that better match the simulation of human-like characters in a narrative context.</p><h2 id="AI-Planning-in-Context"><a href="#AI-Planning-in-Context" class="headerlink" title="AI Planning in Context"></a>AI Planning in Context</h2><p>Reinforcement Learning in which Agents leverage deep learning to play video games goes back a decade and more, but they have to learn how to play. With Large Language Models (LLMs), one simply has to provide contextual information, perhaps some examples, and then instruct the LLM to complete useful information to reach the goal. Of course this works best for domains where the LLM has seen representative training data, but in the case of human actions, this data is very common in the training set of the Web – we humans do like to talk about ourselves.</p><p>There is also a large space of work in what is generally called “AI Planning” which goes all the way back to the famous “Shakey the Robot” in the late 60s that could break a command down into individualized steps itself. Notably, “Shakey” research is where we get the A* algorithm and the Hough transform, a precursor to Convolutional Neural Nets. There is a lot of interest in using LLMs for Planning right now, be that in robotics, coding and more.</p><h2 id="中文翻译-Chinese-Translation-7"><a href="#中文翻译-Chinese-Translation-7" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>SAGA利用了一种称为”工具使用”的技术，这种技术由AutoGPT和ChatGPT（Functions）等项目普及。与这些其他项目一样，SAGA是一个建立在许多其他人工作基础上的工具，不应被视为研究论文或花哨的新模型，但它确实在一个可用的包中实现了非常有趣的结果，任何人都可以扩展和实验。</p><p>事实上，技能定义可以扩展到其他领域，如”搜索网络”、”生成图像”或”从向量数据库中召回”，如果你愿意的话。在这里，我们专注于更好地匹配在叙事上下文中模拟类人角色的行动。</p><h2 id="AI规划的上下文"><a href="#AI规划的上下文" class="headerlink" title="AI规划的上下文"></a>AI规划的上下文</h2><p>强化学习中代理利用深度学习玩视频游戏的历史可以追溯到十多年前，但它们必须学习如何玩游戏。使用大型语言模型（LLM），只需提供上下文信息，也许一些例子，然后指示LLM完成有用的信息以达到目标。当然，这对于LLM已经见过代表性训练数据的领域效果最好，但在人类行为的情况下，这些数据在网络的训练集中非常常见 - 我们人类喜欢谈论自己。</p><p>还有一大类被广泛称为”AI规划”的工作，可以追溯到60年代末著名的”Shakey机器人”，它可以将命令分解为自己的个性化步骤。值得注意的是，”Shakey”研究是我们获得A*算法和Hough变换的地方，后者是卷积神经网络的前身。现在在机器人、编码等领域使用LLM进行规划有很多兴趣。</p><hr><h2 id="英文原文-Original-Text-8"><a href="#英文原文-Original-Text-8" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="Language-Models-as-Zero-Shot-Planners"><a href="#Language-Models-as-Zero-Shot-Planners" class="headerlink" title="Language Models as Zero-Shot Planners"></a>Language Models as Zero-Shot Planners</h2><p>The closest analog for this work is probably the paper, <a href="https://arxiv.org/abs/2201.07207">“Language Models as Zero-Shot Planners: Extracting Actionable Knowledge for Embodied Agents”</a> from Huang and Abbeel in Jan 2022 that generated action plans for tasks like “Brush teeth”. There, they fine-tuned an LLM on “admissible actions” or actions that could actually be recognized by the VirtualHome simulator instead of just free-form instructions that the simulator wouldn’t recognize.</p><p>Diagram from Language Models as Zero-Shot Planners</p><p>Currently, SAGA doesn’t generate a whole action plan of small steps, instead it generates a list of candidate next-step-actions that are very high-level and parameterizable. This allows the Model to focus on a smaller set of high-level tools that it can apply in a multitude of ways instead of using lower-level or very specific steps to construct an action plan. This has benefits that fine-tuning isn’t necessary and allows the simulation to take on more of the burden of providing and executing the actions, saving time and money for those using a model like GPT-4.</p><h2 id="Generative-Human-like-Agents"><a href="#Generative-Human-like-Agents" class="headerlink" title="Generative Human-like Agents"></a>Generative Human-like Agents</h2><p>In 2023, a lot of additional work has been done in this space, but we will highlight two for now that were also inspirational for how SAGA is architected, the terminology, and getting SAGA released. How SAGA may take a different approach than these projects is also highlighted.</p><p>Diagram from Generative Agents Paper</p><p><a href="https://arxiv.org/abs/2304.03442">Generative Agents: Interactive Simulacra of Human Behavior</a>, Park, et al Apr 2023. Here, Joon created a simple simulation in the browser using a 2D-grid game engine backed by a Python webserver. It also has another Python server running the code that drives the agents. The two communicate by saving a series of specially named files containing either the simulation data (locations of the agents in space), or what actions the agents should take in this step. All agents are evaluated each step and there is interesting work that explores observations, daily planning, and vector database storage/retrieval of memories.</p><p>Outside of research, that architecture makes it difficult to make use of in practice. The lock-step approach also takes a long time between steps and with the complex LLM re-processing overhead <a href="https://twitter.com/goodside/status/1645129328681115648">it can be very expensive to run</a> for someone just looking to experiment.</p><h2 id="中文翻译-Chinese-Translation-8"><a href="#中文翻译-Chinese-Translation-8" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="作为零样本规划器的语言模型"><a href="#作为零样本规划器的语言模型" class="headerlink" title="作为零样本规划器的语言模型"></a>作为零样本规划器的语言模型</h2><p>这项工作最接近的类比可能是这篇论文，<a href="https://arxiv.org/abs/2201.07207">“Language Models as Zero-Shot Planners: Extracting Actionable Knowledge for Embodied Agents”</a>，由Huang和Abbeel于2022年1月发表，该论文为”刷牙”等任务生成行动计划。在那里，他们对LLM进行了微调，使其能够识别”可接受的行动”，即VirtualHome模拟器可以实际识别的行动，而不是模拟器无法识别的自由形式指令。</p><p>来自《作为零样本规划器的语言模型》的图表</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120244409.png" alt="image-20250523120244409"></p><p>目前，SAGA不生成由小步骤组成的完整行动计划，而是生成一个可参数化的高级候选下一步行动列表。这允许模型专注于一组更小的高级工具，它可以以多种方式应用，而不是使用低级或非常具体的步骤构建行动计划。这有好处，不需要微调，并允许模拟承担更多提供和执行行动的负担，为使用像GPT-4这样的模型的人节省时间和金钱。</p><h2 id="生成式类人代理"><a href="#生成式类人代理" class="headerlink" title="生成式类人代理"></a>生成式类人代理</h2><p>2023年，在这个领域已经完成了大量额外的工作，但我们现在将重点介绍两个对SAGA的架构、术语和发布有启发作用的项目。SAGA可能采取与这些项目不同的方法，这一点也被强调。</p><p>来自生成式代理论文的图表</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120256805.png" alt="image-20250523120256805"></p><p><a href="https://arxiv.org/abs/2304.03442">Generative Agents: Interactive Simulacra of Human Behavior</a>，Park等人，2023年4月。在这里，Joon创建了一个在浏览器中使用2D网格游戏引擎的简单模拟，由Python网络服务器支持。它还有另一个运行驱动代理代码的Python服务器。两者通过保存包含模拟数据（代理在空间中的位置）或代理在此步骤中应采取的行动的特殊命名文件进行通信。所有代理在每一步都被评估，有一些有趣的工作探索观察、日常规划和向量数据库存储/检索记忆。</p><p>在研究之外，这种架构使其难以实际使用。锁步方法也需要在步骤之间花费很长时间，并且由于复杂的LLM重新处理开销，<a href="https://twitter.com/goodside/status/1645129328681115648">运行可能非常昂贵</a>，对于只想实验的人来说。</p><hr><h2 id="英文原文-Original-Text-9"><a href="#英文原文-Original-Text-9" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><p>SAGA takes a different approach. It’s available via socket.io so it communicates asynchronously over the web or on a local network. That means Agents and the Simulation don’t need to pause the world while waiting for Actions to be generated, though you can still do that if you like. It also provides a cleaner abstraction between the simulation and what is generating actions. SAGA does the generation based on requests for Actions, and the simulation is free to interpret those actions as it needs.</p><h2 id="Interacting-With-and-Planning-in-a-3D-World"><a href="#Interacting-With-and-Planning-in-a-3D-World" class="headerlink" title="Interacting With and Planning in a 3D World"></a>Interacting With and Planning in a 3D World</h2><p>Diagram from Voyager Paper</p><p><a href="https://arxiv.org/abs/2305.16291">Voyager: An Open-Ended Embodied Agent with LLMs</a> - Jim Fan’s team May 2023. Shortly after “Generative Agents” in 2023 we got “Voyager”, a follow up to Fan’s Team’s “MineDojo” paper and tool of the same name from 2022. Together, they provide an open 3D world by connecting to the popular game MineCraft. MineCraft is the simulation environment and Voyager connects to it via an API that bridges the two called “MineFlayer”. There are no plans to connect SAGA to Minecraft, but pull requests are welcome!</p><p>Voyager also goes beyond the current scope of SAGA as it’s a research project focused on “Life-long learning” and creating new skills via code generation and refinement while essentially leveling the Agent up in Minecraft and learning to craft new things along the way.</p><p>However, Minecraft is a pretty limited simulator for human-like experiences, especially with multiple agents in dialog with each other. Thistle Gulch is mostly concerned with narrative outcomes, so we prioritize Actions that match the Agent’s personality, history, memory and relationships. Our Agents, Blackjack and the Sheriff, are also characters in a Narrative, so we want them to perform their narrative roles and achieve satisfying narrative outcomes as well.</p><h2 id="中文翻译-Chinese-Translation-9"><a href="#中文翻译-Chinese-Translation-9" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><p>SAGA采取了不同的方法。它通过socket.io可用，因此它通过网络或在本地网络上异步通信。这意味着代理和模拟不需要在等待生成行动时暂停世界，尽管如果你愿意，你仍然可以这样做。它还提供了模拟和生成行动之间更清晰的抽象。SAGA基于行动请求进行生成，模拟系统可以根据需要自由解释这些行动。</p><h2 id="在3D世界中交互和规划"><a href="#在3D世界中交互和规划" class="headerlink" title="在3D世界中交互和规划"></a>在3D世界中交互和规划</h2><p>来自Voyager论文的图表</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed3/master/image-20250523120423179.png" alt="image-20250523120423179"></p><p><a href="https://arxiv.org/abs/2305.16291">Voyager: An Open-Ended Embodied Agent with LLMs</a> - Jim Fan的团队，2023年5月。在2023年”Generative Agents”之后不久，我们得到了”Voyager”，这是对Fan的团队2022年的”MineDojo”论文和同名工具的后续。它们共同提供了一个开放的3D世界，通过连接到流行游戏Minecraft。Minecraft是模拟环境，Voyager通过一个名为”MineFlayer”的API桥接连接到它。目前没有计划将SAGA连接到Minecraft，但欢迎提出请求！</p><p>Voyager还超出了SAGA的当前范围，因为它是一个专注于”终身学习”和通过代码生成和改进创建新技能的研究项目，同时本质上在Minecraft中提升代理的等级并学习制作新物品。</p><p>然而，Minecraft作为人类般体验的模拟器相当有限，特别是在多个代理相互对话的情况下。蓟草峡谷主要关注叙事结果，因此我们优先考虑与代理的个性、历史、记忆和关系相匹配的行动。我们的代理，Blackjack和警长，也是叙事中的角色，所以我们希望他们执行其叙事角色并实现令人满意的叙事结果。</p><hr><h2 id="英文原文-Original-Text-10"><a href="#英文原文-Original-Text-10" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>What’s next for SAGA and where do we see it headed? As a v1 release, SAGA is functional but we will continue to support and improve it over time while looking to grow a community interested in it and its applications.</p><h2 id="Challenges-for-Production-Use"><a href="#Challenges-for-Production-Use" class="headerlink" title="Challenges for Production Use"></a>Challenges for Production Use</h2><h3 id="Generation-Times"><a href="#Generation-Times" class="headerlink" title="Generation Times"></a>Generation Times</h3><p>Right now, Generation on the latest GPT-3.5 takes around 3 seconds for 5 Action options, and GPT-4 takes around 30 seconds. The generation time is directly related to the number of generated tokens, not the input prompt so SAGA users should experiment which model and the number of options they actually need in their own context. Right now, this generation of options happens in one LLM request which optimizes input token costs, but it can be parallelized instead. For our demo video, we paused the world while waiting for options to generate and then cut that for time. SAGA already parallelizes the per-character requests so the number of characters doesn’t directly affect the wall-clock generation time.</p><h3 id="Memory-and-Prompt-Size-Limits"><a href="#Memory-and-Prompt-Size-Limits" class="headerlink" title="Memory and Prompt Size Limits"></a>Memory and Prompt Size Limits</h3><p>SAGA keeps the memory model simple at this point, using lists and dictionaries in memory to index and retrieve the records provided by the simulation. Using LLMs with larger prompts and limiting the metadata to recent or important events is a way to expand the amount of Meta-Memories possible without hitting model context window limits. The latest GPT-4 OpenAI models have a 128K token limit now, nearly 100x larger than it was a few years ago.</p><p>To increase the number of Meta-Memories, say to increase the number of characters in the world, their relationships, their individual knowledge, and their memories of events, more complex storage and retrieval techniques are needed. Generation of embeddings to store and retrieve Meta-Memories with Vector DBs like FAISS, knowledge graphs, or even SQL databases to preserve memories are useful techniques to explore, but needs will vary and engineering is all about tradeoffs so we leave those to the user for now.</p><h2 id="中文翻译-Chinese-Translation-10"><a href="#中文翻译-Chinese-Translation-10" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>SAGA的下一步是什么，我们认为它将走向何方？作为v1版本，SAGA是功能性的，但我们将继续支持并随着时间改进它，同时寻求建立一个对它及其应用感兴趣的社区。</p><h2 id="生产使用的挑战"><a href="#生产使用的挑战" class="headerlink" title="生产使用的挑战"></a>生产使用的挑战</h2><h3 id="生成时间"><a href="#生成时间" class="headerlink" title="生成时间"></a>生成时间</h3><p>目前，在最新的GPT-3.5上生成大约需要3秒钟生成5个行动选项，而GPT-4需要大约30秒。生成时间与生成的令牌数量直接相关，而不是输入提示，因此SAGA用户应该实验哪种模型以及在自己的上下文中实际需要的选项数量。目前，这种选项生成发生在一个LLM请求中，这优化了输入令牌成本，但它也可以并行化。对于我们的演示视频，我们在等待选项生成时暂停了世界，然后为了节省时间而剪辑了视频。SAGA已经并行化了每个角色的请求，因此角色数量不会直接影响挂钟生成时间。</p><h3 id="内存和提示大小限制"><a href="#内存和提示大小限制" class="headerlink" title="内存和提示大小限制"></a>内存和提示大小限制</h3><p>SAGA目前保持内存模型简单，使用内存中的列表和字典来索引和检索模拟提供的记录。使用具有更大提示和限制元数据到最近或重要事件的LLM是扩展可能的元记忆量而不触及模型上下文窗口限制的一种方法。最新的GPT-4 OpenAI模型现在有128K令牌限制，几乎比几年前大100倍。</p><p>要增加元记忆的数量，比如增加世界中的角色数量、它们的关系、它们的个人知识以及它们对事件的记忆，需要更复杂的存储和检索技术。生成嵌入以存储和检索带有向量数据库（如FAISS）、知识图或甚至SQL数据库的元记忆是值得探索的有用技术，但需求会有所不同，工程都是关于权衡的，所以我们暂时将这些留给用户。</p><hr><h2 id="英文原文-Original-Text-11"><a href="#英文原文-Original-Text-11" class="headerlink" title="英文原文 (Original Text)"></a>英文原文 (Original Text)</h2><h2 id="SAGA’s-Future-Goals"><a href="#SAGA’s-Future-Goals" class="headerlink" title="SAGA’s Future Goals"></a>SAGA’s Future Goals</h2><p>As the goal of SAGA is steering AI Agents toward successful goals through Actions, the next logical step is to improve those generated Actions. There’s a number of exciting research areas exploring this space lately.</p><p>For instance, SAGA already uses a “test-time compute” tradeoff technique of generating multiple candidate options and then validating and scoring the answers before choosing the best one as a way to get much better results without training a custom model. Related techniques include “Chain-of-thought” and “Tree-of-thought” or search based techniques used in AlphaGo where a model is trained to predict how good an option is likely to be through self-play.</p><p>Improving the Skills (the tools the model has to choose from) also increases the quality of the Actions. For instance, we are working on the “exchange” skill that allows characters to buy, sell, steal, and give items in their inventory. Creating new Skills via code generation like Voyager does, or at least chaining together existing skills to form action-plans is an exciting area of research as well.</p><p>Since SAGA doesn’t ship with a simulation out of the box in order to get started, we will be looking to add a simple text-based simulation to quickly test it out, but we think it’s important to keep the simulation itself separate from SAGA in order to be sim-agnostic. We will be looking for others who want to build their own simulation or use it with existing open source simulators and expect to see rapid support for simple 2D simulations that appeared after the Generate Agents paper.</p><p>Other simulations will have Agents within Gaming or Reinforcement Learning scenarios. Some simulations are engaged in RPG combat like the Neurips MMO Challenge happening this week. We’re excited to build upon SAGA, but also excited to see how the community uses it and contributes back. <a href="https://github.com/fablestudio/fable-saga">Check out the GitHub repo for more information</a>.</p><p>[AI] · [Simulations] · [Agents] · [Tool-Use]</p><p>[Previous Previous Thistle Gulch Simulation Beta Op…]</p><p>[Next Next SAGA Now Available: Open Source]</p><h2 id="中文翻译-Chinese-Translation-11"><a href="#中文翻译-Chinese-Translation-11" class="headerlink" title="中文翻译 (Chinese Translation)"></a>中文翻译 (Chinese Translation)</h2><h2 id="SAGA的未来目标"><a href="#SAGA的未来目标" class="headerlink" title="SAGA的未来目标"></a>SAGA的未来目标</h2><p>由于SAGA的目标是通过行动引导AI代理实现成功目标，下一个合乎逻辑的步骤是改进这些生成的行动。最近有许多令人兴奋的研究领域在探索这个空间。</p><p>例如，SAGA已经使用”测试时计算”权衡技术，生成多个候选选项，然后在选择最佳选项之前验证和评分答案，作为一种在不训练自定义模型的情况下获得更好结果的方法。相关技术包括”思维链”和”思维树”或基于搜索的技术，用于AlphaGo，其中模型被训练预测通过自我对弈选项可能有多好。</p><p>改进技能（模型可以选择的工具）也会提高行动的质量。例如，我们正在开发”交换”技能，允许角色在其库存中购买、出售、偷窃和赠送物品。像Voyager那样通过代码生成创建新技能，或者至少将现有技能链接在一起形成行动计划，是一个令人兴奋的研究领域。</p><p>由于SAGA没有附带开箱即用的模拟系统，为了快速测试，我们将寻求添加一个简单的基于文本的模拟系统，但我们认为保持模拟系统本身与SAGA分离以保持模拟不可知性很重要。我们将寻找希望构建自己的模拟系统或将其与现有开源模拟器一起使用的人，并期望看到对Generative Agents论文之后出现的简单2D模拟的快速支持。</p><p>其他模拟将在游戏或强化学习场景中拥有代理。一些模拟参与RPG战斗，如本周进行的Neurips MMO挑战赛。我们很高兴在SAGA的基础上构建，但也很高兴看到社区如何使用它并做出贡献。<a href="https://github.com/fablestudio/fable-saga">查看GitHub仓库了解更多信息</a>。</p><p>[AI] · [Simulations] · [Agents] · [Tool-Use]</p><p>[Previous Previous Thistle Gulch Simulation Beta Op…]</p><p>[Next Next SAGA Now Available: Open Source]</p><h1 id="SAGA项目代码流程详细解析"><a href="#SAGA项目代码流程详细解析" class="headerlink" title="SAGA项目代码流程详细解析"></a>SAGA项目代码流程详细解析</h1><h2 id="1-SAGA核心架构与组件"><a href="#1-SAGA核心架构与组件" class="headerlink" title="1. SAGA核心架构与组件"></a>1. SAGA核心架构与组件</h2><p>SAGA框架的核心组件构成了一个层次化的架构，以实现AI代理行动生成的功能。</p><h3 id="1-1-主要组件概述"><a href="#1-1-主要组件概述" class="headerlink" title="1.1 主要组件概述"></a>1.1 主要组件概述</h3><p>SAGA的核心架构由以下几个主要组件构成：</p><ol><li> <strong>BaseSagaAgent</strong>: 所有代理的基类，提供了与语言模型交互的基础设施。</li><li> <strong>ActionsAgent</strong>: 负责根据上下文和技能生成行动选项。</li><li> <strong>ConversationAgent</strong>: 负责生成角色之间的对话。</li><li> <strong>EmbeddingAgent</strong>: 负责生成文本嵌入，用于记忆检索和相似度匹配。</li></ol><h3 id="1-2-核心组件详解"><a href="#1-2-核心组件详解" class="headerlink" title="1.2 核心组件详解"></a>1.2 核心组件详解</h3><p>下面是主要组件的关系图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class BaseSagaAgent &#123;</span><br><span class="line">        +prompt_template</span><br><span class="line">        +callback_handler</span><br><span class="line">        +_llm</span><br><span class="line">        +generate_chain()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ActionsAgent &#123;</span><br><span class="line">        +guidance</span><br><span class="line">        +generate_actions()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ConversationAgent &#123;</span><br><span class="line">        +generate_conversation()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class EmbeddingAgent &#123;</span><br><span class="line">        +embed_documents()</span><br><span class="line">        +embed_query()</span><br><span class="line">        +store_documents()</span><br><span class="line">        +find_similar()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Skill &#123;</span><br><span class="line">        +name</span><br><span class="line">        +description</span><br><span class="line">        +parameters</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Action &#123;</span><br><span class="line">        +skill</span><br><span class="line">        +parameters</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class GeneratedActions &#123;</span><br><span class="line">        +options</span><br><span class="line">        +scores</span><br><span class="line">        +raw_prompt</span><br><span class="line">        +raw_response</span><br><span class="line">        +llm_info</span><br><span class="line">        +sort()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BaseSagaAgent &lt;|-- ActionsAgent</span><br><span class="line">    BaseSagaAgent &lt;|-- ConversationAgent</span><br><span class="line">    ActionsAgent ..&gt; Skill</span><br><span class="line">    ActionsAgent ..&gt; GeneratedActions</span><br><span class="line">    GeneratedActions o-- Action</span><br></pre></td></tr></table></figure><h4 id="1-2-1-BaseSagaAgent"><a href="#1-2-1-BaseSagaAgent" class="headerlink" title="1.2.1 BaseSagaAgent"></a>1.2.1 BaseSagaAgent</h4><p><code>BaseSagaAgent</code>是所有SAGA代理的基类，它提供了与语言模型交互的基础设施：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, prompt_template: BasePromptTemplate, llm: <span class="type">Optional</span>[BaseLanguageModel] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 设置回调处理器</span></span><br><span class="line">    self.callback_handler = SagaCallbackHandler(...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果没有提供语言模型，使用默认的OpenAI模型</span></span><br><span class="line">    <span class="keyword">if</span> llm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._llm = llm</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._llm = ChatOpenAI(...)</span><br><span class="line">    </span><br><span class="line">    self.prompt_template = prompt_template</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_chain</span>(<span class="params">self</span>) -&gt; LLMChain:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成用于代理的LLMChain&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> LLMChain(llm=self._llm, prompt=self.prompt_template)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-ActionsAgent"><a href="#1-2-2-ActionsAgent" class="headerlink" title="1.2.2 ActionsAgent"></a>1.2.2 ActionsAgent</h4><p><code>ActionsAgent</code>继承自<code>BaseSagaAgent</code>，专门负责生成行动选项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, llm: <span class="type">Optional</span>[BaseLanguageModel] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__(</span><br><span class="line">        prompt_template=load_prompt(<span class="string">&quot;generate_actions.yaml&quot;</span>),</span><br><span class="line">        llm=llm,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提供给模型的指导，帮助生成更好的行动</span></span><br><span class="line">    self.guidance = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        * 提供目标和行动</span></span><br><span class="line"><span class="string">        * 不要创造新角色</span></span><br><span class="line"><span class="string">        * 保持角色个性和环境一致性</span></span><br><span class="line"><span class="string">        * 使用观察和对话来指导行动</span></span><br><span class="line"><span class="string">        * 只使用提供的技能</span></span><br><span class="line"><span class="string">        * 避免重复相同的行动</span></span><br><span class="line"><span class="string">        * 通过行动推进故事</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_actions</span>(<span class="params">self, context: <span class="built_in">str</span>, skills: <span class="type">List</span>[Skill], max_tries=<span class="number">0</span>, verbose=<span class="literal">False</span></span>) -&gt; GeneratedActions:</span><br><span class="line">    <span class="comment"># 检查输入</span></span><br><span class="line">    <span class="keyword">assert</span> context <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(context) &gt; <span class="number">0</span>, <span class="string">&quot;Must provide a context.&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> skills <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(skills) &gt; <span class="number">0</span>, <span class="string">&quot;Must provide at least one skill.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建Chain</span></span><br><span class="line">    chain = self.generate_chain()</span><br><span class="line">    chain.verbose = verbose</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将技能转换为JSON</span></span><br><span class="line">    dumped_skills = [unstructure(skill) <span class="keyword">for</span> skill <span class="keyword">in</span> skills]</span><br><span class="line">    json_skills = json.dumps(dumped_skills)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试生成行动</span></span><br><span class="line">    retries = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> retries &lt;= max_tries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 调用语言模型</span></span><br><span class="line">            response = <span class="keyword">await</span> chain.ainvoke(</span><br><span class="line">                &#123;<span class="string">&quot;context&quot;</span>: context, <span class="string">&quot;skills&quot;</span>: json_skills&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;callbacks&quot;</span>: [self.callback_handler]&#125;,</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 解析响应</span></span><br><span class="line">            raw_response = response.get(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            raw_actions = json.loads(raw_response)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 构建GeneratedActions对象</span></span><br><span class="line">            actions = structure(raw_actions, GeneratedActions)</span><br><span class="line">            actions.raw_prompt = self.callback_handler.last_prompt</span><br><span class="line">            actions.raw_response = raw_actions</span><br><span class="line">            actions.llm_info = self.callback_handler.last_model_info</span><br><span class="line">            actions.retries = retries</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 排序并返回</span></span><br><span class="line">            actions.sort()</span><br><span class="line">            <span class="keyword">return</span> actions</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 处理错误，准备重试</span></span><br><span class="line">            last_error = <span class="built_in">str</span>(e)</span><br><span class="line">        retries += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 所有尝试都失败</span></span><br><span class="line">    <span class="keyword">return</span> GeneratedActions(</span><br><span class="line">        options=[],</span><br><span class="line">        scores=[],</span><br><span class="line">        retries=retries,</span><br><span class="line">        error=<span class="string">f&quot;No options found after <span class="subst">&#123;retries&#125;</span> retries.&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="1-2-3-ConversationAgent"><a href="#1-2-3-ConversationAgent" class="headerlink" title="1.2.3 ConversationAgent"></a>1.2.3 ConversationAgent</h4><p><code>ConversationAgent</code>也继承自<code>BaseSagaAgent</code>，专门用于生成角色之间的对话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, llm: <span class="type">Optional</span>[BaseLanguageModel] = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__(</span><br><span class="line">        prompt_template=load_prompt(<span class="string">&quot;generate_conversation.yaml&quot;</span>),</span><br><span class="line">        llm=llm,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_conversation</span>(<span class="params">self, persona_guids: <span class="type">List</span>[<span class="built_in">str</span>], context: <span class="built_in">str</span>, max_tries=<span class="number">0</span>, verbose=<span class="literal">False</span></span>) -&gt; GeneratedConversation:</span><br><span class="line">    <span class="comment"># 检查输入</span></span><br><span class="line">    <span class="keyword">assert</span> persona_guids <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(persona_guids) &gt; <span class="number">0</span>, <span class="string">&quot;Must provide at least one persona_guid.&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> context <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(context) &gt; <span class="number">0</span>, <span class="string">&quot;Must provide a context.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建Chain</span></span><br><span class="line">    chain = self.generate_chain()</span><br><span class="line">    chain.verbose = verbose</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 格式化角色ID</span></span><br><span class="line">    formatted_persona_guids = <span class="string">&quot;[&quot;</span> + <span class="string">&quot;, &quot;</span>.join(persona_guids) + <span class="string">&quot;]&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试生成对话</span></span><br><span class="line">    retries = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> retries &lt;= max_tries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 调用语言模型</span></span><br><span class="line">            response = <span class="keyword">await</span> chain.ainvoke(</span><br><span class="line">                &#123;<span class="string">&quot;context&quot;</span>: context, <span class="string">&quot;persona_guids&quot;</span>: formatted_persona_guids&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;callbacks&quot;</span>: [self.callback_handler]&#125;,</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 解析响应</span></span><br><span class="line">            raw_response = response.get(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            raw_conversation = json.loads(raw_response)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 构建GeneratedConversation对象</span></span><br><span class="line">            conversation = structure(raw_conversation, GeneratedConversation)</span><br><span class="line">            conversation.raw_prompt = self.callback_handler.last_prompt</span><br><span class="line">            conversation.raw_response = raw_response</span><br><span class="line">            conversation.llm_info = self.callback_handler.last_model_info</span><br><span class="line">            conversation.retries = retries</span><br><span class="line">            <span class="keyword">return</span> conversation</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 处理错误，准备重试</span></span><br><span class="line">            last_error = <span class="built_in">str</span>(e)</span><br><span class="line">        retries += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 所有尝试都失败</span></span><br><span class="line">    <span class="keyword">return</span> GeneratedConversation(</span><br><span class="line">        conversation=[],</span><br><span class="line">        retries=retries,</span><br><span class="line">        error=<span class="string">f&quot;No options found after <span class="subst">&#123;retries&#125;</span> retries.&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="1-2-4-EmbeddingAgent"><a href="#1-2-4-EmbeddingAgent" class="headerlink" title="1.2.4 EmbeddingAgent"></a>1.2.4 EmbeddingAgent</h4><p><code>EmbeddingAgent</code>负责生成文本嵌入并与向量数据库交互（更多细节见章节3）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmbeddingAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        embeddings: <span class="type">Optional</span>[Embeddings] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        storage: <span class="type">Optional</span>[VectorStore] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="comment"># 初始化嵌入模型和存储</span></span><br><span class="line">        <span class="keyword">if</span> embeddings <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line">            <span class="keyword">except</span> ImportError:</span><br><span class="line">                <span class="keyword">raise</span> ImportError(</span><br><span class="line">                    <span class="string">&quot;OpenAI not installed. Please install langchain-openai or provide embeddings.&quot;</span></span><br><span class="line">                )</span><br><span class="line">            self.embeddings = OpenAIEmbeddings(</span><br><span class="line">                model=default_openai_embedding_model_name</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.embeddings = embeddings</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> storage <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.storage = SimpleVectorStore(embedding_model=self.embeddings)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.storage = storage</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">embed_documents</span>(<span class="params">self, texts: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;为文档生成嵌入&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.embeddings.embed_documents(texts)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">store_documents</span>(<span class="params">self, docs: <span class="type">List</span>[Document]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储文档到向量数据库&quot;&quot;&quot;</span></span><br><span class="line">        texts = [doc.text <span class="keyword">for</span> doc <span class="keyword">in</span> docs]</span><br><span class="line">        metadatas = [doc.metadata <span class="keyword">for</span> doc <span class="keyword">in</span> docs]</span><br><span class="line">        <span class="keyword">return</span> self.storage.add_texts(texts, metadatas=metadatas)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">find_similar</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, query: <span class="built_in">str</span>, k: <span class="built_in">int</span> = <span class="number">5</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[Document, <span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找与查询相似的文档&quot;&quot;&quot;</span></span><br><span class="line">        results = self.storage.similarity_search_with_score(query, k)</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            (Document.from_langchain(doc), score) <span class="keyword">for</span> doc, score <span class="keyword">in</span> results</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><h3 id="1-3-关键数据结构"><a href="#1-3-关键数据结构" class="headerlink" title="1.3 关键数据结构"></a>1.3 关键数据结构</h3><p>SAGA框架中使用的一些关键数据结构：</p><ul><li><p><strong>Skill</strong>: 代表代理可以执行的技能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class Skill:</span></span><br><span class="line"><span class="comment">#     +name</span></span><br><span class="line"><span class="comment">#     +description</span></span><br><span class="line"><span class="comment">#     +parameters</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Action</strong>: 代表一个被选定执行的具体技能和其参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class Action:</span></span><br><span class="line"><span class="comment">#     +skill</span></span><br><span class="line"><span class="comment">#     +parameters</span></span><br></pre></td></tr></table></figure></li><li><p><strong>GeneratedActions</strong>: 包含由<code>ActionsAgent</code>生成的行动选项列表及其相关信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@define(<span class="params">slots=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratedActions</span>:</span><br><span class="line">    options: <span class="type">List</span>[Action]</span><br><span class="line">    scores: <span class="type">List</span>[<span class="built_in">float</span>]</span><br><span class="line">    raw_prompt: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    raw_response: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    llm_info: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span></span><br><span class="line">    retries: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">    error: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;按分数排序行动选项&quot;&quot;&quot;</span></span><br><span class="line">        self.options = [</span><br><span class="line">            x</span><br><span class="line">            <span class="keyword">for</span> _, x <span class="keyword">in</span> <span class="built_in">sorted</span>(</span><br><span class="line">                <span class="built_in">zip</span>(self.scores, self.options), key=<span class="keyword">lambda</span> pair: pair[<span class="number">0</span>], reverse=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">        self.scores = <span class="built_in">sorted</span>(self.scores, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-核心工作流程"><a href="#2-核心工作流程" class="headerlink" title="2. 核心工作流程"></a>2. 核心工作流程</h2><p>SAGA的主要工作流程涉及环境交互、行动生成、行动执行、对话生成和记忆管理。</p><h3 id="2-1-总体流程"><a href="#2-1-总体流程" class="headerlink" title="2.1 总体流程"></a>2.1 总体流程</h3><p>SAGA的主要工作流程可以用以下流程图表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[模拟环境] --&gt;|提供上下文和技能| B[ActionsAgent]</span><br><span class="line">    B --&gt;|生成行动选项| C[行动选项]</span><br><span class="line">    C --&gt;|选择执行| D[SimAction]</span><br><span class="line">    D --&gt;|更新环境和记忆| A</span><br><span class="line">    A --&gt;|提供对话角色和上下文| E[ConversationAgent]</span><br><span class="line">    E --&gt;|生成对话| F[对话内容]</span><br><span class="line">    F --&gt;|更新记忆| A</span><br><span class="line">    A --&gt;|提供记忆查询| G[EmbeddingAgent]</span><br><span class="line">    G --&gt;|检索相关记忆| A</span><br></pre></td></tr></table></figure><h3 id="2-2-详细执行流程概述"><a href="#2-2-详细执行流程概述" class="headerlink" title="2.2 详细执行流程概述"></a>2.2 详细执行流程概述</h3><ol><li><strong>初始化阶段</strong>:<ul><li>  加载模拟环境（如Space Colony示例）。</li><li>  初始化各种代理（<code>ActionsAgent</code>, <code>ConversationAgent</code>等）。</li><li>  加载技能定义、角色、位置等元数据。</li></ul></li><li><strong>行动生成流程</strong>:<ul><li>  模拟环境调用<code>ActionsAgent.generate_actions()</code>。</li><li>  该方法接收上下文（包含角色信息、记忆等）和可用技能列表。</li><li>  构建提示(prompt)，发送给LLM。</li><li>  LLM返回JSON格式的行动选项，每个选项包含一个技能名和参数。</li><li>  将选项解析为<code>GeneratedActions</code>对象并按分数排序。</li><li>  返回排序后的行动选项供模拟环境使用。</li></ul></li><li><strong>行动执行流程</strong>:<ul><li>  模拟环境选择一个行动选项。</li><li>  创建对应的<code>SimAction</code>子类实例。</li><li>  调用该实例的<code>tick()</code>方法随时间推进行动。</li><li>  行动完成时，更新角色的记忆和状态。</li></ul></li><li><strong>对话生成流程</strong>:<ul><li>  当角色需要交谈时，调用<code>ConversationAgent.generate_conversation()</code>。</li><li>  该方法接收参与对话的角色ID和上下文。</li><li>  构建提示，发送给LLM。</li><li>  LLM返回JSON格式的对话内容。</li><li>  将对话内容保存为角色的记忆。</li></ul></li><li><strong>记忆检索流程</strong>:<ul><li>  使用<code>EmbeddingAgent</code>将文本转换为向量嵌入。</li><li>  存储记忆文档及其嵌入到向量数据库。</li><li>  当需要相关记忆时，执行相似度搜索找出最相关的记忆。</li></ul></li></ol><h3 id="2-3-行动生成流程详解"><a href="#2-3-行动生成流程详解" class="headerlink" title="2.3 行动生成流程详解"></a>2.3 行动生成流程详解</h3><p>SAGA的核心功能是生成行动选项。</p><h4 id="2-3-1-详细流程图"><a href="#2-3-1-详细流程图" class="headerlink" title="2.3.1 详细流程图"></a>2.3.1 详细流程图</h4><p>下面是详细的行动生成流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 客户端/模拟环境</span><br><span class="line">    participant Agent as ActionsAgent</span><br><span class="line">    participant LLM as 语言模型</span><br><span class="line">    participant Parser as JSON解析器</span><br><span class="line">    </span><br><span class="line">    Client-&gt;&gt;Agent: 调用generate_actions(context, skills)</span><br><span class="line">    Agent-&gt;&gt;Agent: 验证输入</span><br><span class="line">    Agent-&gt;&gt;Agent: 构建Chain</span><br><span class="line">    Agent-&gt;&gt;Agent: 将skills转换为JSON</span><br><span class="line">    Agent-&gt;&gt;LLM: 发送提示和上下文</span><br><span class="line">    LLM-&gt;&gt;Agent: 返回原始响应</span><br><span class="line">    Agent-&gt;&gt;Parser: 解析JSON响应</span><br><span class="line">    Parser-&gt;&gt;Agent: 返回解析后的结构</span><br><span class="line">    Agent-&gt;&gt;Agent: 创建GeneratedActions对象</span><br><span class="line">    Agent-&gt;&gt;Agent: 按分数排序行动选项</span><br><span class="line">    Agent-&gt;&gt;Client: 返回GeneratedActions</span><br></pre></td></tr></table></figure><h4 id="2-3-2-提示模板设计"><a href="#2-3-2-提示模板设计" class="headerlink" title="2.3.2 提示模板设计"></a>2.3.2 提示模板设计</h4><p>SAGA使用YAML格式的提示模板来构建发送给语言模型的提示。以下是行动生成的模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_type:</span> <span class="string">prompt</span></span><br><span class="line"><span class="attr">input_variables:</span></span><br><span class="line">    [<span class="string">&quot;context&quot;</span>, <span class="string">&quot;skills&quot;</span>]</span><br><span class="line"><span class="attr">template:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    Generate a list of different action options that your character should take next using the following skills:</span></span><br><span class="line"><span class="string">    &#123;skills&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    &#123;<span class="string">context</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="string">Generate</span> <span class="string">a</span> <span class="string">list</span> <span class="string">of</span> <span class="string">different</span> <span class="string">action</span> <span class="string">options</span> <span class="string">that</span> <span class="string">your</span> <span class="string">character</span> <span class="string">should</span> <span class="string">take.</span> <span class="string">Then</span> <span class="string">score</span> <span class="string">each</span> <span class="string">option.</span> <span class="string">Only</span> <span class="string">generate</span> <span class="string">valid</span> <span class="string">JSON.</span></span><br><span class="line">    <span class="attr">Use the following JSON format to specify the parameters:</span></span><br><span class="line">            &#123;&#123;<span class="attr">&quot;options&quot;:</span> [</span><br><span class="line">                &#123;&#123;<span class="attr">&quot;skill&quot;:</span> <span class="string">&lt;choice</span> <span class="string">of</span> <span class="string">skill&gt;</span>, <span class="attr">&quot;parameters&quot;:</span> &#123;&#123;<span class="string">&lt;skill</span> <span class="string">parameters</span> <span class="string">as</span> <span class="string">json&gt;</span>&#125;&#125;&#125;&#125;</span><br><span class="line">            ],<span class="attr">&quot;scores&quot;:</span> [<span class="string">&lt;list</span>[<span class="string">float</span>]<span class="string">:</span> <span class="string">scores</span> <span class="string">for</span> <span class="string">each</span> <span class="string">action</span> <span class="string">in</span> <span class="string">the</span> <span class="string">order</span> <span class="string">listed.</span> <span class="number">-1.0</span> <span class="string">is</span> <span class="string">terrible</span>, <span class="number">0</span> <span class="string">is</span> <span class="string">neutral</span>, <span class="string">and</span> <span class="number">1.0</span> <span class="string">the</span> <span class="string">best</span> <span class="string">action</span> <span class="string">ever.&gt;</span>]</span><br><span class="line">            ]&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-行动解析和排序"><a href="#2-3-3-行动解析和排序" class="headerlink" title="2.3.3 行动解析和排序"></a>2.3.3 行动解析和排序</h4><p>行动选项从LLM返回后，由<code>ActionsAgent</code>解析JSON响应，并使用<code>GeneratedActions</code>对象的<code>sort()</code>方法（如1.3节所示）按分数对行动选项进行排序。</p><h3 id="2-4-对话生成流程详解"><a href="#2-4-对话生成流程详解" class="headerlink" title="2.4 对话生成流程详解"></a>2.4 对话生成流程详解</h3><p>当角色需要进行对话时，模拟环境会调用<code>ConversationAgent</code>的<code>generate_conversation()</code>方法。此方法（如1.2.3节代码所示）接收参与对话的角色ID列表和当前上下文。它会构建一个专门的提示发送给语言模型，LLM随后返回JSON格式的对话内容。这些对话内容被构造成<code>GeneratedConversation</code>对象，并可以被保存为角色的记忆。</p><h3 id="2-5-完整的模拟执行流程"><a href="#2-5-完整的模拟执行流程" class="headerlink" title="2.5 完整的模拟执行流程"></a>2.5 完整的模拟执行流程</h3><h4 id="2-5-1-模拟环境中的用户交互驱动流程（以Space-Colony示例）"><a href="#2-5-1-模拟环境中的用户交互驱动流程（以Space-Colony示例）" class="headerlink" title="2.5.1 模拟环境中的用户交互驱动流程（以Space Colony示例）"></a>2.5.1 模拟环境中的用户交互驱动流程（以Space Colony示例）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant Simulation</span><br><span class="line">    participant ActionsAgent</span><br><span class="line">    participant LLM</span><br><span class="line">    participant SimAction</span><br><span class="line">    </span><br><span class="line">    User-&gt;&gt;Simulation: 运行示例</span><br><span class="line">    Simulation-&gt;&gt;Simulation: 加载元数据</span><br><span class="line">    loop 每个角色</span><br><span class="line">        Simulation-&gt;&gt;ActionsAgent: generate_action_options(agent)</span><br><span class="line">        ActionsAgent-&gt;&gt;LLM: 发送上下文和技能</span><br><span class="line">        LLM-&gt;&gt;ActionsAgent: 返回行动选项</span><br><span class="line">        ActionsAgent-&gt;&gt;Simulation: 返回排序后的行动选项</span><br><span class="line">        Simulation-&gt;&gt;User: 显示行动选项列表</span><br><span class="line">        User-&gt;&gt;Simulation: 选择一个行动</span><br><span class="line">        Simulation-&gt;&gt;SimAction: 创建行动实例</span><br><span class="line">        SimAction-&gt;&gt;Simulation: 更新角色状态和记忆</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h4 id="2-5-2-SAGA内部行动生成到执行的详细流程"><a href="#2-5-2-SAGA内部行动生成到执行的详细流程" class="headerlink" title="2.5.2 SAGA内部行动生成到执行的详细流程"></a>2.5.2 SAGA内部行动生成到执行的详细流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Sim as 模拟系统</span><br><span class="line">    participant Agent as 模拟代理</span><br><span class="line">    participant Context as 上下文生成器</span><br><span class="line">    participant SAGA as SAGA框架 (ActionsAgent)</span><br><span class="line">    participant LLM as 语言模型</span><br><span class="line">    participant ActionFactory as 行动工厂</span><br><span class="line">    </span><br><span class="line">    Sim-&gt;&gt;Agent: tick(delta_time)</span><br><span class="line">    Alt 需要新行动</span><br><span class="line">        Agent-&gt;&gt;Context: 请求生成上下文</span><br><span class="line">        Context-&gt;&gt;Context: 收集代理信息、环境信息、记忆等</span><br><span class="line">        Context--&gt;&gt;Agent: 返回格式化上下文</span><br><span class="line">        Agent-&gt;&gt;SAGA: generate_actions(context, skills)</span><br><span class="line">        SAGA-&gt;&gt;LLM: 发送提示(context + skills)</span><br><span class="line">        LLM--&gt;&gt;SAGA: 返回JSON格式行动选项和评分</span><br><span class="line">        SAGA--&gt;&gt;Agent: 返回GeneratedActions对象</span><br><span class="line">        Agent-&gt;&gt;Agent: 选择行动(通常是最高评分)</span><br><span class="line">        Agent-&gt;&gt;ActionFactory: 创建行动实例 (e.g., sim_action_factory)</span><br><span class="line">        ActionFactory--&gt;&gt;Agent: 返回具体SimAction子类实例</span><br><span class="line">        Agent-&gt;&gt;Agent: 设置当前action</span><br><span class="line">    End</span><br><span class="line">    </span><br><span class="line">    Agent-&gt;&gt;Agent: tick_action(delta_time) // 调用 SimAction.tick()</span><br><span class="line">    Agent-&gt;&gt;Agent: 更新行动状态和运行时间</span><br><span class="line">    </span><br><span class="line">    Alt 行动完成</span><br><span class="line">        Agent-&gt;&gt;Agent: 添加记忆 (e.g., MemoryStore.append)</span><br><span class="line">        Agent-&gt;&gt;Agent: action.complete()</span><br><span class="line">        Agent-&gt;&gt;Agent: action = None</span><br><span class="line">    End</span><br><span class="line">    </span><br><span class="line">    Agent--&gt;&gt;Sim: 返回控制</span><br></pre></td></tr></table></figure><h2 id="3-记忆与嵌入机制"><a href="#3-记忆与嵌入机制" class="headerlink" title="3. 记忆与嵌入机制"></a>3. 记忆与嵌入机制</h2><p>SAGA的记忆系统利用向量嵌入来存储和检索记忆，从而使代理能够根据过去的经验做出更明智的决策。</p><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>SAGA的记忆和嵌入机制工作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[文本记忆] --&gt;|嵌入生成| B[向量嵌入]</span><br><span class="line">    B --&gt;|存储| C[向量数据库]</span><br><span class="line">    D[查询] --&gt;|嵌入生成| E[查询向量]</span><br><span class="line">    E --&gt;|相似度搜索| C</span><br><span class="line">    C --&gt;|相关记忆| F[检索结果]</span><br></pre></td></tr></table></figure><h3 id="3-2-EmbeddingAgent-的作用"><a href="#3-2-EmbeddingAgent-的作用" class="headerlink" title="3.2 EmbeddingAgent 的作用"></a>3.2 <code>EmbeddingAgent</code> 的作用</h3><p><code>EmbeddingAgent</code> (详见1.2.4节) 在此机制中扮演核心角色。它负责：</p><ol><li> 将文本（如观察、对话、思考）转换为向量嵌入。</li><li> 将这些嵌入及其原始文本（和元数据）存储到向量存储中。</li><li> 当需要检索相关记忆时，将查询文本转换为查询向量，并在向量存储中执行相似度搜索。</li></ol><h3 id="3-3-SimpleVectorStore-实现"><a href="#3-3-SimpleVectorStore-实现" class="headerlink" title="3.3 SimpleVectorStore 实现"></a>3.3 <code>SimpleVectorStore</code> 实现</h3><p><code>SimpleVectorStore</code>是一个简单的内存向量存储实现，使用numpy进行相似度搜索。它是SAGA中用于演示和快速启动的默认向量存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleVectorStore</span>(<span class="title class_ inherited__">VectorStore</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_model: Embeddings</span>):</span><br><span class="line">        self.embedding_model = embedding_model</span><br><span class="line">        self.vectors = []</span><br><span class="line">        self.ids = []</span><br><span class="line">        self.docstore = InMemoryDocstore()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_texts</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        texts: Iterable[<span class="built_in">str</span>],</span></span><br><span class="line"><span class="params">        metadatas: <span class="type">Optional</span>[<span class="type">List</span>[<span class="type">Dict</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ids: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加文本到向量存储&quot;&quot;&quot;</span></span><br><span class="line">        embedding_values = self.embedding_model.embed_documents(<span class="built_in">list</span>(texts))</span><br><span class="line">        <span class="keyword">if</span> ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ids = [uuid.uuid4().<span class="built_in">hex</span> <span class="keyword">for</span> _ <span class="keyword">in</span> texts]</span><br><span class="line">        self.ids.extend(ids)</span><br><span class="line">        self.vectors.extend(np.array(embedding_values))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建文档并存储</span></span><br><span class="line">        <span class="keyword">if</span> metadatas <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            docs = [</span><br><span class="line">                LangchainDocument(page_content=text, metadata=metadata)</span><br><span class="line">                <span class="keyword">for</span> text, metadata <span class="keyword">in</span> <span class="built_in">zip</span>(texts, metadatas)</span><br><span class="line">            ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            docs = [LangchainDocument(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line">        </span><br><span class="line">        self.docstore.add(<span class="built_in">dict</span>(<span class="built_in">zip</span>(ids, docs)))</span><br><span class="line">        <span class="keyword">return</span> ids</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">similarity_search_with_score</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, query: <span class="built_in">str</span>, k: <span class="built_in">int</span> = <span class="number">5</span>, **kwargs</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[LangchainDocument, <span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找相似向量并返回相关性分数&quot;&quot;&quot;</span></span><br><span class="line">        query_embedding = self.embedding_model.embed_query(query)</span><br><span class="line">        cos_sim = np.array(</span><br><span class="line">            [</span><br><span class="line">                self.cosine_similarity_numpy(np.array(query_embedding, ndmin=<span class="number">2</span>), vector)</span><br><span class="line">                <span class="keyword">for</span> vector <span class="keyword">in</span> self.vectors</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 余弦相似度范围从-1到1，归一化到0-1</span></span><br><span class="line">        scores = (cos_sim.flatten() + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 按分数排序，取前k个</span></span><br><span class="line">        indices = np.argsort(scores, axis=<span class="number">0</span>)[::-<span class="number">1</span>][:k]</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> indices:</span><br><span class="line">            doc = self.docstore.search(self.ids[i])</span><br><span class="line">            results.append((doc, scores[i]))</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h3 id="3-4-记忆和元记忆处理"><a href="#3-4-记忆和元记忆处理" class="headerlink" title="3.4 记忆和元记忆处理"></a>3.4 记忆和元记忆处理</h3><p>元记忆处理是SAGA框架的核心特点之一，它允许代理不仅存储事实，还存储关于其自身状态、目标和知识的结构化信息。</p><p><strong>元记忆典型数据结构示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;agent_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cooper&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;persona&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wyatt Cooper&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;job&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sheriff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;goals&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Solve the murder case&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Maintain peace in town&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;knowledge&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;world&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Thistle Gulch is a small western town&quot;</span><span class="punctuation">,</span> <span class="string">&quot;...&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;people&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;blackjack&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;suspicious&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;observations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Native American man found dead&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Fresh blood and bullet casings&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;crime_scene&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;skills&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;goto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;interact&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;interaction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;conversewith&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;persona&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;topic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;current_goal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Find the murderer before tribal retaliation&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>记忆处理流程：</strong></p><ol><li> 模拟系统维护每个代理的记忆库（例如使用<code>MemoryStore</code>，它可能内部使用<code>EmbeddingAgent</code>和<code>VectorStore</code>）。</li><li> 新的行动结果、观察和对话被添加为记忆条目到记忆库中。</li><li> 在为<code>ActionsAgent</code>或<code>ConversationAgent</code>构建上下文时，系统会从记忆库中检索相关记忆。这通常涉及将当前情况或查询嵌入化，然后通过向量相似度搜索找到语义相关的记忆。</li><li> 检索到的记忆被格式化并包含在提供给LLM的上下文中，以指导其生成行动或对话。</li><li> 一些记忆系统可能会实现记忆的淡忘特性，使得较旧或较少访问的记忆随时间变得不那么突出或检索权重降低。</li></ol><h2 id="4-模拟环境集成"><a href="#4-模拟环境集成" class="headerlink" title="4. 模拟环境集成"></a>4. 模拟环境集成</h2><p>SAGA提供了一个Space Colony示例，展示了如何将框架集成到模拟环境中。集成的关键在于将SAGA的代理（如<code>ActionsAgent</code>）与模拟世界中的代理（<code>SimAgent</code>）连接起来，并通过模拟行动（<code>SimAction</code>）来执行SAGA生成的决策。</p><h3 id="4-1-模拟代理-SimAgent"><a href="#4-1-模拟代理-SimAgent" class="headerlink" title="4.1 模拟代理 (SimAgent)"></a>4.1 模拟代理 (<code>SimAgent</code>)</h3><p><code>SimAgent</code>是模拟环境中的代理，它持有一个角色（persona）、位置、技能列表和当前正在执行的行动。它还拥有一个<code>MemoryStore</code>来存储其记忆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@define(<span class="params">slots=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimAgent</span>:</span><br><span class="line">    guid: <span class="built_in">str</span></span><br><span class="line">    persona: sim_models.Persona</span><br><span class="line">    location: sim_models.Location</span><br><span class="line">    skills: <span class="type">List</span>[Skill] = []</span><br><span class="line">    action: <span class="type">Optional</span>[SimAction] = <span class="literal">None</span></span><br><span class="line">    memories: MemoryStore = MemoryStore([])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self, delta: timedelta, sim: <span class="string">&quot;Simulation&quot;</span></span>):</span><br><span class="line">        <span class="comment"># 如果没有当前行动，选择一个新行动</span></span><br><span class="line">        <span class="keyword">if</span> self.action <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            actions = <span class="keyword">await</span> sim.action_generator.generate_action_options(</span><br><span class="line">                sim, self, verbose=<span class="literal">False</span></span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 让用户或AI选择一个行动</span></span><br><span class="line">            idx = <span class="keyword">await</span> choose_action(actions)</span><br><span class="line">            new_action = sim.action_generator.sim_action_factory(</span><br><span class="line">                self, actions.options[idx]</span><br><span class="line">            )</span><br><span class="line">            self.action = new_action</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 推进当前行动</span></span><br><span class="line">        <span class="keyword">await</span> self.tick_action(delta, sim)</span><br></pre></td></tr></table></figure><h3 id="4-2-模拟行动-SimAction"><a href="#4-2-模拟行动-SimAction" class="headerlink" title="4.2 模拟行动 (SimAction)"></a>4.2 模拟行动 (<code>SimAction</code>)</h3><p><code>SimAction</code>及其子类实现了代理可以执行的各种具体行动。每个<code>SimAction</code>子类对应一个SAGA <code>Skill</code>。当一个行动被选择后，其实例被创建，并且其<code>tick()</code>方法会在模拟的每个时间步被调用，直到行动完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimAction</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, agent: SimAgent, action_data: Action</span>):</span><br><span class="line">        self.agent = agent</span><br><span class="line">        self.action_data = action_data</span><br><span class="line">        self.skill = action_data.skill</span><br><span class="line">        self.parameters = action_data.parameters</span><br><span class="line">        self.start_time = <span class="literal">None</span></span><br><span class="line">        self.run_time = timedelta()</span><br><span class="line">        self.end_time = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self, delta: timedelta, sim: Simulation</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新行动的运行时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.start_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.start_time = sim.sim_time</span><br><span class="line">        self.run_time += delta</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">complete</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;标记行动为完成&quot;&quot;&quot;</span></span><br><span class="line">        self.agent.action = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoTo</span>(<span class="title class_ inherited__">SimAction</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, agent: SimAgent, action_data: Action</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(agent, action_data)</span><br><span class="line">        self.destination = self.parameters.get(<span class="string">&quot;destination&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        self.goal = self.parameters.get(<span class="string">&quot;goal&quot;</span>, <span class="string">&quot;None&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self, delta: timedelta, sim: Simulation</span>):</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">super</span>().tick(delta, sim)</span><br><span class="line">        <span class="comment"># 假设移动到下一个位置需要一分钟</span></span><br><span class="line">        <span class="keyword">if</span> self.run_time.total_seconds() &lt; <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新代理位置</span></span><br><span class="line">        previous_location = self.agent.location.guid</span><br><span class="line">        self.agent.location = sim.locations[EntityId(self.destination)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建记忆</span></span><br><span class="line">        summary = <span class="string">f&quot;Moved from <span class="subst">&#123;previous_location&#125;</span> to <span class="subst">&#123;self.destination&#125;</span> with goal <span class="subst">&#123;self.goal&#125;</span>&quot;</span></span><br><span class="line">        self.agent.memories.append(</span><br><span class="line">            sim_models.Memory(summary=summary, timestamp=sim.sim_time)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完成行动</span></span><br><span class="line">        self.end_time = sim.sim_time</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.agent.persona.<span class="built_in">id</span>()&#125;</span>: <span class="subst">&#123;summary&#125;</span>&quot;</span>)</span><br><span class="line">        self.complete()</span><br></pre></td></tr></table></figure><h3 id="4-3-行动生成器-ActionGenerator"><a href="#4-3-行动生成器-ActionGenerator" class="headerlink" title="4.3 行动生成器 (ActionGenerator)"></a>4.3 行动生成器 (<code>ActionGenerator</code>)</h3><p><code>ActionGenerator</code>是模拟环境中的一个辅助类，它封装了与SAGA <code>ActionsAgent</code>的交互，以便为<code>SimAgent</code>生成行动选项。它还包含一个工厂方法 (<code>sim_action_factory</code>)，用于将SAGA返回的抽象<code>Action</code>数据转换为具体的<code>SimAction</code>子类实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActionGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, saga_agent: ActionsAgent</span>):</span><br><span class="line">        self.saga_agent = saga_agent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_action_options</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        sim: Simulation,</span></span><br><span class="line"><span class="params">        sim_agent: SimAgent,</span></span><br><span class="line"><span class="params">        retries=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">        verbose=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; GeneratedActions:</span><br><span class="line">        <span class="comment"># 构建上下文</span></span><br><span class="line">        context = Format.standard_llm_context(sim_agent, sim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 生成行动选项</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> self.saga_agent.generate_actions(</span><br><span class="line">            context, sim_agent.skills, retries, verbose</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sim_action_factory</span>(<span class="params">sim_agent: SimAgent, action: Action</span>):</span><br><span class="line">        <span class="comment"># 根据技能名创建对应的SimAction子类实例</span></span><br><span class="line">        <span class="keyword">if</span> action.skill == <span class="string">&quot;go_to&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> GoTo(sim_agent, action)</span><br><span class="line">        <span class="keyword">elif</span> action.skill == <span class="string">&quot;interact&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Interact(sim_agent, action)</span><br><span class="line">        <span class="keyword">elif</span> action.skill == <span class="string">&quot;converse_with&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> ConverseWith(sim_agent, action)</span><br><span class="line">        <span class="keyword">elif</span> action.skill == <span class="string">&quot;wait&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Wait(sim_agent, action)</span><br><span class="line">        <span class="keyword">elif</span> action.skill == <span class="string">&quot;reflect&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Reflect(sim_agent, action)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknown skill: <span class="subst">&#123;action.skill&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-服务器实现"><a href="#5-服务器实现" class="headerlink" title="5. 服务器实现"></a>5. 服务器实现</h2><p>SAGA可以作为服务器运行，通过HTTP、WebSocket或SocketIO等协议提供接口，使得非Python或其他外部模拟环境也能利用SAGA的AI代理能力。</p><h3 id="5-1-架构概述"><a href="#5-1-架构概述" class="headerlink" title="5.1 架构概述"></a>5.1 架构概述</h3><p>SAGA服务器架构允许外部客户端与核心SAGA代理进行交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[客户端] --&gt;|请求| B&#123;服务器类型&#125;</span><br><span class="line">    B --&gt;|HTTP| C[HTTP处理器]</span><br><span class="line">    B --&gt;|WebSocket| D[WebSocket处理器]</span><br><span class="line">    B --&gt;|SocketIO| E[SocketIO处理器]</span><br><span class="line">    C --&gt;|处理请求| F[端点]</span><br><span class="line">    D --&gt;|处理请求| F</span><br><span class="line">    E --&gt;|处理请求| F</span><br><span class="line">    F --&gt;|ActionsEndpoint| G[ActionsAgent]</span><br><span class="line">    F --&gt;|ConversationEndpoint| H[ConversationAgent]</span><br><span class="line">    F --&gt;|EmbeddingsEndpoint| I[EmbeddingAgent]</span><br><span class="line">    G --&gt;|返回行动| F</span><br><span class="line">    H --&gt;|返回对话| F</span><br><span class="line">    I --&gt;|返回嵌入| F</span><br><span class="line">    F --&gt;|构建响应| C</span><br><span class="line">    F --&gt;|构建响应| D</span><br><span class="line">    F --&gt;|构建响应| E</span><br><span class="line">    C --&gt;|响应| A</span><br><span class="line">    D --&gt;|响应| A</span><br><span class="line">    E --&gt;|响应| A</span><br></pre></td></tr></table></figure><h3 id="5-2-端点设计"><a href="#5-2-端点设计" class="headerlink" title="5.2 端点设计"></a>5.2 端点设计</h3><p>SAGA的服务器使用统一的端点设计模式，每个端点负责处理特定类型的请求并与相应的SAGA代理交互。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseEndpoint</span>(<span class="type">Generic</span>[TReq, TResp]):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;所有端点的基类&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self, request: TReq</span>) -&gt; TResp:</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionsEndpoint</span>(BaseEndpoint[ActionsRequest, ActionsResponse]):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从ActionsRequest生成ActionsResponse&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, agent: ActionsAgent</span>):</span><br><span class="line">        self.agent = agent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self, req: ActionsRequest</span>) -&gt; ActionsResponse:</span><br><span class="line">        actions = <span class="keyword">await</span> self.agent.generate_actions(</span><br><span class="line">            req.context, req.skills, req.retries, req.verbose</span><br><span class="line">        )</span><br><span class="line">        response = ActionsResponse(actions=actions, reference=req.reference)</span><br><span class="line">        <span class="keyword">if</span> actions.error <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            response.error = <span class="string">f&quot;Generation Error: <span class="subst">&#123;actions.error&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="5-3-HTTP服务器"><a href="#5-3-HTTP服务器" class="headerlink" title="5.3 HTTP服务器"></a>5.3 HTTP服务器</h3><p>HTTP服务器通常使用像<code>aiohttp</code>这样的异步Web框架实现。请求被路由到相应的端点处理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@routes.post(<span class="params"><span class="string">&quot;/generate-actions&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_actions</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = <span class="keyword">await</span> request.json()</span><br><span class="line">        result = <span class="keyword">await</span> generic_handler(data, actions_endpoint)</span><br><span class="line">        <span class="keyword">return</span> web.json_response(result)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> web.json_response(</span><br><span class="line">            &#123;<span class="string">&quot;error&quot;</span>: <span class="string">f&quot;Error in generate_actions: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>&#125;, status=<span class="number">500</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="5-4-WebSocket和SocketIO"><a href="#5-4-WebSocket和SocketIO" class="headerlink" title="5.4 WebSocket和SocketIO"></a>5.4 WebSocket和SocketIO</h3><p>WebSocket和SocketIO接口为需要实时、双向通信的客户端提供支持。它们允许服务器在生成结果后主动将结果推送给客户端。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sio.on(<span class="params"><span class="string">&quot;generate-actions&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_actions</span>(<span class="params">sid, message_str: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> generic_handler(message_str, actions_endpoint)</span><br><span class="line">        <span class="keyword">await</span> sio.emit(<span class="string">&quot;generate-actions&quot;</span>, json.dumps(result), room=sid)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">await</span> sio.emit(</span><br><span class="line">            <span class="string">&quot;generate-actions&quot;</span>,</span><br><span class="line">            json.dumps(&#123;<span class="string">&quot;error&quot;</span>: <span class="string">f&quot;Error in generate_actions: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>&#125;),</span><br><span class="line">            room=sid,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> NPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯坦福小镇阅读笔记</title>
      <link href="/2025/01/16/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%B0%8F%E9%95%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/16/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%B0%8F%E9%95%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>阉割版：<a href="https://www.convex.dev/ai-town">https://www.convex.dev/ai-town</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们如何打造一个反映可信人类行为的交互式人工社会？</p><p>从《模拟人生》等沙盒游戏到认知模型和虚拟环境等应用程序，四十多年来，研究人员和从业者一直设想可以作为人类行为可信代理的计算代理。在这些愿景中，计算驱动的代理的行为与他们过去的经验一致，并对他们的环境做出可信的反应。这种对人类行为的模拟可以在虚拟空间和社区中填充现实的社会现象，训练人们如何处理罕见但困难的人际关系情况，测试社会科学理论 ，制作用于理论和可用性测试的人类处理器模型，为无处不在的计算应用程序和社交机器人 提供支持，并支持可以导航复杂人类的不可玩游戏角色开放世界中的关系。</p><p>1.在实际实施中，这些方法通常会简化环境或代理行为的维度，以使工作更易管理。基于规则的方法，比如<strong>有限状态机</strong>(finite-state machines)和<strong>行为树</strong>(behavior tree)，是手工编写代理行为的蛮力方法。它们提供了一种创建简单代理的直接方式，这种方法今天仍然是最主要的方法，甚至可以处理基本的社交互动，如《Mass Effect》和《The Sims》系列游戏中所示。然而，手工制作不可以全面处理开放世界中互动的所有行为。这意味着最终的代理行为可能无法完全代表其互动的后果，也不能执行未在其脚本中硬编码的新程序。</p><p>然而，人类行为的空间是广阔而复杂的。</p><p>2.尽管大型语言模型在<strong>单个时间点</strong>上可以模拟人类行为，但确保长期一致性的完全通用智能体将更适合管理不断增长的记忆的体系结构，因为新的交互、冲突和事件会随着时间的推移而产生和消退，同时处理在多个智能体之间展开的级联社会动态。</p><p>需要一种方法，能够检索相关事件和长期互动，反思这些记忆以概括和得出更高层次的推论，并应用这种推理来创造计划和反应，在代理人行为的每个时刻乃至更长期的故事情节中产生意义。</p><h2 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h2><h3 id="场景结构-互动"><a href="#场景结构-互动" class="headerlink" title="场景结构/互动"></a>场景结构/互动</h3><p>《Smallville》拥有小村庄的常见功能，包括咖啡馆、酒吧、公园、学校、宿舍、房屋和商店。它还定义了使这些空间具有功能性的子区域和对象，例如房屋中的厨房和厨房中的炉灶（见图2）。所有作为代理人主要居住区的空间都设有床、书桌、衣柜、架子、浴室和厨房。代理人在Smallville中的移动方式类似于简单的视频游戏，进入和离开建筑物，导航地图，并接近其他代理人。代理人的移动由生成代理体系结构和沙盒游戏引擎控制：当模型指示代理人将移动到某个位置时，我们在Smallville环境中计算到目的地的步行路径，然后代理人开始移动。此外，用户还可以作为一个代理人进入Smallville的沙盒世界进行操作。用户所扮演的代理人可以是已经存在于世界中的代理人，比如Isabella和John，也可以是一个没有在Smallville中有过历史的外来访客。Smallville的居民将不会与用户控制的代理人有任何不同的对待方式。他们会察觉到其存在，发起互动，并在形成对其看法之前记住其行为。用户和代理人可以影响这个世界中物体的状态，就像在像《模拟人生》这样的沙盒游戏中一样。例如，当代理人正在睡觉时，床可以被占用，当代理人用完食材制作早餐时，冰箱可以是空的。最后，用户还可以通过以自然语言重写代理人周围物体的状态来重新塑造Smallville中的代理人环境。例如，在Isabella早上做早餐时，用户可以通过向系统输入一个命令来选择对象并说明其新状态，像这样：“&lt;Isabella的公寓：厨房：炉灶&gt; 正在燃烧。” Isabella将会在下一刻注意到这一点并去关闭炉灶并重新制作早餐。同样，如果用户将Isabella的淋浴状态设置为“漏水”当她进入浴室时，她将会从她的客厅拿取工具并尝试修理漏水。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20231211105340882.png" alt="image-20231211105340882"></p><h3 id="生成体的一天"><a href="#生成体的一天" class="headerlink" title="生成体的一天"></a>生成体的一天</h3><p>从单一段描述开始，生成代理开始规划他们的一天。随着时间在沙盒世界中流逝，这些代理之间的行为会随着互动和世界的变化而演变，建立记忆和关系，并协调共同的活动。我们通过追踪我们系统的输出来演示生成代理的行为，以代理人John Lin的一天为例（见图3）。在Lin家，John是第一个早上7点醒来的人。他刷牙、淋浴、穿衣、吃早餐，并在客厅的餐桌上查看新闻。早上8点，Eddy紧随其后，匆匆忙忙地离开床准备上课。他在John即将出门时追上了他：</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20231211110617476.png" alt="image-20231211110617476"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">John: 早上好，Eddy。你睡得好吗？ </span><br><span class="line">Eddy: 早上好，爸爸。是的，我睡得很好。</span><br><span class="line">John: 那很好。你今天要做什么？</span><br><span class="line">Eddy: 我正在为我的课程准备一首新的音乐作品。这周要交，所以我正在努力完成它。但我玩得很开心！ </span><br><span class="line">John: 听起来不错！</span><br></pre></td></tr></table></figure><p>Eddy出门后不久，Mei醒来并加入了John。Mei询问她的儿子，John回忆起他们刚刚的对话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mei: Eddy已经去上学了吗？</span><br><span class="line">John: 是的，他刚刚离开。他正在为他的课程写音乐作品。 </span><br><span class="line">Mei: 哦，太棒了！告诉我详细情况。 </span><br><span class="line">John: 我觉得他真的很喜欢！他说他玩得很开心。</span><br><span class="line">Mei: 那太好了！我为他感到骄傲。</span><br></pre></td></tr></table></figure><p>当他们结束对话时，Mei和John开始准备。Mei去教书并继续研究论文，而John在早上9点前在Willow Market and Pharmacy打开他的药房柜台。</p><h3 id="自发的社交活动"><a href="#自发的社交活动" class="headerlink" title="自发的社交活动"></a>自发的社交活动</h3><p>通过互动，Smallville中的生成代理相互交换信息，建立新关系，并协调共同活动。这些社交行为是 emergent（自发的），而不是预先编程的。</p><h4 id="信息传播"><a href="#信息传播" class="headerlink" title="信息传播"></a>信息传播</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sam: 嗨，Tom，最近怎么样？</span><br><span class="line">Tom: 不错，谢谢。有什么事吗？</span><br><span class="line">Sam: 嗯，我想和你谈谈某件事。事实上，我正在竞选即将举行的地方选举市长职位。</span><br><span class="line">Tom: 真的吗？那太棒了！为什么要竞选？</span><br><span class="line">Sam: 我多年来一直参与地方政治，我真的觉得我可以在我们的社区产生影响。另外，我想为我们带来新的想法和观点。</span><br></pre></td></tr></table></figure><p>当Sam离开后，Tom和John从另一个消息来源听到这个消息，然后讨论了Sam在选举中获胜的机会：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">John: 我听说Sam Moore要竞选地方选举市长。你觉得他有很好的机会吗？</span><br><span class="line">Tom: 我认为他有很好的机会。他一直在社区努力工作，我认为他会得到很多支持。你觉得呢？</span><br><span class="line">John: 我觉得他竞选很不错。我很好奇选举会怎么样。</span><br></pre></td></tr></table></figure><p>渐渐地，Sam的竞选成为城里的话题，一些人支持他，而其他人则保持观望。</p><h4 id="人脉关系记忆"><a href="#人脉关系记忆" class="headerlink" title="人脉关系记忆"></a>人脉关系记忆</h4><p>smallville中的代理随着时间的推移建立新的关系，并记住他们与其他代理的互动。例如，在一开始，Sam不认识Latoya Williams。在Johnson Park散步时，Sam遇到了Latoya，并互相介绍。Latoya提到她正在进行一个摄影项目：“我来这里拍照，为我正在做的项目。”</p><p>在以后的互动中，Sam与Latoya的互动表明他记得那次互动，因为他问道：“嗨，Latoya，你的项目进行得怎么样？”而她回答：“嗨，Sam，进展顺利！”</p><h4 id="协调与组织"><a href="#协调与组织" class="headerlink" title="协调与组织"></a>协调与组织</h4><p>生成代理之间可以相互协调。Isabella Rodriguez在Hobbs Cafe开始计划在2月14日下午5点到7点举行的情人节派对。从这个出发点，代理人在看到朋友和顾客时会邀请他们来Hobbs Cafe或其他地方。随后，Isabella在13日下午装饰了咖啡馆，Maria，是Isabella的常客和亲密朋友，来到了咖啡馆。Isabella请求Maria帮助她装饰派对，Maria答应了。Maria的角色描述提到她喜欢Klaus。那天晚上，Maria邀请了她的暗恋对象Klaus参加派对，他欣然接受。情人节那天，包括Klaus和Maria在内的五名代理人在下午5点来到了Hobbs Cafe，他们享受了派对的欢乐。</p><p>在这种情况下，最终用户只设置了Isabella举办派对的初始意图以及Maria对Klaus的暗恋，而传播信息、装饰、邀请对方、参加派对以及在派对上互动等社交行为是由代理体系结构发起的。</p><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>我们介绍了生成式智能代理——这些代理借助生成模型来模拟可信的人类行为，并证明它们能够产生可信的个体和紧急组群体行为的模拟。</p><p>我们描述了一种架构，通过<strong>扩展大型语言模型</strong>，以自然语言存储代理的完整经验记录，随着时间将这些记忆合成为更高级别的反思，并动态检索它们以规划行为。</p><p>这个架构包含三个主要组成部分。</p><ul><li>第一个是<strong>记忆流</strong>，这是一个长期记忆模块，以自然语言记录代理的全面经历列表。一个记忆检索模型结合了相关性、最新性和重要性，以提取需要用于指导代理每时每刻行为的记录。</li><li>第二个是<strong>反思</strong>，它将记忆综合成随时间变化的高级推理，使代理能够对自己和其他人做出结论，以更好地指导其行为。</li><li>第三个是<strong>规划</strong>，它将这些结论和当前环境翻译成高级行动计划，然后递归地翻译成详细的行为以进行行动和反应。这些反思和计划被反馈到记忆流中，以影响代理未来的行为。</li></ul><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20231016164734625.png" alt="image-20231016164734625"></p><h3 id="记忆流-Memory-and-Retrieval"><a href="#记忆流-Memory-and-Retrieval" class="headerlink" title="记忆流 Memory and Retrieval"></a>记忆流 Memory and Retrieval</h3><p>记忆流（memory stream）最基本的元素是 <em>observation</em>  ：如何实现observation的？</p><p>observation（观察）是生成性代理（generative agents）感知到的事件，直接由代理自身的行为或代理感知到的其他代理或非代理对象的行为产生的。例如，如果一个代理在咖啡店工作，它可能会积累以下观察：</p><ol><li>代理自己正在摆放糕点（Isabella Rodriguez is setting out the pastries）.</li><li>另一个代理正在喝咖啡时学习化学（Maria Lopez is studying for a Chemistry test while drinking coffee）.</li><li>代理和另一个代理正在讨论在咖啡店举办情人节派对的计划（Isabella Rodriguez and Maria Lopez are conversing about planning a Valentine’s day party at Hobbs Cafe）.</li><li>冰箱是空的（The refrigerator is empty）.</li></ol><p><strong>时近性</strong>（Recency）为最近访问的记忆对象分配一个更高的分，使得刚才或今早发生的事情很可能留在智能体的注意力范围内。在我们的实验中，时近性被设计成一个自上次检索记忆以来根据沙盒游戏内小时数呈指数衰减的函数，衰减因子为 0.99。</p><p><strong>重要性</strong>（Importance）通过为智能体觉得重要的记忆对象赋予更高的得分，将关键记忆和普通记忆区分来开。比如，像在房间内吃早饭这样一件平凡的事情可能会得到一个较低的重要性得分，但是和另一半分手这件事则会有一个较高的得分。重要性评分也会有多种可能的实现方式；我们发现直接让 LLM 来输出一个整数是有效的。完整的 prompt 如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="number">1</span> 到 <span class="number">10</span> 的范围内，其中 <span class="number">1</span> 是完全普通的（例如刷牙和整理床铺），<span class="number">10</span> 是非常深刻的（例如分手和大学录取），请评估以下记忆片段可能的深刻程度：</span><br><span class="line">记忆：在 The Willows Market <span class="keyword">and</span> Pharmacy 买杂货</span><br><span class="line">等级: &lt;fill in&gt;</span><br></pre></td></tr></table></figure><p>这个 prompt 对于「打扫房间」会返回整数 2，而对「与你的暗恋对象约会」则返回 8。重要性得分会在记忆对象创建的时候生成。</p><p><strong>相关性</strong>（Relevance）为与当前情况紧密相关的记忆对象分配一个更高的得分。举个例子，如果 query 是一个学生正在和同学讨论化学考试的内容，那么关于他们早餐的记忆对象应该和这件事有较低的相关性，而关于老师和功课的记忆对象应该具有较高的相关性。在实现中，我们使用语言模型为每个记忆的文本描述生成一个 embedding，然后计算记忆 embedding 和 query embedding 的余弦距离作为相关性。</p><p>为了计算最终的检索得分，我们用 min-max scaling 将时近性、重要性和相关性都归一化到 [0, 1] 之间。检索时会将上述三个元素进行加权求和作为每条记忆的最终得分：</p><p>𝑠𝑐𝑜𝑟𝑒 = $𝛼_{𝑟𝑒𝑐𝑒𝑛𝑐𝑦}$ · 𝑟𝑒𝑐𝑒𝑛𝑐𝑦 + $𝛼_{𝑖𝑚𝑝𝑜𝑟𝑡𝑎𝑛𝑐𝑒}$ · 𝑖𝑚𝑝𝑜𝑟𝑡𝑎𝑛𝑐𝑒 + $𝛼_{𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒}$ · 𝑟𝑒𝑙𝑒𝑣𝑎𝑛𝑐𝑒</p><h3 id="反思-Reflection"><a href="#反思-Reflection" class="headerlink" title="反思 Reflection"></a>反思 Reflection</h3><p><strong>挑战</strong>：生成式智能体在仅使用原始 observation 时，很难作出概括或者进行推理。考虑这样一个场景，用户问 Klaus Mueller：「如果你必须在你认识的人里面挑一个一起度过一个小时，你怎么选？」。如果只能访问这些原始 observation，那么 Klaus 会直接选择和他互动最频繁的那个人：Wolfgang（他的大学室友）。不幸的是，Wolfgang和Klaus只是经常在对方路过的时候会看到对方，但其实没有过深的交情。更理想的响应要求智能体对「Klaus花费大量精力在研究项目上」的记忆进行概括，以得到「 Klaus对研究充满热忱」这个更高层次的反思，并且同样认识到「Maria在她自己的研究中（虽然是不同的领域）也付出了努力」，这反应出它们可能有共同的兴趣。在第二种方法下，当 Klaus被问到希望和谁度过时光时，Klaus 会选择 Maria 而非Wolfgang。</p><p><strong>方案</strong>：</p><p>反思（reflection）是周期性生成的；在我们的实验中，当<strong>智能体感知到的最新事件的重要性分数总和超过某个阈值时，就会形成反思</strong>。实际上，智能体每天会反思大约两到三次。</p><p>反思的第一步是根据智能体最近的经历确定可以提出的问题，从而确定要反思的内容。我们使用智能体记忆流中的最近 100 条记录（如「Klaus Mueller 正在阅读一本关于中产阶级的书」、「Klaus Mueller 正在与图书馆里员讨论他的研究项目」、「图书馆的办公桌被占用中」等）构造 prompt 来询问 LLM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅考虑上述信息，我们可以回答关于观察对象的陈述中的3个最突出的高层次问题是什么？</span><br></pre></td></tr></table></figure><p>模型的响应生成了候选问题：例如「Klaus Mueller 热衷于什么话题？」、「Klaus Mueller 和 Maria Lopez 的关系是什么？」。我们使用这些生成的问题作为 query 以进行检索，然后为每个问题收集相关的记忆（也包括其它反思）。接着我们通过 prompt 让语言模型进行感悟（insights）并引用特定的记录，这些记录视作感悟产生的依据。完整的 prompt 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关于 Klaus Mueller 的陈述</span><br><span class="line"></span><br><span class="line">1. Klaus Mueller 正在写科研论文</span><br><span class="line">2. Klaus Mueller 喜欢看关于中产阶级的书</span><br><span class="line">3. Klaus Mueller 正在和 Ayesha Khan 讨论锻炼身体 [ ... ]</span><br><span class="line"></span><br><span class="line">关于这段陈述你能推断出哪 5 个高层次的感悟？（示例格式：感悟（因为 1, 5, 3））</span><br></pre></td></tr></table></figure><p>这个过程会生成像「Klaus Mueller 全身心投入在他对中产阶级的研究上（因为 1, 2, 8, 15）」这样的陈述。我们对它进行解析并以反思的形式存储在记忆流中，包括指向被引用的记忆对象的指针。</p><p>智能体不仅在 observations 上进行反思，还会基于其它反思结果进行进一步的反思：比如，上面关于 Klaus Mueller 的第二个陈述是他之前的反思，而不是他在环境中直接观察到的 observation。最终，智能体生成了反思树：叶子结点代表基本的 observations，而非叶子结点代表了思维。随着非叶子结点的高度变高，它所代表的思维也越抽象越高级。</p><h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>虽然 LLM 可以根据情境信息生成看上去合理的行为，但是智能体需要在更长的一段时间轴上进行规划以确保它们的行为序列的一致性和可信程度。</p><p>如果我们将 Klaus 的背景作为 prompt，描述时间，然后询问语言模型他在给定的时刻应该干什么，那么可能的后果是 Klaus 在中午 12 点的时候吃了一次午饭，但是12.30 的时候再吃一次。优化此刻的可信性牺牲了长时的可信性。</p><p>规划描述了智能体未来的行为序列并且帮助保持其行为在时间维度上的一致性。一个规划包含地点，开始时间和持续时间。比如，「全神贯注于研究」的  Klaus Mueller 在「迫在眉睫的最后期限」下，可能选择整天都在办公桌前奋笔编写论文。规划的其中一条内容可以更好地说明，比如，「从  2023 年 2 月12 日上午 9 点开始，在Oak Hill 大学的宿舍：Klaus Mueller  的房间：桌子，为研究论文阅读并记笔记」。类似反思，规划也存储在记忆流中，并且可被检索。这使得智能体在决策如何行动时，可以综合考虑观察、反思和规划。智能体在必要的时候会中途改变它们的规划。</p><p>规划一个画家智能体在药房柜台一动不动地坐 4 个小时是不现实的，也非常无聊。一个更理想的规划是让它在家工作的4个小时内花一些必要的时间去收集物料、调颜料、休息以及清洁打扫。为了创建这样的规划，我们的方法自上而下递归地生成更多细节。第一步是粗略地制定一个概述当天行程的计划。为了创建初始计划，我们将智能体的摘要性描述（如姓名、特点和最近经历的概括）以及==前一天的摘要作为语言模型的 prompt==。一个完整的 prompt 示例如下，最下面的续写部分交给 LM 完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名: Eddy Lin (age: 19)</span><br><span class="line">性格：善良、外向、好客</span><br><span class="line">Eddy Lin 是一个 Oak Hill 大学攻读音乐理论与作曲的学生。他热衷于探索不同的音乐风格，并且一直想方设法提升知识水平。Eddy Lin 正在为他的大学班级创作。同时，他也积极上课以学习音乐理论。Eddy LIn 对他正在创作的新作品感到非常兴奋，但他也想在接下来几天内花更多时间来完成它。</span><br><span class="line">在 2 月 12 日，Eddy（1）早上 7:00 醒来并完成了例行事务，[ ... ]（6）在晚上 10 点左右准备入睡</span><br><span class="line">今天是 2 月 13 日周三。这里是 Eddy 今天粗略的规划：（1）</span><br></pre></td></tr></table></figure><p>这生成了智能体一天规划的大致构想，可以分为 5 到 8 条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）在早上 8 点起床并完成晨间例事</span><br><span class="line">（2）去 Oak Hill 大学然后从 10 点开始上课</span><br><span class="line">[ ... ]</span><br><span class="line">（5）从下午 1 点到 5 点创作他的新音乐作品</span><br><span class="line">（6）在下午 5.30 吃完饭</span><br><span class="line">（7）完成学校的作业然后在晚上 11 点上床睡觉</span><br></pre></td></tr></table></figure><p>智能体会将这个规划保存在记忆流中，然后递归地对它进行拆解以生成更精细的行为。首先按小时级进行拆解：「从下午 1 点到 5 点创作他的新音乐作品」的计划变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下午 1:00: 从对音乐创作进行头脑风暴开始</span><br><span class="line">[ ... ]</span><br><span class="line">下午 4:00: 短暂的休息一下并且在检查和润色他的作品之前恢复一下创造力</span><br></pre></td></tr></table></figure><p>我们接着再对上述计划拆解成 5 - 15 分钟的级别，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下午 4:00: 吃点零食，比如水果、燕麦棒或者坚果</span><br><span class="line">下午 4:05: 在工作地附近逛一逛</span><br><span class="line">[ ... ]</span><br><span class="line">下午 4:50: 花几分钟时间收拾一下工作区</span><br></pre></td></tr></table></figure><p>这个过程是可以调整的，以匹配理想的粒度。</p><h4 id="4-3-1-Reacting-and-Updating-Plans"><a href="#4-3-1-Reacting-and-Updating-Plans" class="headerlink" title="4.3.1. Reacting and Updating Plans."></a><strong>4.3.1. Reacting and Updating Plans</strong>.</h4><p> 生成式智能体不断执行着动作。在每个时间步，他们感知周围的世界，并将观察到的结果记录在记忆流中。我们将这些 observations 作为 prompt，<strong>让语言模型决定智能体应该继续遵循既定的计划，还是作出反应</strong>。比如，站在画架前进行绘画可能引发关于画架的 observation，但这不意味着需要作出特别的反应。但是，如果 Eddy 的父亲 John 看到 Eddy 在自家花园散步，那么情况就不一样了。下面是 prompt 的内容，[Agent‘s Summary Description] 代表动态生成的、长长的一段关于智能体目的和处置的摘要，这在 Appendix A 中进行了描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Agent’s Summary Description]</span><br><span class="line">现在是 2023 年 2 月 13 日下午 4:56。</span><br><span class="line">John Lin 的状态：John 早早下班回家。</span><br><span class="line">Observation: John 看到 Eddy 在他的工作地点附近散步。</span><br><span class="line">John 记忆中相关上下文的摘要：Eddy Lin 是 John 的 Lin 的儿子。Eddy Lin 一直在为他的班级创作音乐。Eddy Lin 喜欢在思考或听音乐时在花园里走来走去。</span><br><span class="line">John 应该对这个 observation 作出反应吗？如果是的话应该作出什么反应？</span><br></pre></td></tr></table></figure><p>记忆中相关上下文的摘要是通过如下方法得到的：<strong>根据两个模版「[观察者] 和 [被观察实体] 的关系是什么」和「[被观察实体] 正在 [被观察实体的动作状态]」构造prompts</strong>，在记忆中进行检索，然后总结在一起。针对上面的例子，语言模型的输出为「John 会考虑向 Eddy 询问关于他的音乐创作项目的事情」。接着我们从这个反应发生的时间开始，重新生成智能体现在的规划。最终，如果动作预示着智能体之间的交互行为，我们会生成他们的对话。</p><h4 id="4-3-2-Dialogue"><a href="#4-3-2-Dialogue" class="headerlink" title="4.3.2. Dialogue."></a><strong>4.3.2. Dialogue.</strong></h4><p>智能体在交互时会进行对话。我们根据他们对彼此的记忆来调节他们说的话，以实现智能体间的对话。例如，当 John 开始与 Eddy 对话时，我们通过使用他对 Eddy 的记忆摘要以及当他决定向 Eddy 询问他的作曲项目时的预期反应来生成 John 的第一句话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Agent’s Summary Description]</span><br><span class="line">现在是 2023 年 2 月 13 日下午 4:56。</span><br><span class="line">John Lin 的状态：John 早早下班回家。</span><br><span class="line">Observation: John 看到 Eddy 在他的工作地附近散步。</span><br><span class="line">John 记忆中相关的上下文摘要：Eddy Lin 是 John Lin 的儿子。Eddy Lin 一直在为他的班级创作音乐。Eddy LIn 在思考和听音乐的时候喜欢逛花园。</span><br><span class="line">John 正在询问 Eddy 他的音乐项目的情况。他可能会对 Eddy 说什么呢？</span><br></pre></td></tr></table></figure><p>返回的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嗨，Eddy。你们班的音乐创作项目进展如何了？</span><br></pre></td></tr></table></figure><p>在艾迪看来，约翰发起对话被看作是他可能想要做出反应的事件。因此，正如约翰所做的那样，埃迪找回并总结了他关于与约翰关系的记忆，以及他的记忆可能与约翰在对话中的最后一句话有关。如果他决定回应，我们就用他总结的记忆和当前的对话历史生成艾迪的话语：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Agent’s Summary Description]</span><br><span class="line">现在是2023年2月13日下午4：56。</span><br><span class="line">Eddy·Lin的状态：Eddy正在他的工作场所进行短暂的散步。观察：John正在与艾迪展开对话。从Eddy的回忆中总结相关语境：John·Lin是Eddy·Lin的父亲。John·Lin非常关心并有兴趣进一步了解Eddy·Lin的学校工作。John·Lin知道Eddy·Lin正在创作一部音乐作品。下面是对话的历史：John：Hey Eddy，这堂课的音乐创作计划是怎么来的?</span><br><span class="line">Eddy将如何回应John?</span><br></pre></td></tr></table></figure><p>这就产生了艾迪的回应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;嘿，爸爸，一切都好。我一直在花园周围散步，以清除我的头脑，获得一些灵感。&quot;</span><br></pre></td></tr></table></figure><p>不停的根据之前的模板向LLM提prompt，并加入对话历史，==直到其中一方结束对话为止。==</p><h2 id="沙盒结构"><a href="#沙盒结构" class="headerlink" title="沙盒结构"></a>沙盒结构</h2><p>我们将沙箱环境-区域和对象-表示为树形数据结构，树中的一条边表示沙箱世界中的包含关系。我们将这棵树转换成自然语言传递给生成代理。例如，’灶’作为’厨房’的孩子被渲染成’厨房里有灶’。</p><p>当智能体在沙盒世界中航行时，他们更新这棵树以反映新感知的区域。Agent并不是无所不知的：当他们离开某个区域时，他们的树可能会过期，当他们重新进入该区域时，他们的树会更新。</p><h3 id="Sandbox-Environment-Implementation"><a href="#Sandbox-Environment-Implementation" class="headerlink" title="Sandbox Environment Implementation"></a>Sandbox Environment Implementation</h3><ul><li><p>服务器维护一个 JSON 数据结构，其中包含了沙盒世界中每个智能体的信息（它们当前的位置、当前行为的描述以及正在与哪个对象交互）。在每个沙盒时间步，服务器会解析 JSON 来获取生成式智能体的任何变化、将它们移动到新的位置和更新正在与智能体进行交互的对象的状态</p></li><li><p>终端用户通过一段简短的自然语言描述初始化一个新的智能体</p></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1)每当一天结束时都会自动生成这一天的摘要提交给第二天作为初始计划吗？这里的摘要是手工生成的吗？</p><p>我们的许多 prompts 都需要一个关于智能体的简要描述，在上文中出现的地方都用 [Agent’s Summary Description] 简写了。在实验中，该摘要包括智能体的身份信息（例如姓名、年龄、个性），以及关于它们的主要动机、当前职业和自我评估的描述。由于这个信息在多个 prompts 中频繁使用，我们会定期生成它并将其作为缓存访问。</p><p>为了实现这一点，我们用「[姓名] 的主要个性」来进行查询。然后通过 prompt 让语言模型来总结检索结果中的描述信息，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定以下陈述，人们会怎么评价 Eddy 的主要个性？</span><br><span class="line">\- Eddy Lin 是一个 Oak Hill 学院攻读音乐理论和作曲的学生</span><br><span class="line">\- Eddy Lin 正在进行一项新的作曲工作</span><br><span class="line">[ ... ]</span><br></pre></td></tr></table></figure><p>返回的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Eddy Lin 是 Oak Hill 学院的一名学生，主修音乐理论和作曲。 他喜欢探索不同的音乐风格，并一直在寻找方法来扩展自己的知识。</span><br></pre></td></tr></table></figure><p>我们同时对「[姓名] 当前的日常工作」和「[姓名] 对他最近生活进展的感受」采取相同的处理过程。生成的这三个摘要会和智能体的姓名、年龄以及个性拼起来作为缓存的摘要。</p><p>2)有没有可能对话一直不结束</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> NPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点</title>
      <link href="/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="计网面试"><a href="#计网面试" class="headerlink" title="计网面试"></a>计网面试</h1><h3 id="什么是三次握手-three-way-handshake-？"><a href="#什么是三次握手-three-way-handshake-？" class="headerlink" title="什么是三次握手 (three-way handshake)？"></a>什么是三次握手 (three-way handshake)？</h3><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129101827556_21212.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092132185.png" alt="三次握手"></a></p><ul><li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li><li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li><li>第三次握手：客户端检查acknowledge  number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge  number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge  number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li></ul><h4 id="TCP建立连接可以两次握手吗？为什么"><a href="#TCP建立连接可以两次握手吗？为什么" class="headerlink" title="TCP建立连接可以两次握手吗？为什么?"></a>TCP建立连接可以两次握手吗？为什么?</h4><details open=""><summary>展开</summary><p dir="auto">不可以。有两个原因：</p><p dir="auto">首先，可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p><blockquote><p dir="auto">client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p></blockquote><p dir="auto">其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p></details> <h4 id="可以采用四次握手吗？为什么？"><a href="#可以采用四次握手吗？为什么？" class="headerlink" title="可以采用四次握手吗？为什么？"></a>可以采用四次握手吗？为什么？</h4><details open=""><summary>展开</summary><p dir="auto">可以。但是会降低传输的效率。</p><p dir="auto">四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p></details><h4 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h4><details open=""><summary>展开</summary><p dir="auto">Server端：<br>由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</p><p dir="auto">Client端，两种情况：</p><ol dir="auto"><li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态</li><li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包（连接异常终止包）应答。</li></ol></details><h4 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h4><details open=""><summary>展开</summary><p dir="auto">服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></details><h4 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h4><details open=""><summary>展开</summary><p dir="auto">TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p></details><h4 id="为什么初始序列号要是随机的？"><a href="#为什么初始序列号要是随机的？" class="headerlink" title="为什么初始序列号要是随机的？"></a>为什么初始序列号要是随机的？</h4><ul><li>减少将那些仍在网络中存在的来自两台主机之间先前已终止的链接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性。（它碰巧与旧连接使用了相同的序列号）</li><li>如果初始序列号都是有规律的，容易被伪造收报方攻击。例如客户端每次都以0为初始序列号，那另一个伪造的收报方只要不停的发1就可以。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>初始化序列号时是采用随机的方式来提升攻击者猜测序列号的难度，以增加安全性。</p><p>但是这种方式只能避免攻击者预测出合法的 RST 报文，而无法避免攻击者截获客户端的报文，然后中途伪造出合法 RST 报文的攻击的方式。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131052300.png" alt="图片"></p><h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129112652915_15481.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092146664.png" alt="四次挥手"></a></p><ul><li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li><li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li><li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li><li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge  number=序列号+1给服务器；服务器收到后，确认acknowledge  number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li></ul><h5 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5><details open=""><summary>展开</summary><p dir="auto">因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p></details><h5 id="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h5><details open=""><summary>展开</summary><p dir="auto">客户端没有收到ACK确认，会重新发送FIN请求。</p></details><h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h5><details open=""><summary>展开</summary><p dir="auto">第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p><p dir="auto">MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p></details><h3 id="TCP如何实现流量控制？"><a href="#TCP如何实现流量控制？" class="headerlink" title="TCP如何实现流量控制？"></a>TCP如何实现流量控制？</h3><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129145400104_2106.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092336557.png" alt="滑动窗口"></a></p><p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口  receiver  window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p><p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。==接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力==。</p><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/1615897397.gif"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092336441.gif" alt="滑动窗口"></a></p><h5 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h5><details open=""><summary>展开</summary><p dir="auto">如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistencetimer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p></details><h3 id="TCP的拥塞控制是怎么实现的？"><a href="#TCP的拥塞控制是怎么实现的？" class="headerlink" title="TCP的拥塞控制是怎么实现的？"></a>TCP的拥塞控制是怎么实现的？</h3><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129153624025_28293.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092336351.png" alt="拥塞控制"></a></p><p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p><ol><li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li></ol><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129155345024_11142.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092336180.png" alt="slow start"></a></p><p>2.拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.</p><blockquote><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p></blockquote><p>3.快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129161026032_32431.png"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202092336150.png" alt="快重传"></a></p><p>4.快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br> 也有的快恢复是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS  。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</p><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol><li>TCP是面向连接的，UDP是无连接的；</li></ol><details open=""><summary>什么叫无连接？</summary><p dir="auto">UDP发送数据之前不需要建立连接</p></details><ol><li>TCP是可靠的，UDP不可靠；</li></ol><details open=""><summary>什么叫不可靠？</summary><p dir="auto">UDP接收方收到报文后，不需要给出任何确认</p></details><ol><li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li><li>TCP是面向字节流的，UDP是面向报文的；</li></ol><details open=""><summary>什么意思？</summary><p dir="auto">面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p></details><ol><li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li><li>UDP 的主机不需要维持复杂的连接状态表</li></ol><h3 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h3><details><summary>展开</summary>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</details>### TCP 和 UDP 可以使用同一个端口吗？<p>可以</p><p>TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><p>因此， TCP/UDP 各自的端口号也相互独立，互不影响。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240327111424516.png" alt="image-20240327111424516"></p><h5 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h5><details><summary>展开</summary>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠<h4 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h4><p>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）</p><p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p><p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络<strong>尽最大努力交付</strong>数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p><h4 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h4><ol><li>数据包校验</li><li>对失序数据包重新排序（TCP报文具有序列号）</li><li>丢弃重复数据</li><li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li><li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li><li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li></ol><h4 id="简述TCP粘包现象"><a href="#简述TCP粘包现象" class="headerlink" title="简述TCP粘包现象"></a>简述TCP粘包现象</h4><p>TCP是面向流协议，发送的单位是字节流，因此会有将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</p><h4 id="TCP粘包现象处理方法"><a href="#TCP粘包现象处理方法" class="headerlink" title="TCP粘包现象处理方法"></a>TCP粘包现象处理方法</h4><p>固定发送信息长度，或在两个信息之间加入分隔符。</p><h3 id="TCP的缺陷"><a href="#TCP的缺陷" class="headerlink" title="TCP的缺陷"></a>TCP的缺陷</h3><h4 id="升级-TCP-的工作很困难"><a href="#升级-TCP-的工作很困难" class="headerlink" title="升级 TCP 的工作很困难"></a>升级 TCP 的工作很困难</h4><p>TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核。</p><p>由于内核升级涉及到底层软件和运行库的更新，服务程序就需要回归测试是否兼容新的内核版本，所以服务器的内核升级比较保守和缓慢。</p><ul><li><em>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</em></li></ul><h4 id="TCP-建立连接的延迟"><a href="#TCP-建立连接的延迟" class="headerlink" title="TCP 建立连接的延迟"></a>TCP 建立连接的延迟</h4><p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。</p><p>TCP 三次握手和 TLS 握手延迟，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131044901.jpeg" alt="图片"></p><p>TCP 三次握手的延迟被 TCP Fast Open （快速打开）这个特性解决了，这个特性可以在「第二次建立连接」时减少 TCP 连接建立的时延。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131047243.png" alt="图片"></p><p>过程如下：</p><ul><li>在第一次建立连接的时候，服务端在第二次握手产生一个 <code>Cookie</code> （已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 <code>Cookie</code>，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个 RTT 的时延；</li><li>在下次请求的时候，客户端在 SYN 包带上 <code>Cookie</code> 发给服务端，就提前可以跳过三次握手的过程，因为 <code>Cookie</code> 中维护了一些信息，服务端可以从 <code>Cookie</code> 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</li></ul><h4 id="TCP-存在队头阻塞问题"><a href="#TCP-存在队头阻塞问题" class="headerlink" title="TCP 存在队头阻塞问题"></a>TCP 存在队头阻塞问题</h4><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131056530.jpeg" alt="图片"></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 <code>packet #3</code> 在网络中丢失了，即使 <code>packet #4-6</code> 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 <code>packet #3</code> 重传后，接收方的应用层才可以从内核中读取到数据。</p><h4 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p><p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><h3 id="怎么用UDP来实现TCP？"><a href="#怎么用UDP来实现TCP？" class="headerlink" title="怎么用UDP来实现TCP？"></a>怎么用UDP来实现TCP？</h3><p><a href="https://mp.weixin.qq.com/s/hX75YxVOMtsnB6Sm_yjm0g">小林图解</a></p><ul><li>UDP是传输层的协议，要在应用层全部实现一遍</li></ul><p>现在市面上已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，已经应用在了 HTTP/3。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131108596.png" alt="图片"></p><h4 id="实现可靠传输—头部设计"><a href="#实现可靠传输—头部设计" class="headerlink" title="实现可靠传输—头部设计"></a>实现可靠传输—头部设计</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131109651.png" alt="图片"></p><p>Packet Header 首次建立连接时和日常传输数据时使用的 Header 是不同的。如下图，注意我没有把 Header 所有字段都画出来，只是画出了重要的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131127170.jpeg" alt="图片">Packet Header</p><p>细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。</li></ul><p>QUIC 也是需要三次握手来建立连接的，主要目的是为了确定连接 ID。</p><p>建立连接时，连接 ID 是由服务器根据客户端的 Source Connection ID 字段生成的，这样后续传输时，双方只需要固定住 Destination Connection ID（连接 ID ），从而实现连接迁移功能。所以，你可以看到日常传输数据的 Short Packet Header 不需要在传输 Source Connection ID 字段了。</p><p>Short Packet Header 中的 Packet Number 是每个报文独一无二的编号，它是严格递增的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131127759.jpeg" alt="图片"></p><p>为什么要这么设计呢？</p><p>我们先来看看  TCP 的问题，TCP 在重传报文时的序列号和原始报文的序列号是一样的，也正是由于这个特性，引入了 TCP 重传的歧义问题。</p><h5 id="TCP-重传的歧义问题"><a href="#TCP-重传的歧义问题" class="headerlink" title="TCP 重传的歧义问题"></a><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131127818.jpeg" alt="图片">TCP 重传的歧义问题</h5><p>比如上图，当 TCP 发生超时重传后，客户端发起重传，然后接收到了服务端确认 ACK 。由于客户端原始报文和重传报文序列号都是一样的，那么服务端针对这两个报文回复的都是相同的 ACK。</p><p>这样的话，客户端就无法判断出是原始报文的响应还是重传报文的响应，这样在计算 RTT（往返时间） 时应该选择从发送原始报文开始计算，还是重传原始报文开始计算呢？</p><ul><li>如果算成原始报文的响应，但实际上是重传报文的响应（上图右），会导致采样 RTT 变大；</li><li>如果算成重传报文的响应，但实际上是原始报文的响应（上图左），又很容易导致采样 RTT 过小；</li></ul><p>RTT 计算不精确的话，那么 RTO （超时时间）也就不精确，因为 RTO 是基于 RTT 来计算的，RTO 计算不准确可能导致重传的概率事件增大。</p><p>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131127745.jpeg" alt="图片"></p><p>如果 ACK 的 Packet Number 是 N+M，就根据重传报文计算采样 RTT。如果 ACK 的 Pakcet Number 是 N，就根据原始报文的时间计算采样 RTT，没有歧义性的问题。</p><p>另外，还有一个好处，<strong>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</strong>。</p><p>待发送端超过一定时间没收到 Packet N 的确认报文后，会将需要重传的数据包放到待发送队列，重新编号比如数据包 Packet N+M 后重新发送给接收端，对重传数据包的处理跟发送新的数据包类似，这样就不会因为丢包重传将当前窗口阻塞在原地，从而解决了队头阻塞问题。</p><p>所以，Packet Number 单调递增的两个好处：</p><ul><li>可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；</li><li>可以支持乱序确认，防止因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；</li></ul><h4 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h4><h5 id="HTTP-2-的队头阻塞"><a href="#HTTP-2-的队头阻塞" class="headerlink" title="HTTP/2  的队头阻塞"></a>HTTP/2  的队头阻塞</h5><p>HTTP/2 通过抽象出 Stream 的概念，实现了 HTTP 并发传输，一个 Stream 就代表 HTTP/1.1 里的请求和响应。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131142534.png" alt="图片">HTTP/2</p><p>在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。</p><p><strong>但是 HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131141627.jpeg" alt="图片"></p><h5 id="没有队头阻塞的-QUIC"><a href="#没有队头阻塞的-QUIC" class="headerlink" title="没有队头阻塞的 QUIC"></a>没有队头阻塞的 QUIC</h5><p>QUIC 也借鉴 HTTP/2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。</p><p>但是 <strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><p>假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202206131141682.jpeg" alt="图片"></p><h4 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h4><h4 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h4><h4 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h4><h4 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h4><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li><li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li></ol><h4 id="简述半连接队列和全连接队列"><a href="#简述半连接队列和全连接队列" class="headerlink" title="简述半连接队列和全连接队列"></a>简述半连接队列和全连接队列</h4><h5 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h5><p>当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN Received)，此时会将这个连接信息放入「半连接队列」，半连接队列也被称为 SYN Queue，存储的是 “inbound SYN packets”。</p><p>旦收到客户端的 ACK，服务端就开始尝试把它加入另外一个<strong>全连接队列（Accept Queue</strong>）。</p><h5 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h5><p>「全连接队列」包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。</p><p>此时的 socket 处于 ESTABLISHED 状态。每次应用调用 accept() 函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。</p><h4 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h4><p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</p><p>优化方式：</p><ol><li>缩短SYN Timeout时间 </li><li>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li></ol><h5 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h5><details open=""><summary>展开</summary><ol dir="auto"><li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li><li>服务器从中选出一组加密算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li><li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，<strong>发行者证书的公钥</strong>能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li><li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong></strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li><li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li><li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li></ol><p dir="auto">总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p></details><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240327103416107.png" alt="image-20240327103416107" style="zoom: 67%;" /><h5 id="输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？"><a href="#输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？" class="headerlink" title="输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？"></a>输入 <a href="http://www.baidu.com,怎么变成/">www.baidu.com，怎么变成</a> <a href="https://www.baidu.com/">https://www.baidu.com</a> 的，怎么确定用HTTP还是HTTPS？</h5><p>一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。（要重定向）但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。（不重定向，直接冲）</p><h5 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h5><details open=""><summary>展开</summary><ul dir="auto"><li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li><li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li><li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</li></ul></details><h5 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h5><details open=""><summary>展开</summary><ul dir="auto"><li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li><li>摘要算法:MD5、SHA</li></ul></details><h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol><li>GET是幂等的，即读取同一个资源（只是查询数据不会影响到资源的变化），总是得到相同的数据，POST不是幂等的；（每次调用可能会改变服务器上的资源）</li><li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li><li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li><li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li><li>GET的长度有限制（一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。），而POST数据大小无限制</li><li>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</li></ol><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><h4 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie?"></a>什么是Cookie?</h4><p>我们知道HTTP协议是无状态的，一次请求完成，不会持久化请求与相应的信息。那么，在购物车、用户登录状态、页面个性化设置等场景下，就无法识别特定用户的信息。这时Cookie就出现了。</p><p>Cookie是客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送。对于Cookie，可以设置过期时间。</p><p>通常，Cookie用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。这样就解决了HTTP无状态的问题。</p><p>Cookie主要用于以下方面：</p><ul><li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li><li>个性化设置(如用户自定义设置、主题等)</li><li>浏览器行为跟踪(如跟踪分析用户行为等)</li></ul><p>Cookie存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。针对这个问题，怎么解决呢?那就引入了Session。</p><h4 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session?"></a>什么是Session?</h4><p>Session代表服务器和客户端一次会话的过程。</p><p>对照Cookie，Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>当在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而会在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。</p><p>目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁。</p><h4 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h4><p>如果说<strong>Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</strong></p><p><strong>1、cookie数据存放在客户的浏览器上，session数据放在服务器上.</strong></p><p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一  SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p><p><strong>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</strong></p><p><strong>3、设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。</strong></p><p><strong>4、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</strong></p><p><strong>5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)</strong> </p><p>  注意:</p><p>   session很容易失效,用户体验很差;</p><p>   虽然cookie不安全,但是可以加密 ;</p><p>   cookie也分为永久和暂时存在的;</p><p>   浏览器 有禁止cookie功能 ,但一般用户都不会设置;</p><p>   一定要设置失效时间,要不然浏览器关闭就消失了;</p><p>   例如:</p><p>​      记住密码功能就是使用永久cookie写在客户端电脑，下次登录时，自动将cookie信息附加发送给服务端。</p><p>​      application是全局性信息，是所有用户共享的信息，如可以记录有多少用户现在登录过本网站，并把该信息展示个所有用户。</p><p> <strong>两者最大的区别在于生存周期，一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</strong> </p><p>Session信息是存放在server端，但session id是存放在client cookie的，当然php的session存放方法是多样化的，这样就算禁用cookie一样可以跟踪 </p><p>Cookie是完全保持在客户端的如：IE firefox 当客户端禁止cookie时将不能再使用</p><h4 id="禁用Cookie会怎样"><a href="#禁用Cookie会怎样" class="headerlink" title="禁用Cookie会怎样?"></a>禁用Cookie会怎样?</h4><p>如果客户在浏览器禁用了Cookie，该怎么办呢?</p><p>方案一：拼接SessionId参数。在GET或POST请求中拼接SessionID，GET请求通常通过URL后面拼接参数来实现，POST请求可以放在Body中。无论哪种形式都需要与服务器获取保持一致。</p><p>这种方案比较常见，比如老外的网站，经常会提示是否开启Cookie。如果未点同意或授权，会发现浏览器的URL路径中往往有”?sessionId=123abc”这样的参数。</p><p>方案二：基于Token(令牌)。在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器，用于服务器验证请求用户的身份。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ul><li><p>请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p><ul><li>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li><li>查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</li><li>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</li><li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li><li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li></ul></li><li><p>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</p></li><li><p>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</p></li><li><p>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p></li><li><p>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</p></li><li><p>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p></li></ul><h3 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a><strong>什么是DNS？</strong></h3><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。　　 通俗的讲，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)等链接。因为，DNS就相当于一个电话本，比如你要找[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)等链接。因为，DNS就相当于一个电话本，比如你要找[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com)这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</a></p><h4 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h4><p>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p><p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p><h3 id="简述DNS协议"><a href="#简述DNS协议" class="headerlink" title="简述DNS协议"></a>简述DNS协议</h3><p>DNS协议是基于UDP<strong>的应用层</strong>协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p><h3 id="简述DNS劫持"><a href="#简述DNS劫持" class="headerlink" title="简述DNS劫持"></a>简述DNS劫持</h3><p>DNS是指将网页域名翻译为对应的IP的一种方法。DNS劫持指攻击者篡改结果，使用户对域名的解析IP变成了另一个IP。</p><h3 id="简述dos攻击"><a href="#简述dos攻击" class="headerlink" title="简述dos攻击"></a>简述dos攻击</h3><p>DoS是Denial of Service的简称，也称为拒绝服务攻击，通过发送大量的无用请求数据包给服务器，耗尽服务器资源，从而无法通过正常的访问服务器资源，导致服务器崩溃。</p><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol><h3 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p><ul><li><p>Bellman-ford</p></li><li><p>好消息传得快，坏消息传得慢。</p><ul><li>当网络出现故障时，要经过较长的时间才能将此信息传送到所有的路由器，“慢收敛”。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240327141053186.png" alt="image-20240327141053186"></p><p>当出现坏消息时，比如网1出现了故障：</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240327141117025.png" alt="image-20240327141117025"></p><ul><li>这个时候R1是知道是无法到达的，则其到网1的距离为16，并且为直接交付。</li><li>但是R2在收到R1报文之前，即在R2并不知道R1出故障时，发送了原来的报文，网1 2 R1。</li><li>于是，R1收到R2跟新报文后，误以为可以经过R2到网1，于是更新自己的路由表，网1 3 R2，并且将次更新信息发送给R2.</li><li>然后R2以后又跟新自己的路由表为网1 4 R1, 30s后，又把这个信息发送给R1.</li><li>一直到知道了距离等于16为止，这个时候才知道，噢噢噢噢原来，如此原来，是不可以达到呀。</li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202101727047.png" alt="image-20220210172724812"></p><ul><li>应用层：常见协议：<ul><li>FTP(21端口)：文件传输协议</li><li>SSH(22端口)：远程登陆</li><li>TELNET(23端口)：远程登录</li><li>SMTP(25端口)：发送邮件</li><li>POP3(110端口)：接收邮件</li><li>HTTP(80端口)：超文本传输协议</li><li>DNS(53端口)：运行在UDP上，域名解析服务</li></ul></li><li>传输层：TCP/UDP</li><li>网络层：IP、ARP、NAT、RIP…</li></ul><details open=""><summary>路由器、交换机位于哪一层？</summary><ul dir="auto"><li>路由器网络层，根据IP地址进行寻址；</li><li>交换机数据链路层，根据MAC地址进行寻址</li></ul></details><h4 id="物理层有什么作用"><a href="#物理层有什么作用" class="headerlink" title="物理层有什么作用"></a>物理层有什么作用</h4><p>主要解决两台物理机之间的通信，通过<strong>二进制比特流</strong>的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</p><h4 id="数据链路层有什么作用"><a href="#数据链路层有什么作用" class="headerlink" title="数据链路层有什么作用"></a>数据链路层有什么作用</h4><p>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并<strong>封装成帧</strong>，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</p><h4 id="网络层有什么作用"><a href="#网络层有什么作用" class="headerlink" title="网络层有什么作用"></a>网络层有什么作用</h4><p>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</p><h4 id="传输层有什么作用"><a href="#传输层有什么作用" class="headerlink" title="传输层有什么作用"></a>传输层有什么作用</h4><p>传输层提供了进程间的逻辑通信，传输层向高层用户<strong>屏蔽了下面网络层的核心细节</strong>，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h4 id="会话层有什么作用"><a href="#会话层有什么作用" class="headerlink" title="会话层有什么作用"></a>会话层有什么作用</h4><p>建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</p><h4 id="表示层有什么作用"><a href="#表示层有什么作用" class="headerlink" title="表示层有什么作用"></a>表示层有什么作用</h4><p>对<strong>数据格式进行编译</strong>，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p><h4 id="应用层有什么作用"><a href="#应用层有什么作用" class="headerlink" title="应用层有什么作用"></a>应用层有什么作用</h4><p>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</p><h3 id="IP地址的分类？"><a href="#IP地址的分类？" class="headerlink" title="IP地址的分类？"></a>IP地址的分类？</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202101731191.png" alt="image-20210423105710272"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202101731778.png" alt="image-20210423111715385"></p><h5 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h5><p>私有ip属于非注册地址，专门为组织机构内部使用。RFC1918定义了私有IP地址范围：</p><p><strong>A: 10.0.0.0~10.255.255.255 即10.0.0.0/8</strong></p><p><strong>B:172.16.0.0~172.31.255.255即172.16.0.0/12</strong></p><p><strong>C:192.168.0.0~192.168.255.255 即192.168.0.0/16</strong>    </p><h3 id="什么叫划分子网？"><a href="#什么叫划分子网？" class="headerlink" title="什么叫划分子网？"></a>什么叫划分子网？</h3><p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p><h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP  地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做</p><h3 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h3><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏研发场景题</title>
      <link href="/2023/11/08/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
      <url>/2023/11/08/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="战争迷雾"><a href="#战争迷雾" class="headerlink" title="战争迷雾"></a>战争迷雾</h2><ul><li>大量移动单位和大视野不动单位</li></ul><p>这个用个循环暴力计算显然不现实, 除非你地图很小. 所以, 优化思路就是针对移动的单位重新计算, 针对不动的单位只算一次<br>首先, 我们可以用坐标(X,Y)和视野半径(R)三个值确定出一个唯一值K代表一个提供视野的单位U<br>对于每帧新加入(K当前不存在)的U, 定义其生命周期L=MAX. 其余的就对U的L进行递减<br>移除L&lt;=0的U. 针对于L=MAX的, 计算其可见的格子, 如果可见, 则格子的计数C加1<br>每个格子的可见计数C&gt;0的表示可见, 否则就是不可见, 然后更新到纹理上<br>对于0&lt;L&lt;MAX的单位U全部不用计算, 所以不动的单位就不用更新</p><ul><li>预计算FOV</li></ul><p>如果视野阻挡不会变化的话, 可以针对每个点计算其最大视野范围的可见性信息, 缓存起来<br>如果用1bit表示每个格子, 最大视野范围20, 地图大小256x256个格子的话, 所需要的内存空间为41x41x256x256bit=13.13MB, 如果再剔除掉视野阻挡内的点, 应该更小</p><ul><li>平滑</li></ul><p>加了一个速度适中的<strong>渐变动画效果</strong>而已。需要消除/添加阴影时，不去瞬间切换遮罩物透明度，而是触发一个渐变过程，使玩家产生错觉。</p><h2 id="热更新的方式"><a href="#热更新的方式" class="headerlink" title="热更新的方式"></a>热更新的方式</h2><p>1.使用基于lua的ulua技术，让游戏部分ui或者部分逻辑模块使用lua脚本编写，这样可维护性强，易于扩展。（准则：动态特性适合用来做游戏UI）</p><p>2.使用C#Assembly 的反射技术（ class.GetType.Assembly &amp; calss.GetType），正如前面所说，安卓适合，苹果不适合，这样就满足不了发布双版本的需求。</p><p>3.最后一种就是C#中的light技术。</p><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>redis有序集合-&gt;字典+<a href="https://www.cnblogs.com/WJ5888/p/4516782.html">跳表</a></p><p>如果人还是太多-&gt;分桶</p><h2 id="网格法"><a href="#网格法" class="headerlink" title="网格法"></a>网格法</h2><p>网格，顾名思义就是把游戏场景划分为一个个格子，如图所示，2D的情况下使用的是一个二维数组，图中的白块处于第6行第6列（左下作为起点），那么它应该存入[5,5]的索引中。<br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051130785.png" alt="在这里插入图片描述"><br>如果物体跟网格线交叉了，如下图，物体没有完全处于网格内，那么它应该存储在和它交叉的所有网格：[4,4]，[4,5]，[5,4]，[5,5]。<br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051130975.png"><br>当查询时，只要找到物体所在的网格，拿出网格内的所有其他物体挨个遍历即可。<br>到这里，我们可以总结出网格法的优缺点：</p><ul><li>物体插入时很快，只有O(1)复杂度</li><li>物体可以很方便地动态更新自己在网格中的位置</li><li>对于跨多个网格的物体，需要占用更多的空间来存储</li></ul><h2 id="八叉树"><a href="#八叉树" class="headerlink" title="八叉树"></a>八叉树</h2><p>八叉树（octree）是三维空间划分的数据结构之一，它用于加速空间查询，例如在游戏中</p><ul><li><p>邻近查询（proximity query），如查询玩家角色某半径范围内的敌方NPC。</p></li><li><p>碰撞检测的粗略阶段（broad phase），找出潜在可能碰撞的物体对。</p></li></ul><p>简单来说，八叉树的空间划分方式是，把一个立方体分割为八个小立法体，然后递归地分割小立方体。</p><p>四／八叉树有多种变种，先谈一个简化的情况，就是假设所有物体是一个点，这样比较容易理解。把每点放到正方形空间里，若该正方形含有超过一个点，就把该正方式分割，直至每个小正方形（叶节点）仅含有一个点，就可以得出以下的分割结果：</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051059254.jpg" alt="img"></p><h3 id="问题：当一个物体超出划分范围-正好在边界上："><a href="#问题：当一个物体超出划分范围-正好在边界上：" class="headerlink" title="问题：当一个物体超出划分范围/正好在边界上："></a>问题：当一个物体超出划分范围/正好在边界上：</h3><p>1.所有与物体相交的子节点都引用这个物体</p><p>2.令非叶子结点也能放置物体（小正方体装不下就用它的上一级较大的那个正方体来装）</p><p>第一种方法的范围比较精确，但如果物体的大小相差很大，大体积的物体便需要被大量小范围的叶节点引用，而且管理上也会很麻烦。第二种做法是较常用的方法。然而，第二种方法的范围可能非常大，例如物体刚好在场景的中心，即使是一个体积很小的物体，都只能放于根节点里。</p><h3 id="另一个问题在于动态更新。"><a href="#另一个问题在于动态更新。" class="headerlink" title="另一个问题在于动态更新。"></a>另一个问题在于动态更新。</h3><p>想想看，如果四叉树内的物体每帧位置都在变化，四叉树应该如何更新？每帧都重建四叉树？那肯定不行，太费时间了。 首先需要找对旧位置所在的节点 ，把节点里存的物体列表中删掉当前这个在移动的物体，删掉后还要考虑已经分裂的子四叉树是不是需要删除，然后对于新位置的处理，这个就比较好办，按照插入时的逻辑就可以了。</p><h3 id="解决：松散四-八叉树（稍微扩大正方体（包围盒））"><a href="#解决：松散四-八叉树（稍微扩大正方体（包围盒））" class="headerlink" title="解决：松散四/八叉树（稍微扩大正方体（包围盒））"></a>解决：松散四/八叉树（稍微扩大正方体（包围盒））</h3><p>松散八叉树的“松散”是指调整节点的包围体大小，“放松”包围立方体，但是同时节点的层次和节点的中心不变。在松散八叉树中，包围立方体边长的计算公式修改为：</p><p>松散四叉树/八叉树中，出口边界比入口边界要宽些（虽然各节点的出口边界也会发生部分重叠），从而使节点不容易越过出口边界，减少了物体切换节点的次数。</p><p>问题在于如何定义出口边界的长度。因为太短会退化成正常四叉树/八叉树，太长又可能会导致节点存储冗余的物体。经过前人的实验表明出口边界长度为入口边界2倍最佳。</p><p>当出口范围是入口范围2倍的时候，松散四叉树会多一个神奇的特性：<br>如果一个AABB大小小于一个四叉树节点的入口范围，那么只要这个AABB的中心点在入口范围内，那么这个AABB一定包含在出口范围内</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Nsb3VkZ3Jhc3NsYW5kLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNi8wOC8lRTYlOUQlQkUlRTYlOTUlQTMlRTUlODUlQUIlRTUlOEYlODklRTYlQTAlOTEucG5n?x-oss-process=image/format,png" alt="松散八叉树"></p><h3 id="松散四叉树结合网格法"><a href="#松散四叉树结合网格法" class="headerlink" title="松散四叉树结合网格法"></a>松散四叉树结合网格法</h3><p>我们都知道，当四叉树节点里的物体数量到达一个阈值时，我们会分裂四叉树，如果要支持动态更新，分裂后的四叉树可能还要删除。那么如果我们一上来就把四叉树全部分裂完呢？不管节点里有没有物体都不删除四叉树节点呢？这样的话这个四叉树就会跟网格很像。</p><p>有了松散四叉树配合网格法，我们能够快速找到一个物体应该插入的位置。<br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051134766.png" alt="在这里插入图片描述"></p><p>如图，我们把一个区域分成了三层的网格，图中黄色线代表第一层的网格，绿色线代表第二层的网格，白色线代表第三层的网格。我们可以发现，蓝色方块的大小大于第三层的网格（只有宽、高其中之一比网格大就算），小于第二层的网格，所以它最终应该放在第二层的四叉树上。</p><p>接着我们来看它的中心点的位置，我们使用的是2倍的松散四叉树，所以中心点在哪个节点，物体就在哪个节点。通过观察我们可以发现，蓝色方块的位置在第一层四叉树的左下节点，第二层四叉树的左上节点。</p><p>我们用一个2x2的2维数组来表示四叉树的四个子节点，用行和列表示索引，左下是[0,0]，左上[1,0]，右下是[0,1]，右上是[1,1]。蓝色方块的位置就是根节点的[0,0]子节点的[1,0]子节点。</p><p>发现没有，使用松散四叉树结合网格法，可以快速得出一个物体要插入的位置，从原来的O(logn)复杂度变成O(1)复杂度。（可能有人会疑惑为何原先是logn复杂度，因为传统四叉树的插入是一种二分查找算法。二分查找的复杂度就是logn。二分查找是两半取其一不断循环，四叉树插入是四半取其一不断循环，本质一样。）</p><h3 id="游戏地形生成"><a href="#游戏地形生成" class="headerlink" title="游戏地形生成"></a>游戏地形生成</h3><p><strong>噪声（Noise）</strong>实际上就是一个随机数生成器，当然，这是一种伪随机（现实世界中的真随机在计算机中不存在）。我们所看到的那些黑白噪声图，实际上是随机数映射到0和1之间产生的灰度图。随机本身就是不同，那为什么还需要不同的随机？</p><p>普通噪声（随机数生成器）的问题在于，它实在太过于随机，毫无规律可言（如图1所示）。（太突兀、嘈杂、刺眼）</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051432867.jpg" alt="img"></p><p><strong>柏林噪声</strong>：平滑的、均匀性的噪声、随机值一部分取决于周边元素</p><p><a href="https://zhuanlan.zhihu.com/p/206271895">https://zhuanlan.zhihu.com/p/206271895</a></p><p>柏林噪声基于随机，并在此基础上利用缓动曲线进行平滑插值，使得最终得到噪声效果更加趋于自然。基于不同的采样空间，柏林噪声可以分为一维、二维和三维。维度不同，但其基本原理是相同，都主要经过以下三个步骤：</p><ol><li>初始化相关数据，包括<strong>排列表（Permutation Table）</strong>和<strong>梯度表（Gradient Table）</strong>等。</li><li>建立采样空间。对于一维柏林噪声，采样空间为一个一维的坐标轴，轴上整数坐标位置均有一个点。而对应二维柏林噪声，采样空间为一个二维坐标系，坐标系中横纵坐标为整数的地方均有一点。三维柏林噪声同理。</li><li>对于不同类型的噪声，对采样点在不同空间中，根据最近的参考点的梯度和缓动曲线进行插值计算。</li></ol><ul><li><p>噪声细节函数</p><ul><li>多少层柏林噪声</li><li>这些柏林噪声怎么结合在一起</li></ul></li><li><p>same seed-&gt;same result</p></li><li><p>高度图：2D的只有高度的图用来表示3D</p></li><li><p>三角形网格</p></li><li><p>如果对整张图使用二维柏林噪声，那整张图的地形都差不多，如何形成又有山坡又有平原的地形？对地形再加一维柏林噪声。（甚至可以给湿度，温度加柏林噪声）</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化排列表和梯度表之前，我们先了解一下它们的作用。排列表是一个<strong>乱序</strong>存放一系列索引值的表，而梯度表是一个存放了一系列随机梯度值的表，两者都具有很强的随机性。在决定一个点的梯度时，需要结合哈希函数，以点的坐标为参数，利用所得的值作为索引，去排列表中取对应的值。所取得的排列表中的值，就是该点在梯度表中对应梯度值的索引。这样解释可能会有些让人摸不着头脑，我们来看一段伪代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排列表</span></span><br><span class="line"><span class="built_in">int</span>[] perm = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 梯度表</span></span><br><span class="line"><span class="built_in">float</span>[] grad = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有整数点才需要随机指定梯度，以计算非整数点的插值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hash</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span>[] gradient, <span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过哈希函数找到排列表的索引</span></span><br><span class="line">    <span class="built_in">int</span> permIdx[] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">    permIdx[<span class="number">0</span>] = FindIndex(x);</span><br><span class="line">    permIdx[<span class="number">1</span>] = FindIndex(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过排列表索引找到梯度表的索引</span></span><br><span class="line">    <span class="built_in">int</span> gradIdx[] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">    gradIdx[<span class="number">0</span>] = perm[permIdx[<span class="number">0</span>]];</span><br><span class="line">    gradIdx[<span class="number">1</span>] = perm[permIdx[<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在梯度表中找到梯度值</span></span><br><span class="line">    gradient[<span class="number">0</span>] = grad[gradIdx[<span class="number">0</span>]];</span><br><span class="line">    gradient[<span class="number">1</span>] = grad[gradIdx[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一维柏林噪声中，各个整点的梯度就是斜率，所以我们可以不依赖梯度表，将排列表中所取到值直接作为梯度即可。因为排列表中的值是乱序的，所以有良好的随机性，且对于同样的输入，它的输出都相同，伪随机性也得以保留。在***Ken Perlin***的经典噪声算法中，使用的排列表是由数字0到255散列组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Language: Processing</span></span><br><span class="line"><span class="comment">// Permutation table</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] perm = &#123;<span class="number">151</span>,<span class="number">160</span>,<span class="number">137</span>,<span class="number">91</span>,<span class="number">90</span>,<span class="number">15</span>,</span><br><span class="line"> <span class="number">131</span>,<span class="number">13</span>,<span class="number">201</span>,<span class="number">95</span>,<span class="number">96</span>,<span class="number">53</span>,<span class="number">194</span>,<span class="number">233</span>,<span class="number">7</span>,<span class="number">225</span>,<span class="number">140</span>,<span class="number">36</span>,<span class="number">103</span>,<span class="number">30</span>,<span class="number">69</span>,<span class="number">142</span>,<span class="number">8</span>,<span class="number">99</span>,<span class="number">37</span>,<span class="number">240</span>,<span class="number">21</span>,<span class="number">10</span>,<span class="number">23</span>,</span><br><span class="line"> <span class="number">190</span>, <span class="number">6</span>,<span class="number">148</span>,<span class="number">247</span>,<span class="number">120</span>,<span class="number">234</span>,<span class="number">75</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">197</span>,<span class="number">62</span>,<span class="number">94</span>,<span class="number">252</span>,<span class="number">219</span>,<span class="number">203</span>,<span class="number">117</span>,<span class="number">35</span>,<span class="number">11</span>,<span class="number">32</span>,<span class="number">57</span>,<span class="number">177</span>,<span class="number">33</span>,</span><br><span class="line"> <span class="number">88</span>,<span class="number">237</span>,<span class="number">149</span>,<span class="number">56</span>,<span class="number">87</span>,<span class="number">174</span>,<span class="number">20</span>,<span class="number">125</span>,<span class="number">136</span>,<span class="number">171</span>,<span class="number">168</span>, <span class="number">68</span>,<span class="number">175</span>,<span class="number">74</span>,<span class="number">165</span>,<span class="number">71</span>,<span class="number">134</span>,<span class="number">139</span>,<span class="number">48</span>,<span class="number">27</span>,<span class="number">166</span>,</span><br><span class="line"> <span class="number">77</span>,<span class="number">146</span>,<span class="number">158</span>,<span class="number">231</span>,<span class="number">83</span>,<span class="number">111</span>,<span class="number">229</span>,<span class="number">122</span>,<span class="number">60</span>,<span class="number">211</span>,<span class="number">133</span>,<span class="number">230</span>,<span class="number">220</span>,<span class="number">105</span>,<span class="number">92</span>,<span class="number">41</span>,<span class="number">55</span>,<span class="number">46</span>,<span class="number">245</span>,<span class="number">40</span>,<span class="number">244</span>,</span><br><span class="line"> <span class="number">102</span>,<span class="number">143</span>,<span class="number">54</span>, <span class="number">65</span>,<span class="number">25</span>,<span class="number">63</span>,<span class="number">161</span>, <span class="number">1</span>,<span class="number">216</span>,<span class="number">80</span>,<span class="number">73</span>,<span class="number">209</span>,<span class="number">76</span>,<span class="number">132</span>,<span class="number">187</span>,<span class="number">208</span>, <span class="number">89</span>,<span class="number">18</span>,<span class="number">169</span>,<span class="number">200</span>,<span class="number">196</span>,</span><br><span class="line"> <span class="number">135</span>,<span class="number">130</span>,<span class="number">116</span>,<span class="number">188</span>,<span class="number">159</span>,<span class="number">86</span>,<span class="number">164</span>,<span class="number">100</span>,<span class="number">109</span>,<span class="number">198</span>,<span class="number">173</span>,<span class="number">186</span>, <span class="number">3</span>,<span class="number">64</span>,<span class="number">52</span>,<span class="number">217</span>,<span class="number">226</span>,<span class="number">250</span>,<span class="number">124</span>,<span class="number">123</span>,</span><br><span class="line"> <span class="number">5</span>,<span class="number">202</span>,<span class="number">38</span>,<span class="number">147</span>,<span class="number">118</span>,<span class="number">126</span>,<span class="number">255</span>,<span class="number">82</span>,<span class="number">85</span>,<span class="number">212</span>,<span class="number">207</span>,<span class="number">206</span>,<span class="number">59</span>,<span class="number">227</span>,<span class="number">47</span>,<span class="number">16</span>,<span class="number">58</span>,<span class="number">17</span>,<span class="number">182</span>,<span class="number">189</span>,<span class="number">28</span>,<span class="number">42</span>,</span><br><span class="line"> <span class="number">223</span>,<span class="number">183</span>,<span class="number">170</span>,<span class="number">213</span>,<span class="number">119</span>,<span class="number">248</span>,<span class="number">152</span>, <span class="number">2</span>,<span class="number">44</span>,<span class="number">154</span>,<span class="number">163</span>, <span class="number">70</span>,<span class="number">221</span>,<span class="number">153</span>,<span class="number">101</span>,<span class="number">155</span>,<span class="number">167</span>, <span class="number">43</span>,<span class="number">172</span>,<span class="number">9</span>,</span><br><span class="line"> <span class="number">129</span>,<span class="number">22</span>,<span class="number">39</span>,<span class="number">253</span>, <span class="number">19</span>,<span class="number">98</span>,<span class="number">108</span>,<span class="number">110</span>,<span class="number">79</span>,<span class="number">113</span>,<span class="number">224</span>,<span class="number">232</span>,<span class="number">178</span>,<span class="number">185</span>, <span class="number">112</span>,<span class="number">104</span>,<span class="number">218</span>,<span class="number">246</span>,<span class="number">97</span>,<span class="number">228</span>,</span><br><span class="line"> <span class="number">251</span>,<span class="number">34</span>,<span class="number">242</span>,<span class="number">193</span>,<span class="number">238</span>,<span class="number">210</span>,<span class="number">144</span>,<span class="number">12</span>,<span class="number">191</span>,<span class="number">179</span>,<span class="number">162</span>,<span class="number">241</span>, <span class="number">81</span>,<span class="number">51</span>,<span class="number">145</span>,<span class="number">235</span>,<span class="number">249</span>,<span class="number">14</span>,<span class="number">239</span>,<span class="number">107</span>,</span><br><span class="line"> <span class="number">49</span>,<span class="number">192</span>,<span class="number">214</span>, <span class="number">31</span>,<span class="number">181</span>,<span class="number">199</span>,<span class="number">106</span>,<span class="number">157</span>,<span class="number">184</span>, <span class="number">84</span>,<span class="number">204</span>,<span class="number">176</span>,<span class="number">115</span>,<span class="number">121</span>,<span class="number">50</span>,<span class="number">45</span>,<span class="number">127</span>, <span class="number">4</span>,<span class="number">150</span>,<span class="number">254</span>,</span><br><span class="line"> <span class="number">138</span>,<span class="number">236</span>,<span class="number">205</span>,<span class="number">93</span>,<span class="number">222</span>,<span class="number">114</span>,<span class="number">67</span>,<span class="number">29</span>,<span class="number">24</span>,<span class="number">72</span>,<span class="number">243</span>,<span class="number">141</span>,<span class="number">128</span>,<span class="number">195</span>,<span class="number">78</span>,<span class="number">66</span>,<span class="number">215</span>,<span class="number">61</span>,<span class="number">156</span>,<span class="number">180</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20231108150014134.png" alt="image-20231108150014134"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051516000.png" alt="image-20220405151507917"></p><p>柏林噪声的生成算法其实并没有那么难，主要经历以下三个步骤：</p><ol><li>对排列表和梯度表进行初始化，梯度表可以不必随机生成，选择单位圆（球）上的对称的梯度向量也可。一维向量可以不用梯度表，直接用排列表中的值进行映射也能达到效果。</li><li>对于噪声图上的像素，找到它在晶格上对应的一点，并求出它的参考点的坐标。在一维情况下，参考点为两侧最近的整数点；二维情况下，参考点为组成包围该点的单位正方体的四个点；三维情况下，参考点为组成包围该点的单位立方体的八个点。需要注意的一点是，晶格必须与图片对齐且完全覆盖，否则坐标映射会很麻烦。</li><li>根据参考点的方向向量和梯度向量，并结合缓动曲线，求解最终的灰度值。一维噪声只需一次插值，二维需要三次插值，三维需要七次插值，呈指数增长，所以算法的时间复杂度是 $O(2^n)$</li></ol><p>不是存储世界，而是存储建造世界的方式 </p><h4 id="Minecraft生成"><a href="#Minecraft生成" class="headerlink" title="Minecraft生成"></a>Minecraft生成</h4><p>individual chunk：16x16x256</p><p>indvidual chunk整合在一起-&gt;the whole world</p><p>一开始生成的：spawn chunk</p><h4 id="生成一个chunk的步骤"><a href="#生成一个chunk的步骤" class="headerlink" title="生成一个chunk的步骤"></a>生成一个chunk的步骤</h4><p>1.生成高度图（height map generation）仅由石头 水 和空气构成</p><p>2.矿物层(ore stage)</p><p>3.表层被替换成泥土或者沙</p><p>3.雕刻层，山洞  cave ravines canyons</p><p>4.生成结构（树，村庄）还有生物</p><h4 id="chunk是怎么连接成为一个顺滑的世界的？"><a href="#chunk是怎么连接成为一个顺滑的世界的？" class="headerlink" title="chunk是怎么连接成为一个顺滑的世界的？"></a>chunk是怎么连接成为一个顺滑的世界的？</h4><p>约40层噪声实现：不同生物群落以及在什么地形下该生成怎样的雕刻层，表层 </p><p>每一个世界都是从整片海洋开始的</p><p>每一个群落都有一个编号，而海洋是0</p><p>第一层噪音层是海洋 </p><p>不同的噪声层叠加，陆地面积越来越多</p><p>每个群落都有一个温度值，温度值随着海拔升高会降低</p><p>温度取决于生物群落</p><p> 温度相近的生物群落常常聚集在一起</p><p>边缘层</p><p>气候过渡</p><p>有一层是专门用来生成蘑菇岛的</p><p>生物群落变种</p><p>河流</p><p>海岸线</p><h2 id="chunk的加载"><a href="#chunk的加载" class="headerlink" title="chunk的加载"></a>chunk的加载</h2><p>每个区块的加载都来源于一个“加载标签”。</p><p>每个加载标签具有3个属性：加载等级，标签类型和存活时间（可选属性）。</p><h4 id="加载等级"><a href="#加载等级" class="headerlink" title="加载等级"></a>加载等级</h4><p><strong>加载等级</strong>用于决定了这个区块中哪些游戏内容能够被运算。</p><p>加载等级的范围是0-45。只会在0-33的范围里有常规的游戏运算。加载等级45以上是不可能的。</p><p>一个区块如果获得多个加载等级，只有最小的加载等级是有效的。加载等级越小，游戏会运算更多内容。</p><p>加载等级可以分为以下有四种加载等级类型：</p><table><thead><tr><th>类型</th><th>等级</th><th>属性</th></tr></thead><tbody><tr><td>强加载</td><td>31及以下</td><td>所有游戏内容都能够被运算。</td></tr><tr><td>弱加载</td><td>32</td><td>除了区块<a href="https://minecraft.fandom.com/zh/wiki/%E5%88%BB">刻</a>以及实体不会运算（例如不会移动），所有的游戏内容都正常运行。</td></tr><tr><td>加载边界</td><td>33</td><td>只有少部分游戏内容会正常运行（红石元件和命令方块等都不能运行）。</td></tr><tr><td>不可访问</td><td>34及以上</td><td>各种游戏内容都不会运算，但<a href="https://minecraft.fandom.com/zh/wiki/%E4%B8%96%E7%95%8C%E7%94%9F%E6%88%90">世界生成</a>会在这些区块中运行。</td></tr></tbody></table><h4 id="等级传播"><a href="#等级传播" class="headerlink" title="等级传播"></a>等级传播</h4><p>带有加载标签的区块，会相邻（8个）的区块传播加载等级。对于每张“标签”使用“flood fills”算法从“标签”的位置传播，每向外传播一次就加载等级增加1，直到达到上限45。</p><table><thead><tr><th>34</th><th>34</th><th>34</th><th>34</th><th>34</th><th>34</th><th>34</th></tr></thead><tbody><tr><td>34</td><td>33</td><td>33</td><td>33</td><td>33</td><td>33</td><td>34</td></tr><tr><td>34</td><td>33</td><td>32</td><td>32</td><td>32</td><td>33</td><td>34</td></tr><tr><td>34</td><td>33</td><td>32</td><td>31</td><td>32</td><td>33</td><td>34</td></tr><tr><td>34</td><td>33</td><td>32</td><td>32</td><td>32</td><td>33</td><td>34</td></tr><tr><td>34</td><td>33</td><td>33</td><td>33</td><td>33</td><td>33</td><td>34</td></tr><tr><td>34</td><td>34</td><td>34</td><td>34</td><td>34</td><td>34</td><td>34</td></tr></tbody></table><table><thead><tr><th>IN</th><th>IN</th><th>IN</th><th>IN</th><th>IN</th><th>IN</th><th>IN</th></tr></thead><tbody><tr><td>IN</td><td>BO</td><td>BO</td><td>BO</td><td>BO</td><td>BO</td><td>IN</td></tr><tr><td>IN</td><td>BO</td><td>TI</td><td>TI</td><td>TI</td><td>BO</td><td>IN</td></tr><tr><td>IN</td><td>BO</td><td>TI</td><td>ET</td><td>TI</td><td>BO</td><td>IN</td></tr><tr><td>IN</td><td>BO</td><td>TI</td><td>TI</td><td>TI</td><td>BO</td><td>IN</td></tr><tr><td>IN</td><td>BO</td><td>BO</td><td>BO</td><td>BO</td><td>BO</td><td>IN</td></tr><tr><td>IN</td><td>IN</td><td>IN</td><td>IN</td><td>IN</td><td>IN</td><td>IN</td></tr></tbody></table><h4 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h4><p>不同来源的标签有不同的类型，用于确定不同加载等级。</p><h5 id="玩家"><a href="#玩家" class="headerlink" title="玩家"></a>玩家</h5><p>由<a href="https://minecraft.fandom.com/zh/wiki/%E7%8E%A9%E5%AE%B6">玩家</a>加载的标签。“玩家”标签的加载等级为31。玩家的加载范围内的区块都会获得“玩家”标签。</p><p>玩家的模拟距离会生成模拟标签，模拟标签与玩家标签不同，独立计算。</p><h2 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h2><p>估价函数可以贪心的搜索更像答案的状态，减少搜索的状态数</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051921843.png" alt="image-20220405174823540"></p><p>启发函数h(n)的选取</p><p>1.曼哈顿距离（城市街区距离）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D*(Math.<span class="built_in">abs</span>(startX-endsX)+Math.<span class="built_in">abs</span>(startY-endsY));</span><br></pre></td></tr></table></figure><p>D为每走一步需要消耗的代价。</p><p>如果是只能四个方向走的时候，此时应该是较好的一种方案。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051803627.png" alt="image-20220405180327453"></p><p>2.欧几里得距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=Math.<span class="built_in">abs</span>(startX-endsX);</span><br><span class="line">var b=Math.<span class="built_in">abs</span>(startY-endsY);</span><br><span class="line"><span class="keyword">return</span> D*Math.<span class="built_in">sqrt</span>((a*a+b*b));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051803906.png" alt="image-20220405180335845"></p><p>3.平方后的欧几里得距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=Math.<span class="built_in">abs</span>(startX-endsX);</span><br><span class="line">var b=Math.<span class="built_in">abs</span>(startY-endsY);</span><br><span class="line"><span class="keyword">return</span> D*(a*a+b*b);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051803089.png" alt="image-20220405180348018"></p><p>4.对角线距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D*Math.<span class="built_in">max</span>(Math.<span class="built_in">abs</span>(startX-endsX),Math.<span class="built_in">abs</span>(startY-endsY));</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204051803944.png" alt="image-20220405180352851"></p><h2 id="帧同步与状态同步"><a href="#帧同步与状态同步" class="headerlink" title="帧同步与状态同步"></a>帧同步与状态同步</h2><p>一、同步</p><p>所谓同步，就是要多个客户端表现效果是一致的，例如我们玩王者荣耀的时候，需要十个玩家的屏幕显示的英雄位置完全相同、技能释放角度、释放时间完全相同，这个就是同步。就好像很多个人一起跳街舞齐舞，每个人的动作都要保持一致。而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。</p><p>二、状态同步和帧同步的区别</p><p>最大的区别就是战斗核心逻辑写在哪，状态同步的战斗逻辑在服务端，帧同步的战斗逻辑在客户端。战斗逻辑是包括技能逻辑、普攻、属性、伤害、移动、AI、检测、碰撞等等的一系列内容，这常常也被视为游戏开发过程中最难的部分。由于核心逻辑必须知道一个场景中的所有实体情况，所以MMO游戏（例如魔兽世界）就必须把战斗逻辑写在服务端，所以MMO游戏必须是状态同步的，因为MMO游戏的客户端承载有限，并不能把整张地图的实体全部展现出来（例如100米以外的NPC和玩家就不显示了），所以客户端没有足够的信息计算全图的人的所有行为。</p><p>具体到客户端和服务端通信上，在状态同步下，客户端更像是一个服务端数据的表现层，举个例子，一个英雄的几乎所有属性（例如血量、攻击、防御、攻速、魔法值等等）都是服务端传给客户端的，而且在属性发生改变的时候，服务端需要实时告诉客户端哪些属性改变了，客户端并不能改变这些属性，而是服务端传来多少属性就显示多少属性（虽然可以改变客户端数值达到表现上的效果，例如无限血量，但是服务端那边的血量属性为0时，一样要死）。再举个例子，一个英雄要释放一个非指向性技能（例如伊泽瑞尔的Q），具体的过程就是，客户端通知服务端“我要释放一个技能”-》服务端通知客户端“在某地以什么方向释放某技能”-》客户端根据这些信息创建一个特效放在某地，然后以某个方向飞行-》服务端根据碰撞检测逻辑判断到某个时刻，这个技能碰到了敌方英雄，通知客户端-》客户端根据服务端信息，删除特效，被打的英雄减血同时播放受击特效。</p><p>而在帧同步下，通信就比较简单了，服务端只转发操作，不做任何逻辑处理。以下图为例：</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205140104571.jpg" alt="img"></p><p>现在同一局里有4个玩家，也就是4个客户端，这时客户端A释放了一个技能x，此时将操作传递给服务端，服务端不做任何判断，直接把A的操作全部分发给ABCD，则ABCD同时让客户端A控制的英雄释放技能x。</p><p>三、流量</p><p>状态同步比帧同步流量消耗大，例如一个复杂游戏的英雄属性可能有100多条，每次改变都要同步一次属性，这个消耗是巨大的，而帧同步不需要同步属性；例如释放一个技能，服务端需要通知客户端很多条消息（必须是分步的，不然功能做不了），而帧同步就只需要转发一次操作就行了。</p><p>四、回放&amp;观战</p><p>帧同步的回放&amp;观战比状态同步好做得多，因为只需要保存每局所有人的操作就好了，而状态同步的回放&amp;观战，需要有一个回放&amp;观战服务器，当一局战斗打响，战斗服务器在给客户端发送消息的同时，还需要把这些消息发给放&amp;观战服务器，回放&amp;观战服务器做储存，如果有其他客户端请求回放或者观战，则回放&amp;观战服务器把储存起来的消息按时间发给客户端。</p><p>五、安全性</p><p>状态同步的安全性比帧同步高很多，因为状态同步的所有逻辑和数值都是在服务端的，如果想作弊，就必须攻击服务器，而攻击服务器的难度比更改自己客户端数据的难度高得多，而且更容易被追踪，被追踪到了还会有极高的法律风险。而帧同步因为所有数据全部在客户端，所以解析客户端的数据之后，就可以轻松达到自己想要的效果，例如moba类游戏的全图挂，吃鸡游戏的透视挂，都是没办法防止的，而更改数据达到胜利的作弊方式（例如更改自己的英雄攻击力）可以通过服务器比对同局其他人的战斗结果来预防。</p><p>六、服务器压力</p><p>状态同步服务器压力比较大，因为要做更多运算。</p><p>七、开发效率</p><p>首先要说，状态同步的游戏占主流，其次就是状态同步开发起来比较难。而帧同步服务器开发难度低，同一套方案可以给很多不同类型的游戏使用，反正都是转发操作；减少了服务端客户端沟通，老实说，没有扯皮的时间，开发效率最起码提高20%，状态同步的方案下，同一个功能至少需要一个客户端和服务端共同完成；PVP和PVE基本用的是同一套代码，做完PVP很容易就可以做单机的PVE。</p><p>八、使用帧同步的知名游戏</p><p>王者荣耀、魔兽争霸3、所有格斗类游戏</p><p>九、断线重连</p><p>状态同步的断线重连很好做，无非就是把整个场景和人物全部重新生成一遍，各种数值根据服务端提供加到人物身上而已。帧同步的断线重连就比较麻烦了，例如客户端在战场开始的第10秒短线了，第15秒连回来了，就需要服务端把第10秒到第15秒之间5秒内的所有消息一次性发给客户端，然后客户端加速整个游戏的核心逻辑运行速度（例如加速成10倍），直到追上现有进度。</p><p>帧同步：</p><ul><li>客户端按照一定的帧速率（理解为逻辑帧，而不是客户端的渲染帧）去上传当前的<strong>操作指令</strong>，服务端将操作指令广播给所有客户端，当客户端收到指令后执行本地代码。</li></ul><p>状态同步：</p><ul><li>客户端给服务端直接传递数据和属性，由服务端进行计算。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++知识点</title>
      <link href="/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="C-编译的过程"><a href="#C-编译的过程" class="headerlink" title="C++编译的过程"></a>C++编译的过程</h2><p>.c文件</p><p>1.预处理(Preprocessing),</p><ul><li>展开所有的宏定义，消除“#define”；</li><li>处理所有的预编译指令，比如#if、#ifdef等；</li><li>处理#include预编译指令，将包含文件插入到该预编译的位置；</li><li>删除所有的注释“/**/”、”//“等；</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒；</li><li>保留所有的#program编译指令，原因是编译器要使用它们；</li></ul><p>–&gt; .i文件</p><p>2.编译(Compilation),</p><ul><li>编译过程就是把经过预编译生成的文件进行一系列语法分析、词法分析、语义分析优化后生成相应的汇编代码文件。</li></ul><p>–&gt; .s文件</p><p>3.汇编(Assemble)</p><ul><li><p>将对应的汇编指令翻译成机器指令</p></li><li><p>生成可重定位的二进制文件</p></li></ul><p>–&gt;.o文件</p><p>4.链接(Linking)。</p><ul><li>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。</li></ul><p>例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。</p><p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><ul><li>链接阶段是把源程序转换成的目标代码（obj文件）与你程序里面调用的库函数对应的代码连接起来形成对应的可执行文件（exe文件）</li></ul><p>链接分为两种：</p><ul><li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><p>二者的优缺点：</p><ul><li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失</li></ul><p><a href="https://blog.csdn.net/kang___xi/article/details/80210717">https://blog.csdn.net/kang___xi/article/details/80210717</a></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><h4 id="const-的指针与引用"><a href="#const-的指针与引用" class="headerlink" title="const 的指针与引用"></a>const 的指针与引用</h4><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li></ul></li></ul><blockquote><p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 <code>p2</code>、<code>p3</code></p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>const 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;                <span class="comment">// 常对象成员，可以使用初始化列表或者类内初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值 但是可以修改别的域的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="type">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="type">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="type">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针指向不可改变）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>&#123;<span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line">  Var++;<span class="comment">//错误</span></span><br><span class="line">&#125;           </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>*p;</span><br><span class="line">    p= &amp;a;</span><br><span class="line">    (*p)++;<span class="comment">//错误,定义一个常量指针后，指针指向的值就不能被改变，即不能通过指针变量直接更改指针指向的值</span></span><br><span class="line">    p=&amp;b;<span class="comment">//正确，指向可以改变</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p2=&amp;a;</span><br><span class="line">    p2=b;<span class="comment">//错误,定义一个指针常量后，指针的指向就不能被改变</span></span><br><span class="line">    (*p2)++;<span class="comment">//正确,指向的值仍可修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203311100564.jpg" alt="1561648695629_.pic"></p><h4 id="const的实现机制"><a href="#const的实现机制" class="headerlink" title="const的实现机制"></a>const的实现机制</h4><p>const在C语言中表示只读的变量，而在C++中表示一个常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;var); </span><br><span class="line">*ptr = <span class="number">20</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;var=%d *ptr=%d \n&quot;</span>,var,*ptr); </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=20 *ptr=20</span><br></pre></td></tr></table></figure><p>C++语言中，const被看做常量，编译器使用常数直接替换掉被const修饰的标识符的引用，并不会通过访问内存去读取数据，这一点类似C语言中的宏#define。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> var = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span> *ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(&amp;var); </span><br><span class="line">*ptr = <span class="number">20</span>; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;var=&quot;</span>&lt;&lt;var&lt;&lt;<span class="string">&quot; *ptr=&quot;</span>&lt;&lt;*ptr&lt;&lt;endl; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=10 *ptr=20</span><br></pre></td></tr></table></figure><p>此外，C++语言中，只是对于内置数据类型做常数替换，而对于像结构体这样的非内置数据类型则不会。因为结构体类型不是内置数据类型，编译器不知道如何直接替换，因此必须要访问内存去取数据，而访问内存去取数据必然会取到被指针q改变后的值，因此会造成与C++中const内置类型完全不一样的处理模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="built_in">test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        var = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> test testobj;</span><br><span class="line">    <span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;testobj.var);</span><br><span class="line">    *ptr = <span class="number">40</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;var=&quot;</span>&lt;&lt;testobj.var&lt;&lt;<span class="string">&quot; *ptr=&quot;</span>&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=40 *ptr=40</span><br></pre></td></tr></table></figure><p>这是因为对于非内置数据类型，编译器不知道如何直接替换，所以对于var取值仍是通过读取它的存储空间中的值来获得。</p><p>总结一下，就是：const在C语言中表示只读的变量，而在C++中对于内置类型表示一个常量，对于非内置类型表示只读的变量。</p><h4 id="宏定义-define-和-typedef"><a href="#宏定义-define-和-typedef" class="headerlink" title="宏定义 #define 和 typedef"></a>宏定义 #define 和 typedef</h4><table><thead><tr><th>宏定义 #define</th><th>typedef</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>定义类型的别名</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr><tr><td>没有作用域的限制</td><td>有自己的作用域</td></tr></tbody></table><ul><li><p>宏可能产生<strong>边界效应</strong></p><p>#define MIN(a, b) a &gt; b ? b : a</p><p>这句宏定义就会带来意想不到的问题，比如我在这样使用时：</p><p>num = c + MIN(num1, num2);</p><p>-&gt;num = c + a &gt; b ? b : a</p><p>正确应该为：</p><p>#define MIN(a, b) (a &gt; b ? b : a)</p></li></ul><p><a href="https://www.cnblogs.com/pam-sh/p/15232940.html">https://www.cnblogs.com/pam-sh/p/15232940.html</a></p><h2 id="构造函数的执行顺序？析构函数的执行顺序？"><a href="#构造函数的执行顺序？析构函数的执行顺序？" class="headerlink" title="构造函数的执行顺序？析构函数的执行顺序？"></a>构造函数的执行顺序？析构函数的执行顺序？</h2><h4 id="虚基类-基类-派生类"><a href="#虚基类-基类-派生类" class="headerlink" title="虚基类 基类 派生类"></a>虚基类 基类 派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shit</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Shit! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Shit</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Shit! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Person! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Person! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Student! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Student! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Student,<span class="keyword">public</span> Shit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Teacher! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Teacher</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Teacher! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Shit!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将<code>class Teacher : public Student,public Shit</code>变为<code>class Teacher : public Shit,public Student</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Shit!</span><br><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>==不会管谁继承得更深，如果没有虚基类的情况下按顺序构造和析构==。</li></ul><p>将<code>class Teacher : public Shit,public Student</code>变为<code>class Teacher :public Student, public Virtual Shit</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Shit!</span><br><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>==输出结果不变，说明优先构造虚基类==</p><h4 id="在一个类中创建另一个类的实例"><a href="#在一个类中创建另一个类的实例" class="headerlink" title="在一个类中创建另一个类的实例"></a>在一个类中创建另一个类的实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor A</span><br><span class="line">constructor B</span><br><span class="line">destructor B</span><br><span class="line">destructor A</span><br></pre></td></tr></table></figure><h4 id="在一个类中创建另一个类的实例-并且有基类的情况"><a href="#在一个类中创建另一个类的实例-并且有基类的情况" class="headerlink" title="在一个类中创建另一个类的实例 并且有基类的情况"></a>在一个类中创建另一个类的实例 并且有基类的情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FB</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FB</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor FB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FB</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor FB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :FB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor FB</span><br><span class="line">constructor A</span><br><span class="line">constructor B</span><br><span class="line">destructor B</span><br><span class="line">destructor A</span><br><span class="line">destructor FB</span><br></pre></td></tr></table></figure><p>基类构造函数 &gt; 成员构造函数 &gt; 自身构造函数</p><h2 id="构造函数的扩展过程？"><a href="#构造函数的扩展过程？" class="headerlink" title="构造函数的扩展过程？"></a>构造函数的扩展过程？</h2><p>记录在成员初始化列表中的<strong>数据成员的初始化</strong>操作会被放进该类的构造函数中，并以成员的声明顺序为顺序</p><p><strong>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</strong></p><p>在那之前，如果 class 有虚指针，那么它必须被设定初值，指向适当的虚表；</p><p>在那之前，所有上一层的基类构造函数必须被调用；</p><p>在那之前，所有虚基类的构造函数必须被调用。</p><h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><p><strong>成员初始化列表只能在构造函数中使用。</strong></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>更高效：少了一次调用默认构造函数的过程。</li></ul><h4 id="没有成员初始化列表的情况"><a href="#没有成员初始化列表的情况" class="headerlink" title="没有成员初始化列表的情况"></a>没有成员初始化列表的情况</h4><p>假设一个类<code>ClassA</code>有一个类型为<code>Type</code>的成员变量<code>member</code>。如果在构造函数体内对<code>member</code>进行初始化，过程如下：</p><ol><li>当创建<code>ClassA</code>的对象时，C++首先为所有成员变量调用<strong>默认构造函数</strong>（如果有的话）。这是在进入构造函数体之前自动发生的。 <ul><li>默认构造函数指不需要任何参数即可调用的构造函数<ul><li><strong>显式定义的无参数构造函数</strong>：开发者在类中显式定义了一个不接受任何参数的构造函数</li><li><strong>隐式定义的构造函数</strong>：如果你没有为类定义任何构造函数，C++编译器会自动生成一个默认构造函数，这个构造函数不执行任何操作。</li></ul></li></ul></li><li>然后执行构造函数体内的代码。如果此时对<code>member</code>进行了赋值或调用了其非默认构造函数进行初始化，实际上是在对已经默认构造的对象进行赋值操作，这可能导致了一次不必要的构造和随后的赋值操作。</li></ol><h4 id="使用成员初始化列表的情况"><a href="#使用成员初始化列表的情况" class="headerlink" title="使用成员初始化列表的情况"></a>使用成员初始化列表的情况</h4><p>当使用成员初始化列表时，初始化的过程变得更直接：</p><ol><li>使用成员初始化列表可以避免调用默认构造函数后再进行赋值的额外开销，直接调用成员的非默认构造函数</li><li>这意味着每个成员变量只被构造一次，并且是以最终需要的值进行构造，避免了不必要的默认构造和随后的赋值操作。</li></ol><h3 id="有些场合必须要用初始化列表："><a href="#有些场合必须要用初始化列表：" class="headerlink" title="有些场合必须要用初始化列表："></a>有些场合必须要用初始化列表：</h3><ol><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ol><p>派生类构造函数可以使用初始化器列表机制将位传递给基类构造函数。请看下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">derived: :<span class="built_in">derived</span> (type1 X, type2 y) <span class="built_in">base</span> (x , y) <span class="comment">// init ializer list</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中derived 是派生类， base 是基类， x 和y 是基类构造函数使用的变量。例如，如果派生类构造函数接收到参数10 和12 ，则这种机制将把10 和12 传递给被定义为接受这些类型的参数的基类构造函数。除虚基类外(参见第14 章)，类只能将值传递回相邻的基类，但后者可以使用相同的机制将信息传递给相邻的基类，依此类推。如采没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。</p><ul><li><strong>成员初始化列表只能用于构造函数。</strong></li></ul><h2 id="什么情况下会调用拷贝构造函数-三种情况"><a href="#什么情况下会调用拷贝构造函数-三种情况" class="headerlink" title="什么情况下会调用拷贝构造函数(三种情况)"></a>什么情况下会调用拷贝构造函数(三种情况)</h2><p>类的对象需要拷贝时，拷贝构造函数将会被调用，以下的情况都会调用拷贝构造函数： </p><ul><li>一个对象以<strong>值传递</strong>的方式<strong>传入函数体</strong>，需要拷贝构造函数创建一个临时对象压入到栈空间中。 </li><li>一个对象以<strong>值传递</strong>的方式<strong>从函数返回</strong>，需要执行拷贝构造函数创建一个临时对象作为返回值。 </li><li>一个对象需要通过另外一个对象进行初始化。</li></ul><h2 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h2><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 ==main 函数运行前就分配了空间==，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，==仅在定义该函数的文件内才能使用==。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使==所有的对象只保存一个该变量==，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 ==static 函数内不能访问非静态成员==。</li></ol><ul><li>const和static不能同时修饰一个成员函数，因为C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</li></ul><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ol><li><code>this</code> 指针是一个隐含于每一个==非静态成员函数==中的特殊指针。它==指向调用该成员函数的那个对象==。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象进行修改（即不能对这种对象的数据成员进行赋值操作）；</li><li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li><li>在以下场景中，经常需要显式引用 <code>this</code>指针：<ol><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 <code>list</code>。</li></ol></li></ol><h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>==在<strong>类声明中</strong>定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数==。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure><ul><li>如下风格的函数 Foo 不能成为内联函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;   <span class="comment">// inline 仅与函数声明放在一起  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>而如下风格的函数 Foo 则成为内联函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>   <span class="comment">// inline 与函数定义体放在一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li><strong>代码膨胀</strong>。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li><strong>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</strong></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p><p>面向对象三大特征 —— 封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p><ul><li><code>public</code> 成员：可以被任意实体访问</li><li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li><li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a><a href="http://c.biancheng.net/view/169.html">友元函数</a></h4><ul><li>在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。</li></ul><p><strong>1、为什么要引入友元函数：</strong>在实现类之间数据共享时，减少系统开销，提高效率</p><p>c++利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置成public，最大限度的保护数据成员的安全。</p><p>具体来说：为了使其他类的成员函数直接访问该类的私有变量</p><p>即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数（<strong>友元函数不是类的成员函数，是普通函数</strong>）</p><ul><li><p>优点：能够提高效率，表达简单、清晰</p></li><li><p>缺点：友元函数破环了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。</p></li></ul><p><strong>2、什么时候使用友元函数：</strong></p><p>   1)运算符重载的某些场合需要使用友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设重载了*</span><br><span class="line">A a1,a2,a3;</span><br><span class="line">a1=a2*a3;<span class="comment">//等价于a1=operator*(a2,a3) 相当于operator在外部访问了a2和a3的私有变量</span></span><br></pre></td></tr></table></figure><p>  对于结构体来说，如果要把重载运算符写在结构体内也需要使用friend，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果把friend删掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//friend bool operator &lt;(const node&amp; a,const node&amp; b)&#123;</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会报如下错误:<code>Overloaded &#39;operator&lt;&#39; must be a binary operator (has 3 parameters)</code> ，意思是这个重载运算符的函数有三个参数，而重载运算符只能一目或二目。</p><p>不加friend时，这个函数相当于成员函数，当一个结构体的成员函数被调用时，和类一样，也会自动向这个成员函数传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针(this)，所以会说传入了三个参数。但加了friend后，该函数就变成了一个普通函数，但是拥有访问结构体/类的私有参数的权利。但结构体中的参数默认是公有的，所以也可以直接将重载定义在结构体外面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但如果参数是私有的，就不行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//&#x27;price&#x27; is a private member of &#x27;node&#x27;</span></span><br></pre></td></tr></table></figure><p>2)两个类要共享数据的时候</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span>  <span class="title class_">boy</span>;   <span class="comment">//声明类boy是类girl的友元</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">girl</span>(<span class="type">char</span> *n,<span class="type">int</span> age):<span class="built_in">name</span>(n),<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boy</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">boy</span>(<span class="type">char</span> *n,<span class="type">int</span> age):<span class="built_in">name</span>(n),<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(girl &amp;x)</span></span>;   </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span>       <span class="comment">//  该函数必须在girl类定义的后面定义，否则girl类中的私有变量还是未知的    </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl; </span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">boy <span class="title">b</span><span class="params">(<span class="string">&quot;aaa&quot;</span>,<span class="number">8</span>)</span></span>;  </span><br><span class="line">    <span class="function">girl <span class="title">g</span><span class="params">(<span class="string">&quot;bbb&quot;</span>,<span class="number">99</span>)</span></span>;  </span><br><span class="line">    b.<span class="built_in">disp</span>(g); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boy&#x27;s name is:aaa,age:8</span><br><span class="line">girl&#x27;s name is:bbb,age:99</span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><ul><li>一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 </p><h2 id="C-中函数重载、隐藏、覆盖和重写的区别"><a href="#C-中函数重载、隐藏、覆盖和重写的区别" class="headerlink" title="C++中函数重载、隐藏、覆盖和重写的区别"></a>C++中函数重载、隐藏、覆盖和重写的区别</h2><h3 id="1-函数重载（Function-Overload）"><a href="#1-函数重载（Function-Overload）" class="headerlink" title="1.函数重载（Function Overload）"></a>1.函数重载（Function Overload）</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><p>C++规定在==同一作用域中==，同名函数的形式参数（指参数的个数、类型或者顺序）不同时，构成函数重载。</p><h4 id="1-2用法"><a href="#1-2用法" class="headerlink" title="1.2用法"></a>1.2用法</h4><p>比如，要从两个变量中返回其中较大的一个值，可以编写如下两个构成重载的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">max</span>(<span class="params">int a,int b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?<span class="attr">a</span>:b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double <span class="title function_">max</span>(<span class="params">double a,double b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?<span class="attr">a</span>:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><h4 id="1-3注意事项"><a href="#1-3注意事项" class="headerlink" title="1.3注意事项"></a>1.3注意事项</h4><p>（1）函数返回值类型与构成函数重载无任何关系；  </p><p>（2）<strong>类的静态成员函数与普通成员函数可以形成重载；</strong></p><p>（3）函数重载发生在==<strong>同一作用域</strong>==，如类成员函数之间的重载、全局函数之间的重载。</p><h3 id="2-函数隐藏（Function-Hiding）"><a href="#2-函数隐藏（Function-Hiding）" class="headerlink" title="2.函数隐藏（Function Hiding）"></a>2.函数隐藏（Function Hiding）</h3><h4 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h4><p>函数隐藏指**==不同作用域==**中定义的同名函数构成函数隐藏（==不要求函数返回值和函数参数类型相同==）。比如派生类成员函数屏蔽与其同名的基类成员函数、类成员函数屏蔽全局外部函数。请注意，==如果在派生类中存在与基类虚函数同返回值、同名且同形参的函数，则构成函数重写==。</p><h4 id="2-2用法用例"><a href="#2-2用法用例" class="headerlink" title="2.2用法用例"></a>2.2用法用例</h4><p>请仔细研读以下代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;global function with name:&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member function of A&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//func(&quot;lvlv&quot;);//A::func()将外部函数func(char*)隐藏</span></span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        ::<span class="built_in">func</span>(<span class="string">&quot;lvlv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A&#x27;s print&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useFunc</span><span class="params">()</span></span>&#123;          <span class="comment">//隐藏A::void useFunc()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&#x27;s useFunc&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useFunc</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;      <span class="comment">//隐藏A::void useFunc()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In B&#x27;s useFunc(),i=&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">char</span>* a)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&#x27;s print:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面编译不通过,因为对父类虚函数重写时，需要函数返回值类型，函数名称和参数类型全部相同才行</span></span><br><span class="line">    <span class="comment">// virtual int print()&#123;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;B&#x27;s print:&quot;&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">useFunc</span>();</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">useFunc</span>();<span class="comment">//A::useFunc()被B::useFunc()隐藏</span></span><br><span class="line">    b.A::<span class="built_in">useFunc</span>();</span><br><span class="line">    b.<span class="built_in">useFunc</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//b.print();//编译出错，A::print()被B::print(char* a)隐藏</span></span><br><span class="line">    b.A::<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>(<span class="string">&quot;jf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">程序执行结果： </span><br><span class="line">member function of A</span><br><span class="line">global function with name:lvlv</span><br><span class="line"></span><br><span class="line">B<span class="number">&#x27;</span>s useFunc</span><br><span class="line">  </span><br><span class="line">member function of A</span><br><span class="line">global function with name:lvlv</span><br><span class="line">  </span><br><span class="line">In B<span class="number">&#x27;</span><span class="function">s <span class="title">useFunc</span><span class="params">()</span>,i</span>=<span class="number">2</span></span><br><span class="line">  </span><br><span class="line">A<span class="number">&#x27;</span>s print</span><br><span class="line">  </span><br><span class="line">B<span class="number">&#x27;</span>s print:jf</span><br></pre></td></tr></table></figure><h4 id="2-3注意事项"><a href="#2-3注意事项" class="headerlink" title="2.3注意事项"></a>2.3注意事项</h4><p>对比函数隐藏与函数重载的定义可知：  </p><p>（1）派生类成员函数与基类成员函数同名但参数不同。此时基类成员函数将被隐藏（注意别与重载混淆，重载发生在同一个类中）；  </p><p>（2）函数重载发生在同一作用域，函数隐藏发生在不同作用域。</p><h3 id="3-函数覆盖与函数重写（Function-Override）"><a href="#3-函数覆盖与函数重写（Function-Override）" class="headerlink" title="3.函数覆盖与函数重写（Function Override）"></a>3.函数覆盖与函数重写（Function Override）</h3><p>网上和很多书籍多都会涉及函数覆盖的概念，众说纷纭，加大了许多初学者的学习难度，甚至产生误导。事实上，函数覆盖就是函数重写。</p><h4 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h4><p>派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写。</p><p>关于返回值类型存在一种特殊情况，即协变返回类型（covariant return type）。</p><h4 id="3-2虚函数重写与协变返回类型"><a href="#3-2虚函数重写与协变返回类型" class="headerlink" title="3.2虚函数重写与协变返回类型"></a>3.2虚函数重写与协变返回类型</h4><p>如果虚函数函数返回指针或者引用时（不包括value语义），子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型（这就是所谓的协变返回类型）[4]^{[4]}。看示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:public A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    virtual A&amp; <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:public <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">     <span class="comment">//返回值协变，构成虚函数重写</span></span><br><span class="line">     B&amp; <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-3注意事项"><a href="#3-3注意事项" class="headerlink" title="3.3注意事项"></a>3.3注意事项</h4><p><strong>（1）函数覆盖就是虚函数重写，而不是函数被”覆盖”。</strong>  从上面的代码可以看出，函数是不可能被“覆盖”的。有些人可能会错误地认为函数覆盖会导致函数被”覆盖”而”消失”，将不能被访问，事实上只要通过作用域运算符::就可以访问到被覆盖的函数。因此，不存在被”覆盖“的函数。</p><p><strong>（2）函数覆盖是函数隐藏的特殊情况。</strong>  对比函数覆盖和函数隐藏的定义，不难发现函数覆盖其实是函数隐藏的特例。</p><p>如果派生类中定义了一个==与基类虚函数同名但<strong>参数列表不同</strong>的非virtual函数==，则此函数是一个普通成员函数（非虚函数），并形成对基类中同名虚函数的隐藏，而非虚函数覆盖（重写）。</p><p>《C++高级进阶教程》中认为函数的隐藏与覆盖是两个不同的概念。<strong>隐藏是一个静态概念</strong>，它代表了标识符之间的一种屏蔽现象，而<strong>覆盖则是为了实现动态联编</strong>，是一个动态概念。但隐藏和覆盖也有联系：形成覆盖的两个函数之间一定形成隐藏。例如，可以对虚函数采用“实调用”，即尽管被调用的是虚函数，但是被调用函数的地址还是在编译阶段静态确定的，那么派生类中的虚函数仍然形成对基类中虚函数的同名隐藏。</p><p>参考如下代码，考察虚函数的实调用和虚调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">show</span>();</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();          <span class="comment">//对函数show()的实调用</span></span><br><span class="line">    d.Base::<span class="built_in">show</span>();    <span class="comment">//对函数show()的实调用</span></span><br><span class="line">    Base *pb=<span class="literal">NULL</span>;     </span><br><span class="line">    pb=&amp;d;             </span><br><span class="line">    pb-&gt;<span class="built_in">show</span>();        <span class="comment">//对函数show()的虚调用</span></span><br><span class="line">    pb-&gt;Base::<span class="built_in">show</span>();  <span class="comment">//对函数show()的实调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>程序运行结果：  In Base  In Derived  In Base  In Derived  In Base</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>在讨论相关概念的区别时，抓住定义才能区别开来。C++中函数重载隐藏和覆盖的区别，并不难，难就难在没弄清定义，被网上各种说法弄的云里雾里而又没有自己的理解。</p><p>在这里，牢记以下几点，就可区分函数重载、函数隐藏、函数覆盖和函数重写的区别： </p><p>（1）函数重载发生在相同作用域；  </p><p>（2）函数隐藏发生在不同作用域；  </p><p>（3）函数覆盖就是函数重写。准确地叫作虚函数覆盖和虚函数重写，也是函数隐藏的特例。</p><p>关于三者的对比，李健老师在《编写高质量代码：改善C++程序的150个建议》给出了较为详细的总结，如下表所示：</p><table><thead><tr><th align="left">三者</th><th align="left">作用域</th><th align="left">有无virtual</th><th align="left">函数名</th><th align="left">形参列表</th><th align="left">返回值类型</th></tr></thead><tbody><tr><td align="left">重载</td><td align="left">相同</td><td align="left">可有可无</td><td align="left">相同</td><td align="left">不同</td><td align="left">可同可不同</td></tr><tr><td align="left">隐藏</td><td align="left">不同</td><td align="left">可有可无</td><td align="left">相同</td><td align="left">可同可不同</td><td align="left">可同可不同</td></tr><tr><td align="left">重写</td><td align="left">不同</td><td align="left">有</td><td align="left">相同</td><td align="left">相同</td><td align="left">相同（协变）</td></tr></tbody></table><h3 id="动态联编与静态联编"><a href="#动态联编与静态联编" class="headerlink" title="动态联编与静态联编"></a>动态联编与静态联编</h3><p>在 C++ 中，联编是指一个计算机程序的不同部分彼此关联的过程。按照联编所进行的阶段不同，可以分为静态联编和动态联编；</p><p>静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。</p><p>动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p><p>C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p><p>实现动态联编三个条件：</p><p>必须把动态联编的行为定义为类的虚函数；</p><p>类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来；</p><p>必须先使用基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数；</p><h2 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>基类（父类）——&gt; 派生类（子类）</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为<strong>消息以多种形式显示的能力</strong>。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void do(int a);</span><br><span class="line">    void do(int a, int b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="void-指针（泛型指针）"><a href="#void-指针（泛型指针）" class="headerlink" title="void * 指针（泛型指针）"></a>void * 指针（泛型指针）</h5><p><a href="https://zhuanlan.zhihu.com/p/163676489?utm_source=wechat_session&amp;utm_id=0">https://zhuanlan.zhihu.com/p/163676489?utm_source=wechat_session&amp;utm_id=0</a></p><p>void即为不确定类型——类型不确定从而所占内存不确定，所以诸如<code>void par = 10;</code>之类的声明是万万不可的，即<strong>void类型不能声明实例对象</strong>。在C语言中，void的作用主要有以下两大类：</p><ol><li>对函数返回类型的限定，利用void对象的大小不确定来限制函数不能有任何返回值——这就是我们常写的void作返回值的函数。</li><li>对函数参数类型的限定，当函数不允许接受参数是，必须用void来限定函数的参数——当然现在没什么会这么写了:<code>int func(void);</code>。</li></ol><p>但<code>void*</code>则不同，编译器会允许你做类似于<code>int someInt = 10; void* par = &amp;someInt;</code>之类的操作，因为无论指向什么类型的指针，指针本身所占空间是一定的。我们可以认为<code>void*</code>就是一个通用指针，可以指向任意类型的指针。我们都知道，指针有两个属性：指向变量/对象的地址和长度，<strong>但是指针指存储被指向变量的地址，长度则取决于指针的类型</strong>，编译器根据指针的类型从指针指向的地址向后寻址，不同的类型则寻址范围不同，如<code>int*</code>从指定地址向后寻找4字节作为变量的存储单元。而我们将一个<code>void</code>类型的指针指向一个int类型的实例，<strong>实际上是抹去了这一实例的类型信息</strong>，因此在使用时我们要在心里清楚被抹去的类型信息。</p><h4 id="动态多态（运行期-晚绑定）"><a href="#动态多态（运行期-晚绑定）" class="headerlink" title="动态多态（运行期/晚绑定）"></a>动态多态（运行期/晚绑定）</h4><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数。</li></ul><h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><blockquote><p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?</a></p></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h5 id="虚函数内联使用"><a href="#虚函数内联使用" class="headerlink" title="虚函数内联使用"></a>虚函数内联使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">Base b;</span><br><span class="line">b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="动态多态使用"><a href="#动态多态使用" class="headerlink" title="动态多态使用"></a>动态多态使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>                     <span class="comment">// 形状类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> : <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><p>虚析构函数使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;<span class="built_in">calcArea</span>();    </span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="析构函数一般写成虚函数的原因"><a href="#析构函数一般写成虚函数的原因" class="headerlink" title="析构函数一般写成虚函数的原因"></a>析构函数一般写成虚函数的原因</h4><p>直观的讲：是为了降低内存泄漏的可能性。举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数  （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。</p><p>如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。</p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual int A() = 0;</span><br></pre></td></tr></table></figure><h4 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h4><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li><li>虚基类是虚继承中的基类，具体见<a href="http://c.biancheng.net/view/2280.html">虚继承</a>。</li></ul><blockquote><p><a href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p></blockquote><h4 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h4><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份。在程序只读数据段（<code>.rodata section</code>，见：<a href="https://github.com/huihut/interview#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><blockquote><p><a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p></blockquote><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p><a href="https://blog.csdn.net/galaxyrt/article/details/118118831">https://blog.csdn.net/galaxyrt/article/details/118118831</a></p><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，8字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table  pointer），该指针指向了一个虚基类表（virtual  table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><h4 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h4><ul><li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同之处：<ul><li>虚继承<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h4 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h4><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h4 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h4><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h3 id="计算下面几个类的大小"><a href="#计算下面几个类的大小" class="headerlink" title="计算下面几个类的大小"></a>计算下面几个类的大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;; <span class="built_in">sizeof</span>(A) = <span class="number">1</span>; <span class="comment">//空类在实例化时得到一个独一无二的地址，所以为 1. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>(<span class="number">32b</span>it)/<span class="number">8</span>(<span class="number">64b</span>it) <span class="comment">//当 C++ 类中有虚函数的时候，会有一个指向虚函数表的指针（vptr）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;<span class="type">static</span> <span class="type">int</span> a; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="type">int</span> a; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FA</span>&#123;<span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :FA&#123;<span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> FA&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :FA&#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">1</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> FA&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :<span class="keyword">virtual</span> FA&#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">1</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">8</span> <span class="comment">//虚继承的子类都有一个虚基类指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="各种类型的大小"><a href="#各种类型的大小" class="headerlink" title="各种类型的大小"></a>各种类型的大小</h3><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240328101145424.png" alt="image-20240328101145424"></p><h3 id="关于虚函数"><a href="#关于虚函数" class="headerlink" title="关于虚函数"></a>关于虚函数</h3><ul><li>为什么调用普通函数比调用虚函数的效率高？</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为普通函数是静态联编的，而调用虚函数是动态联编的。</span><br><span class="line"></span><br><span class="line">联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。</span><br><span class="line"></span><br><span class="line">静态联编 ：在编译的时候就确定了函数的地址，然后call就调用了。</span><br><span class="line">动态联编 ：首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数，然后call调用。</span><br><span class="line"></span><br><span class="line">明显动态联编要比静态联编做的操作多，肯定就费时间。</span><br></pre></td></tr></table></figure><ul><li>为什么要用虚函数表（存函数指针的数组）？</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现多态，父类对象的指针指向父类对象调用的是父类的虚函数，指向子类调用的是子类的虚函数。</span><br><span class="line">同一个类的多个对象的虚函数表是同一个，所以这样就可以节省空间，一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表。</span><br></pre></td></tr></table></figure><ul><li>为什么要把基类的析构函数定义为虚函数？</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象, 而不能删除子类对象, 形成了删除一半形象, 会造成内存泄漏.如下代码：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;;  </span><br><span class="line">    ~<span class="built_in">Base</span>()   </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete Base&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;;  </span><br><span class="line">    ~<span class="built_in">Derived</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete Derived&quot;</span> &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//操作1  </span></span><br><span class="line">    Base* p1 = <span class="keyword">new</span> Derived;  </span><br><span class="line">    <span class="keyword">delete</span> p1;  </span><br><span class="line">    <span class="comment">//因为这里子类的析构函数重写了父类的析构函数，虽然子类和父类的析构函数名不一样，  </span></span><br><span class="line">    <span class="comment">//但是编译器对析构函数做了特殊的处理，在内部子类和父类的析构函数名是一样的。  </span></span><br><span class="line">    <span class="comment">//所以如果不把父类的析构函数定义成虚函数，就不构成多态，由于父类的析构函数隐藏了子类  </span></span><br><span class="line">    <span class="comment">//的析构函数，所以只能调到父类的析构函数。  </span></span><br><span class="line">    <span class="comment">//但是若把父类的析构函数定义成虚函数，那么调用时就会直接调用子类的析构函数，  </span></span><br><span class="line">    <span class="comment">//由于子类析构先要去析构父类，在析构子类，这样就把子类和继承的父类都析构了  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>子类是否要重写父类的虚函数？</li></ul><p>子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><h4 id="虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive-3-2"><a href="#虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive-3-2" class="headerlink" title="虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2"></a>虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:%d\n&quot;</span>, a + n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Derive:%d\n&quot;</span>, b + n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derive[<span class="number">10</span>];</span><br><span class="line">    ptr[<span class="number">7</span>].<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h4><ol><li>从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间(运行时)的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</li><li>从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li></ol><h3 id="如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"><a href="#如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？" class="headerlink" title="如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"></a>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</h3><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p><ul><li>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：<code>A a;</code></li><li>动态建立：使用 <code>new</code> 关键字在堆空间上创建对象，底层首先调用 <code>operator new()</code> 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li></ul><p>限制对象只能建立在堆上：</p><ul><li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 <code>new</code> 来建立对象。但是由于 <code>new</code> 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 <code>new</code> 创建对象了。因此，这种方法不可行。</p></li><li><p>解决方法 1：</p><ul><li><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p><ul><li>C++</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法存在的问题：</p></li><li><p>用 <code>new</code> 创建的对象，通常会使用 <code>delete</code> 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 <code>destory()</code> 函数，用来释放 <code>new</code> 创建的对象。</p></li><li><p>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 <code>virtual</code>，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p></li></ul></li><li><p>解决方法 2：</p><ul><li><p>构造函数设置为 <code>protected</code>，并提供一个 <code>public</code> 的静态函数来完成构造，而不是在类的外部使用 <code>new</code> 构造；将析构函数设置为 <code>protected</code>。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p><ul><li>C++</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A* create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>限制对象只能建立在栈上：</p><ul><li><p>解决方法：将 <code>operator new()</code> 设置为私有。原因：当对象建立在堆上时，是采用 <code>new</code>的方式进行建立，其底层会调用 <code>operator new()</code> 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p></li><li><p>C++</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    void *operator new(size_t t) &#123;&#125;    // 注意函数的第一个参数和返回值都是固定的</span><br><span class="line">    void operator delete(void *ptr) &#123;&#125; // 重载了 new 就需要重载 delete</span><br><span class="line">public:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>; </span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都==必须从内存中取出值==（没有被 volatile 修饰的变量，可能由于编译器的优化，从 <strong>CPU 寄存器</strong>中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><p>const和volatile 也一样，所谓的const，只是编译器保证在C的“源代码”里面，没有对该变量进行修改的地方，而实际运行的时候则不是编译器所能管的了。<br> 　同样，volatile的所谓“可能被修改”，是指“在运行期间”可能被修改。也就是告诉编译器，这个变量不是“只”会被这些C的“源代码”所操纵，其它地方也有操纵它们的地方。所以，C编译器就不能随便对它进行优化了。<br> 　const    –&gt;该变量为常量,不能在此程序中更改<br> 　volotile –&gt;该变量为一个共享变量,也就是说会有除了本程序之外的其他途径对其值进行更改,如多线程,或是硬件，其他的运行程序.<br> 　const volatile表示该变量既不能被修改，又不能被优化到寄存器，即又是可能会被其他编译器不知道的方式修改的。比如一个<code>实时时钟</code>，我们不希望被程序做修改，所以要声明为const，但其他的线程、中断等（可能来自于库）又要修改此时钟的值，编译器不能把它作为const常量优化到寄存器，所以又要声明为volatile。再举个例子，<code>只读的状态寄存器</code>，它是volatile，因为它可能被意想不到地改变。它是const，因为程序不应该试图去修改它。</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><p>assert() 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><p>extern “C” 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="C-中的链接属性"><a href="#C-中的链接属性" class="headerlink" title="C++中的链接属性"></a>C++中的链接属性</h4><p>　　 链接属性一定程度范围决定着符号的作用域，C++中链接属性有三种：none(无)、external（外部）和 internal(内部）。</p><ul><li>external，外部链接属性。非常量全局变量和自由函数（除成员函数以外的函数）均默认为外部链接的，它们具有全局可见性，在全局范围不允许重名，详情可见例子。</li><li>internal，内部链接属性。具有该属性的类型有，const对象，constexpr对象，命令空间内的静态对象(static objects in namespace scope)</li><li>none，在类中、函数体和代码块中声明的变量默认是具有none链接属性。它和internal一样只在当前作用域可见。</li></ul><h2 id="extern的用法"><a href="#extern的用法" class="headerlink" title="extern的用法"></a>extern的用法</h2><p>　　extern有3种用法，分别如下：</p><h3 id="非常量全局变量的外部链接"><a href="#非常量全局变量的外部链接" class="headerlink" title="非常量全局变量的外部链接"></a>非常量全局变量的外部链接</h3><p>　　 最常见的用法，当链接器在一个<strong>全局变量</strong>声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。</p><p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203301643105.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//fileA.cpp</span><br><span class="line">int i = 1;         //声明并定义全局变量i</span><br><span class="line"></span><br><span class="line">//fileB.cpp</span><br><span class="line">extern int i;    //声明i，链接全局变量</span><br><span class="line"></span><br><span class="line">//fileC.cpp</span><br><span class="line">extern int i = 2;        //错误，多重定义</span><br><span class="line">int i;                    //错误，这是一个定义，导致多重定义</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    extern int i;        //正确</span><br><span class="line">    int i = 5;            //正确，新的局部变量i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量全局变量的外部链接"><a href="#常量全局变量的外部链接" class="headerlink" title="常量全局变量的外部链接"></a>常量全局变量的外部链接</h3><p>　　常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//fileA.cpp</span><br><span class="line">extern const int i = 1;        //定义</span><br><span class="line"></span><br><span class="line">//fileB.cpp                    //声明</span><br><span class="line">extern const int i;</span><br></pre></td></tr></table></figure><h3 id="extern-“C”-和extern-“C-”函数声明"><a href="#extern-“C”-和extern-“C-”函数声明" class="headerlink" title="extern “C” 和extern “C++”函数声明"></a>extern “C” 和extern “C++”函数声明</h3><p>　　 在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern  “C”，就指明使用C语言的链接规范。原因是，C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。C和C++对函数的处理方式是不同的.extern  “C”是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern “C”来说明。</p><p>　　例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明printf函数使用C链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指定的头文件内所有的东西都使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明函数ShowChar和GetChar使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">ShowChar</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">GetChar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义函数 ShowChar 和 GetChar 使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">char</span> <span class="title">ShowChar</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">char</span> <span class="title">GetChar</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局变量 errno 为C链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又比如，在程序中常见的代码段</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**** some declaration or so *****/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，</span></span><br><span class="line"><span class="comment">//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern &quot;C&quot;&#123;和&#125;处理其中的代码。</span></span><br></pre></td></tr></table></figure><ul><li>使用extern和包含头文件来引用函数有什么区别呢？</li></ul><p>　　与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容。extern的引用方式比包含头文件要更简洁。extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>不要把变量定义放入.h文件，这样容易导致重复定义错误</li><li>尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。</li><li>可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。</li></ul><h2 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h2><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> S;</span><br></pre></td></tr></table></figure><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p><p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() &#123;&#125;</code>。</p><h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>一、如果在类标识符空间定义了 <code>struct Student &#123;...&#125;;</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，&quot;struct&quot; 关键字可省略</span></span><br></pre></td></tr></table></figure><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p><p>用typedef可以声明各种类型名,但不能用来<strong>定义变量</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 &quot;Student&quot; 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Student</span>(); </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> me;      <span class="comment">// 或者 &quot;S me&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>最本质的一个区别就是默认的访问控制<ol><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ol></li></ul><h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种==节省空间的特殊的类==，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li><p>共用体变量所占的内存长度是所有成员中最长的成员的长度</p></li><li><p>默认访问控制符为 public</p></li><li><p>可以含有构造函数、析构函数</p></li><li><p>不能含有引用类型的成员</p></li><li><p>不能继承自其他类，不能作为基类</p></li><li><p>==不能含有虚函数==</p></li><li><p>匿名 union 在定义所在作用域可直接访问 union 成员</p></li><li><p>匿名 union 不能包含 protected 成员或 private 成员</p></li><li><p>全局匿名联合必须是静态（static）的</p></li></ul><p>union 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">UnionTest</span> &#123;</span><br><span class="line">    <span class="built_in">UnionTest</span>() : <span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h2><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li></ul><p>explicit 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">A a2 = <span class="number">1</span>;<span class="comment">// OK：复制初始化</span></span><br><span class="line">A a3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">A a4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">A a5 = (A)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line"><span class="built_in">doA</span>(<span class="number">1</span>);<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (a1);<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">a6</span><span class="params">(a1)</span></span>;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="type">bool</span> a7 = a1;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="type">bool</span> a8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">B b2 = <span class="number">1</span>;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">B b3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">B b4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">B b5 = (B)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line"><span class="built_in">doB</span>(<span class="number">1</span>);<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (b1);<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="type">bool</span> b7 = b1;<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line"><span class="type">bool</span> b8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-的四种强制转换"><a href="#C-的四种强制转换" class="headerlink" title="C++ 的四种强制转换"></a><strong>C++</strong> 的四种强制转换</h2><p>C++ 的四种强制转换包括：<strong>static_cast, dynamic_cast, const_cast, reinterpret_cast</strong></p><ul><li><strong>static_cast</strong>：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换</li></ul><p>（派生类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；</p><ul><li><p><strong>dynamic_cast：</strong>专⻔⽤于派⽣类之间的转换，type-id 必须是<strong>类指针</strong>，类引⽤或 void*，对于下⾏转换是安全的，当<strong>类型不⼀致时，转换过来的是空指针</strong>，⽽static_cast当类型不⼀致时，转换过来的是错误意义的指针，可能造成⾮法访问等问题。</p></li><li><p><strong>const_cast：</strong>专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。</p></li><li><p><strong>reinterpret_cast：</strong>不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换。</p></li></ul><h2 id="C-中的指针参数传递和引用参数传递"><a href="#C-中的指针参数传递和引用参数传递" class="headerlink" title="C++ 中的指针参数传递和引用参数传递"></a><strong>C++</strong> 中的指针参数传递和引用参数传递</h2><p><strong>指针参数传递本质上是值传递</strong>，它所传递的是⼀个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的⼀个副本（替身）。</p><p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p><p>引用参数传递过程中，<strong>被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址</strong>。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p><p><strong>引用传递和指针传递是不同的</strong>，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引用参数的处理都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使⽤指向指针的指针或者指针引⽤。</p><ul><li>指针和引用的区别<a href="https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html">https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html</a></li></ul><h2 id="简单说一下函数指针"><a href="#简单说一下函数指针" class="headerlink" title="简单说一下函数指针"></a>简单说一下函数指针</h2><p>⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。</p><p>在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。</p><p>其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fun</span><span class="params">(<span class="type">char</span> * p)</span> </span>&#123;…&#125; <span class="comment">// 函数fun</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * (*pf)(<span class="type">char</span> * p); <span class="comment">// 函数指针pf</span></span><br><span class="line"></span><br><span class="line">pf = fun; <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pf</span>(p); <span class="comment">// 通过函数指针pf调⽤函数fun</span></span><br></pre></td></tr></table></figure><h2 id="范围解析运算符（不能被重载）"><a href="#范围解析运算符（不能被重载）" class="headerlink" title=":: 范围解析运算符（不能被重载）"></a>:: 范围解析运算符（不能被重载）</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ol><p>:: 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">11</span>;         <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;   <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">31</span>;     <span class="comment">// 初始化局部的 count 为 31</span></span><br><span class="line">count = <span class="number">32</span>;         <span class="comment">// 设置局部的 count 的值为 32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">::count = <span class="number">12</span>;       <span class="comment">// 测试 1：设置全局的 count 的值为 12</span></span><br><span class="line"></span><br><span class="line">A::count = <span class="number">22</span>;      <span class="comment">// 测试 2：设置类 A 的 count 为 22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fun</span>();        <span class="comment">// 测试 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><ul><li><p>左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值。</p></li><li><p>可以简单认为： 左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)</p></li></ul><h4 id="左值引用-amp"><a href="#左值引用-amp" class="headerlink" title="左值引用&amp;"></a>左值引用&amp;</h4><p>常规引用，一般表示对象的身份。</p><h4 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用&amp;&amp;"></a>右值引用&amp;&amp;</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p><p>右值引用的好处是能够利用右值引用实现<strong>移动语义</strong>的库代码</p><p><strong>拷贝构造函数</strong>和<strong>移动构造函数</strong>：例如<code>A a(10+20)</code>时，因为<code>10+20</code>是一个右值，<strong>拷贝构造函数</strong>会创建临时对象temp，然后将temp值赋给a，（此时temp和a是两个不同的地址），对象a使用刚刚temp被释放的内存</p><p>而<strong>移动构造函数</strong>也会创建临时变量temp，但所创建就是临时变量的地址就是之后用于a的地址，不会有额外的复制工作。</p><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>移动构造函数和移动赋值运算符的参数不能是const引用，因为修改了源对象</p></li><li><p>想让左值也调用移动构造/赋值运算符，用<code>move(x)</code>，例如<code>a=move(b)</code>,b是一个左值，但此时调用的移动赋值运算符</p></li><li><p><code>int &amp;&amp;r=5+6</code></p></li></ul><p>​        5+6是不能被取地址的，但<code>r</code>是可以被取地址的</p><p><a href="https://zhuanlan.zhihu.com/p/335994370">https://zhuanlan.zhihu.com/p/335994370</a></p><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li></ul><h2 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h2><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性,  而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代  alloca。</li></ol><h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p><p>malloc、free 使用</p><p>申请内存，确认是否申请成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = (char*) malloc(100);</span><br><span class="line">assert(str != nullptr);</span><br></pre></td></tr></table></figure><p>释放内存后指针置空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p); </span><br><span class="line">p = nullptr;</span><br></pre></td></tr></table></figure><h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><p>new、delete 使用</p><p>申请内存，确认是否申请成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    T* t = new T();     // 先内存分配 ，再构造函数</span><br><span class="line">    delete t;           // 先析构函数，再内存释放</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address) type (initializers)</span><br><span class="line">new (place_address) type [size]</span><br><span class="line">new (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h4 id="new与malloc区别"><a href="#new与malloc区别" class="headerlink" title="new与malloc区别"></a>new与malloc区别</h4><p><a href="https://www.cnblogs.com/QG-whz/p/5140930.html">https://www.cnblogs.com/QG-whz/p/5140930.html</a></p><h5 id="创建位置"><a href="#创建位置" class="headerlink" title="创建位置"></a>创建位置</h5><p> new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p><p> 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p><blockquote><p>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p></blockquote><h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul><li><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合<strong>类型安全</strong>性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p></li><li><p>new内存分配失败时，会抛出bac_alloc异常，它<strong>不会返回NULL</strong>；malloc分配内存失败时返回NULL。</p></li><li><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p></li></ul><h2 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h2><blockquote><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?</a></p></blockquote><p>合法，但：</p><ol><li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol><li>shared_ptr</li><li>unique_ptr</li><li>weak_ptr</li><li>auto_ptr（被 C++11 弃用）</li></ol><h4 id="1、auto-ptr（C-98-的⽅案，C11-已抛弃）采⽤所有权模式。"><a href="#1、auto-ptr（C-98-的⽅案，C11-已抛弃）采⽤所有权模式。" class="headerlink" title="1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。"></a><strong>1</strong>、<strong>auto_ptr</strong>（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;std::string&gt; p2;</span><br><span class="line"></span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr 不会报错.</span></span><br></pre></td></tr></table></figure><p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p><h4 id="2、unique-ptr（替换-auto-ptr-）"><a href="#2、unique-ptr（替换-auto-ptr-）" class="headerlink" title="2、unique_ptr（替换 auto_ptr ）"></a><strong>2</strong>、<strong>unique_ptr</strong>（替换 auto_ptr ）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。</p><p>采⽤所有权模式，还是上⾯那个例⼦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="keyword">auto</span>))</span></span>;<span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；<span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错</span></span><br></pre></td></tr></table></figure><p>编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。</p><p>因此，unique_ptr ⽐ auto_ptr 更安全。</p><h4 id="3、shared-ptr（共享型，强引⽤）"><a href="#3、shared-ptr（共享型，强引⽤）" class="headerlink" title="3、shared_ptr（共享型，强引⽤）"></a><strong>3</strong>、<strong>shared_ptr</strong>（共享型，强引⽤）</h4><p>shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。</p><p>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊auto_ptr,unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了可以共享所有权的智能指针。</p><h4 id="4、weak-ptr（弱引⽤）"><a href="#4、weak-ptr（弱引⽤）" class="headerlink" title="4、weak_ptr（弱引⽤）"></a><strong>4</strong>、<strong>weak_ptr</strong>（弱引⽤）</h4><p>weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr。weak_ptr 只是提供了对管理对象的⼀个访问⼿段。weak_ptr 设计的⽬的是为配合 shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。<strong>weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题</strong>，如果说两个 shared_ptr 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为weak_ptr就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="share-ptr的线程安全性"><a href="#share-ptr的线程安全性" class="headerlink" title="share_ptr的线程安全性"></a>share_ptr的线程安全性</h4><ul><li><p>shared_ptr的析构函数需要在使其他分享同一对象的所有权的shared_ptr实例的use_count()汇报数字减1，而C++标准规定对use_count()结果的变更不可以成为data race，于是<strong>析构函数不可以以一种产生data  race的方式去修改use_count()<strong>（及其底层对应的计数）。use_count在这里面汇报的是“</strong>强引用个数</strong>”，即不包含weak_ptr只计数shared_ptr的引用计数，故而析构函数对这个引用计数的修改必须是线程安全的，否则产生data race即违反了C++标准。而上一话题中提到的跨线程分享ownership的一组shared_ptr的并发析构，也就是安全的了，因为标准保证了析构函数对“强引用计数”无data race，故而它会被安全地逐个减1，并最终在导致减到0的那个线程上析构被分享的对象。</p></li><li><p>结论：对同一个对象分享所有权的shared_ptr在多个线程上的析构不需要外部加锁保护，C++标准以及标准的实现保证这一动作的线程安全性。</p></li></ul><h4 id="手写share-ptr"><a href="#手写share-ptr" class="headerlink" title="手写share_ptr"></a>手写share_ptr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> *m_count_;</span><br><span class="line">    T *m_ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>() : <span class="built_in">m_ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">m_count_</span>(<span class="keyword">new</span> <span class="type">size_t</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPtr</span>(T *ptr) : <span class="built_in">m_ptr_</span>(ptr), <span class="built_in">m_count_</span>(<span class="keyword">new</span> <span class="type">size_t</span>) &#123; m_count_ = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">        --(*m_count_);</span><br><span class="line">        <span class="keyword">if</span> (*m_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr_;</span><br><span class="line">            <span class="keyword">delete</span> m_count_;</span><br><span class="line">            m_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">            m_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷⻉构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;ptr) &#123;</span><br><span class="line">        m_count_ = ptr.m_count_;</span><br><span class="line">        m_ptr_ = ptr.m_ptr_;</span><br><span class="line">        ++(*m_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷⻉赋值运算</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr &amp;ptr) &#123; <span class="built_in">SharedPtr</span>(std::<span class="built_in">move</span>(ptr)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(SharedPtr &amp;&amp;ptr) : <span class="built_in">m_ptr_</span>(ptr.m_ptr_), <span class="built_in">m_count_</span>(ptr.m_count_) &#123;</span><br><span class="line">        ++(*m_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动赋值运算</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(SharedPtr &amp;&amp;ptr) &#123; <span class="built_in">SharedPtr</span>(std::<span class="built_in">move</span>(ptr)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解引⽤</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头运算</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载bool操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ptr_ == <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *m_count_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *m_count_ == <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(SharedPtr &amp;ptr)</span> </span>&#123; std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>size_t的取值range是目标平台下最大可能的数组尺寸</strong>,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int.</p><p><a href="https://www.zhihu.com/question/24773728">为什么要用size_t</a></p><h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><p>内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。 </p><ul><li>在类的构造函数和析构函数中没有匹配的调用new和delete函数</li></ul><p>两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存</p><ul><li><p>没有正确地清除嵌套的对象指针</p></li><li><p>在释放对象数组时在delete中没有使用方括号</p></li></ul><p>方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄漏。</p><p>释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。</p><ul><li>指向对象的指针数组不等同于对象数组</li></ul><p>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</p><p>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了</p><ul><li>缺少拷贝构造函数（浅拷贝和深拷贝的问题）</li></ul><p>两次释放相同的内存是一种错误的做法，同时可能会造成堆的崩溃。</p><p>按值传递会调用（拷贝）构造函数，<strong>引用传递</strong>不会调用。</p><p>在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。</p><p>所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符</p><ul><li>缺少重载赋值运算符</li></ul><p>这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203310922129.png" alt="image-20220331092241737"></p><ul><li>关于nonmodifying运算符重载的常见迷思</li></ul><p>a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针</p><p>b. 返回内部静态对象的引用。</p><p>c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收</p><p>解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int</p><ul><li>没有将基类的析构函数定义为虚函数</li></ul><p>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p><blockquote><p>野指针：没有被初始化的指针</p><p>造成野指针的原因：</p><p>指针变量没有被初始化（如果值不定，可以初始化为NULL）</p><p>指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</p><p>悬空指针：是指针最初指向的内存已经被释放了的一种指针。</p><p>指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204010031292.png" alt="img"></p><h3 id="内存泄漏检测工具的实现原理："><a href="#内存泄漏检测工具的实现原理：" class="headerlink" title="内存泄漏检测工具的实现原理："></a><strong>内存泄漏检测工具的实现原理：</strong></h3><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205081241794.png" alt="image.png"></p><p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li>Massif：检查程序中堆栈使用中出现的问题。</li><li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li></ul><p>检测原理：</p><ul><li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li><li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li></ul><h2 id="c-中函数被调用的过程"><a href="#c-中函数被调用的过程" class="headerlink" title="c++中函数被调用的过程"></a>c++中函数被调用的过程</h2><p><a href="https://www.zhihu.com/question/22444939/answer/22200552">https://www.zhihu.com/question/22444939/answer/22200552</a></p><p><strong>堆栈平衡</strong>（栈帧调整）：具体包括<br>保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）<br>将当前栈帧切换到新栈帧。（将ESP值装入EBP，更新栈帧底部）<br>给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）</p><h2 id="C-中内存分配情况"><a href="#C-中内存分配情况" class="headerlink" title="C++ 中内存分配情况"></a><strong>C++</strong> 中内存分配情况</h2><p><strong>栈</strong></p><p>由<strong>编译器自动分配和释放</strong>，一般保存的是<strong>局部变量和函数参数</strong>等。</p><p>连续的内存空间，在函数调用的时候，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。</p><p>大多数编译器中，<strong>参数是从右向左入栈</strong>（原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数长度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表的各变量类型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎片。</p><p>栈是高地址向低地址扩展，栈低高地址，空间较小。</p><p><a href="https://blog.csdn.net/tht2009/article/details/7019635?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-7019635-blog-78483471.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-7019635-blog-78483471.pc_relevant_default&utm_relevant_index=1">变长参数</a></p><p><strong>堆</strong></p><p>由<strong>程序员</strong>管理，需要<strong>手动</strong> new malloc delete free 进行分配和回收，如果不进行回收的话，会造成内存泄漏的问题。</p><p>不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生内存碎片的原因。</p><p>堆是低地址向高地址扩展，空间较大，较为灵活。</p><h5 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h5><p>分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p><p>常量存储区：存储常量，⼀般不允许修改。</p><h5 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h5><p>存放程序的⼆进制代码。</p><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">c++自由存储区是否等价于堆</a></p><p><a href="https://blog.csdn.net/linux_ever/article/details/50533149">malloc和new的区别</a></p><h5 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h5><ul><li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li><li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li></ul><h2 id="c-11新特性"><a href="#c-11新特性" class="headerlink" title="c++11新特性"></a>c++11新特性</h2><h2 id="C-模板是什么，底层怎么实现的？"><a href="#C-模板是什么，底层怎么实现的？" class="headerlink" title="C++ 模板是什么，底层怎么实现的？"></a><strong>C++</strong> 模板是什么，底层怎么实现的？</h2><p><a href="https://zhuanlan.zhihu.com/p/101898043">https://zhuanlan.zhihu.com/p/101898043</a></p><ul><li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产⽣不同的函数；编译器会对函数模板进⾏两次编译：在声明的地⽅对模板代码本身进⾏编译，在调⽤的地⽅对参数替换后的代码进⾏编译。</p></li><li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使⽤函数模板的源⽂件中包含函数模板的头⽂件，如果该头⽂件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。</p></li></ul><h2 id="请你来写个函数在-main-函数执行前先运行"><a href="#请你来写个函数在-main-函数执行前先运行" class="headerlink" title="请你来写个函数在 main 函数执行前先运行"></a>请你来写个函数在 <strong>main</strong> 函数执行前先运行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第⼀种：gcc扩展，标记这个函数应当在main函数之前执⾏。同样有⼀个__attribute((destructor))，标记函数应当在程序结束之前（main结束之后，或者调⽤了exit后）执⾏;</span></span><br><span class="line">__attribute((constructor))<span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before main 1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第⼆种：全局 static 变ᰁ的初始化在程序初始阶段，先于 main 函数的执⾏</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before main 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="built_in">test1</span>();</span><br><span class="line"><span class="comment">// 第三种：知乎⼤⽜ Milo Yip 的回答利⽤ lambda 表达式</span></span><br><span class="line"><span class="type">int</span> a = []() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before main 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请你来说⼀下-fork-函数"><a href="#请你来说⼀下-fork-函数" class="headerlink" title="请你来说⼀下 fork 函数"></a>请你来说⼀下 <strong>fork</strong> 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Fork：创建⼀个和当前进程映像⼀样的进程可以通过 fork() 系统调⽤：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>成功调⽤ fork() 会创建⼀个新的进程，它⼏乎与调⽤ fork() 的进程⼀模⼀样，这两个进程都会继续运行。在⼦进程中，成功的 fork( ) 调⽤会返回0。在⽗进程中 fork() 返回⼦进程的 pid。</p></li><li><p>如果出现错误，fork() 返回⼀个负值。</p></li><li><p>最常⻅的 fork() ⽤法是创建⼀个新的进程，然后使⽤ exec() 载⼊⼆进制映像，替换当前进程的映像。这种情况下，派⽣（fork）了新的进程，⽽这个⼦进程会执⾏⼀个新的⼆进制可执⾏⽂件的映像。这种“派⽣加执⾏”的⽅式是很常⻅的。</p></li></ul><p>在早期的 Unix 系统中，创建进程⽐较原始。当调⽤ fork 时，内核会把所有的内部数据结构复制⼀份，复制进程的⻚表项，然后把⽗进程的地址空间中的内容逐⻚的复制到⼦进程的地址空间中。但从内核⻆度来说，逐⻚的复制⽅式是⼗分耗时的。现代的 Unix 系统采取了更多的优化，例如 Linux，采⽤了写时复制的⽅法，⽽不是对⽗进程空间进程整体复制。</p><h2 id="简单说⼀下-printf-实现原理？"><a href="#简单说⼀下-printf-实现原理？" class="headerlink" title="简单说⼀下 printf 实现原理？"></a>简单说⼀下 <strong>printf</strong> 实现原理？</h2><ul><li><p>在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压⼊堆栈的⽅式来给函数传参数的（堆栈是⼀种先进后出的数据结构）。</p></li><li><p>最先压⼊的参数最后出来，在计算机的内存中，数据有 2 块，⼀块是堆，⼀块是栈（函数参数及局部变变量在这⾥），⽽栈是从内存的⾼地址向低地址⽣⻓的，控制⽣⻓的就是堆栈指针了，最先压⼊的参数是在最离⾯，就是说在所有参数的最后⾯，最后压⼊的参数在最外⾯，结构上看起来是第⼀个，所以最后压⼊的参数总是能够被函数找到。因为它就在堆栈指针的上方。printf的第⼀个被找到的参数就是那个字符指针，就是被双引号括起来的那⼀部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移了。</p></li></ul><ul><li>注意</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;<span class="comment">//这里是给a[0]加了89因为是p++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><code>3,3</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,x++);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x++,x);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,x,x++,x);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,x,++x,x++,x);  </span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 1  </span><br><span class="line">1 2  </span><br><span class="line">2 1 2  </span><br><span class="line">3 3 1 3  </span><br></pre></td></tr></table></figure><p>  在计算时，遇到x++会记录此时的x的值作为最后的输出结果。遇到x和++x的时候则不会将此时的计算结果作为最终的输出，只会修改x的值，在最终输出的时候都输出x的值（所以++x和x的结果总是一样的）。</p><p>​    为什么会是这个样子呢？参见某高手解释吧：</p><p>​    对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d %d\n&quot;</span>,a++, ++a, a++, ++a, a++, ++a );  </span><br></pre></td></tr></table></figure><p>输出<code>6 7 4 7 2 7</code></p><p>a++的值在运算过程中就能确定；</p><p> 而所有++a或者a（如果有）的值是所有对a的值产生影响的运算之后最终的值。</p><h2 id="手写字符串函数-strcat，strcpy，strncpy，memset，memcpy实现"><a href="#手写字符串函数-strcat，strcpy，strncpy，memset，memcpy实现" class="headerlink" title="手写字符串函数 strcat，strcpy，strncpy，memset，memcpy实现"></a>手写字符串函数 <strong>strcat</strong>，<strong>strcpy</strong>，<strong>strncpy</strong>，<strong>memset</strong>，<strong>memcpy</strong>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把 src 所指向的字符串复制到 dest，注意：dest定义的空间应该⽐src⼤。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);<span class="comment">//优化点1：检查输⼊参数</span></span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) *(dest++) = *(src++);</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//优化点2：⼿动地将最后的&#x27;\0&#x27;补上</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑内存重叠的字符串拷⻉函数 优化的点</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memmove</span>(dest, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 将⽬的字符串的起始位置先保存，最后要返回它的头指针</span></span><br><span class="line"><span class="comment">//2. 先找到dest的结束位置,再把src拷⻉到dest中，记得在最后要加上&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*dest != <span class="string">&#x27;\0&#x27;</span>)dest++;</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>)*(dest++) = *(src++);</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 str1 所指向的字符串和 str2 所指向的字符串进⾏⽐较。</span></span><br><span class="line"><span class="comment">//该函数返回值如下：</span></span><br><span class="line"><span class="comment">//如果返回值 &lt; 0，则表示 str1 ⼩于 str2。</span></span><br><span class="line"><span class="comment">//如果返回值 &gt; 0，则表示 str1 ⼤于 str2。</span></span><br><span class="line"><span class="comment">//如果返回值 = 0，则表示 str1 等于 str2。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(s1 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(s2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*s1 != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *s2 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s1 != *s2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s1-*s2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s1++, s2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当有⼀个字符串已经⾛到结尾</span></span><br><span class="line">    <span class="keyword">if</span> (*s1 !=<span class="string">&#x27;\0&#x27;</span>&amp;&amp; *s2==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*s1 ==<span class="string">&#x27;\0&#x27;</span>&amp;&amp; *s2!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟实现memcpy函数 从存储区 str2 复制 n 个字符到存储区 dst。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> *ret = dest;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="comment">//因为void* 不能直接解引⽤，所以需要强转成char*再解引⽤</span></span><br><span class="line"><span class="comment">//此处的void*实现了泛型编程</span></span><br><span class="line">        *(<span class="type">char</span> *) dest = *(<span class="type">char</span> *) src;</span><br><span class="line">        dest = (<span class="type">char</span> *) dest + <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *) src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑内存重叠的memcpy函数 优化的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p1 = (<span class="type">char</span> *) dest;</span><br><span class="line">    <span class="type">char</span> *p2 = (<span class="type">char</span> *) src;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) &#123;<span class="comment">//p1低地址p2⾼地址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != num; ++i) *(p1++) = *(p2++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从后往前赋值</span></span><br><span class="line">        p1 += num - <span class="number">1</span>;</span><br><span class="line">        p2 += num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != num; ++i) *(p1--) = *(p2--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.memcpy和memmove相同点</strong><br> 都是用于从src拷贝count个字节到dest。</p><p><strong>2.memcpy和memmove区别</strong><br> 如果目标区域和源区域有重叠的话：<br> memcpy不能够确保源串所在重叠区域在拷贝之前被覆盖。<br> memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后src内容会被更改，当目标区域与源区域没有重叠则和memcpy函数功能相同。</p><p> 但当源内存和目标内存存在重叠时，memcpy会出现错误，而memmove能正确地实施拷贝，但这也增加了一点点开销。</p><p><strong>memmove的处理措施：</strong><br> （1）当源内存的首地址等于目标内存的首地址时，不进行任何拷贝<br> （2）当源内存的首地址大于目标内存的首地址时，实行正向拷贝<br> （3）当源内存的首地址小于目标内存的首地址时，实行反向拷贝</p><h3 id="memcmp函数"><a href="#memcmp函数" class="headerlink" title="memcmp函数"></a>memcmp函数</h3><p>通过输入字节数n，比较前后两个数组从首地址开始的n个字节</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int arr1[5] = &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">int arr2[5] = &#123; 1,2,3,4,0x11223305 &#125;;</span><br><span class="line">int ret = memcmp(arr1, arr2, 16);</span><br><span class="line">printf(&quot;%d&quot;, ret);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arr1在内存中的样子</p><p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533402.png" alt="img"></p><p>arr2在内存中的样子 </p><p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533645.png"></p><p> 当比较16个字节时，相等</p><p> 当比较17个字节时，依然是相等</p><p>原因是：在第17个字节处刚好相等（这里是小端字节序）</p><p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533376.png" alt="img"></p><p>当比较18个字节时结果是-1</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533321.png" alt="img"></p><p>原因是在第18个字节处出现了不一样，arr2是33，arr1是00</p><h2 id="C或C-中的位域（bit-field）"><a href="#C或C-中的位域（bit-field）" class="headerlink" title="C或C++中的位域（bit field）"></a>C或C++中的位域（bit field）</h2><blockquote><p><strong>位段</strong>（或称“位域”，Bit field）为一种数据结构，可以把数据以位元的形式紧凑的储存，并允许程序员对此结构的位元进行操作。这种数据结构的好处：<br>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。位段可以很方便的访问一个值的部分内容从而可以简化程序源代码。</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>只可以在struct或者class中使用。具体用法如下：</p><p>比如，我们需要定义一个结构体来储存一些信息，我们可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ch;    <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> font;  <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  size;  <span class="comment">//32位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR2</span> ch2;</span><br></pre></td></tr></table></figure><p>其实上面的写法已经使得储存空间很紧凑了，但是我们可以用bit field进一步减少空间占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ch   : <span class="number">8</span>;    <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> font : <span class="number">6</span>;    <span class="comment">//6位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size : <span class="number">18</span>;   <span class="comment">//18位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR</span> ch1;</span><br></pre></td></tr></table></figure><p>可以看出，第一种写法需要使用48bit的空间来储存信息，但第二种写法（bit field）只需要30bit的空间就可以储存相同的信息。<strong>当然这种写法的前提是，我们知道将要储存数据的范围。</strong></p><h3 id="位域的大小"><a href="#位域的大小" class="headerlink" title="位域的大小"></a><strong>位域的大小</strong></h3><p>例如以下位域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该位域结构体中间有一个未命名的位域，占据 3  Bits，仅起填充作用，并无实际意义。 填充使得该结构总共使用了 8 Bits。但 C 语言使用 unsigned int  作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。  有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。文章以下均默认 unsigned int 为  32 Bits。</p><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p><a href="https://blog.csdn.net/u014609638/article/details/106987131/">https://blog.csdn.net/u014609638/article/details/106987131/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a)c=a;</span><br><span class="line"><span class="keyword">decltype</span>(a=b)d=a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>Type</th><th>Value</th></tr></thead><tbody><tr><td>a</td><td>int</td><td>4</td></tr><tr><td>b</td><td>int</td><td>4</td></tr><tr><td>c</td><td>int</td><td>4</td></tr><tr><td>d</td><td>int &amp;</td><td>4</td></tr></tbody></table><p>a是一个变量，所以decltype返回的类型就是int</p><p>而a=b是一个左值表达式，decltype接受的是左值表达式，返回左值引用；接受的是右值表达式，返回右值的类型，所以d的类型是int &amp;，又因为decltype里的表达式不会真的被计算，所以a还是3。又因为d是引用a，所以++d同时也会改变a</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th><strong>优先级</strong></th><th><strong>运算符</strong></th><th><strong>名称或含义</strong></th><th><strong>使用形式</strong></th><th><strong>结合方向</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1</td><td>[]</td><td>数组下标</td><td>数组名[常量表达式]</td><td>左到右</td><td></td></tr><tr><td></td><td>()</td><td>圆括号</td><td>（表达式）/函数名(形参表)</td><td></td><td></td></tr><tr><td></td><td>.</td><td>成员选择（对象）</td><td>对象.成员名</td><td></td><td></td></tr><tr><td></td><td>-&gt;</td><td>成员选择（指针）</td><td>对象指针-&gt;成员名</td><td></td><td></td></tr><tr><td>2</td><td>-</td><td>负号运算符</td><td>-表达式</td><td>右到左</td><td>单目运算符</td></tr><tr><td></td><td>(类型)</td><td>强制类型转换</td><td>(数据类型)表达式</td><td></td><td></td></tr><tr><td></td><td>++</td><td>前置自增运算符</td><td>++变量名</td><td></td><td>单目运算符</td></tr><tr><td></td><td>++</td><td>后置自增运算符</td><td>变量名++</td><td></td><td>单目运算符</td></tr><tr><td></td><td>–</td><td>前置自减运算符</td><td>–变量名</td><td></td><td>单目运算符</td></tr><tr><td></td><td>–</td><td>后置自减运算符</td><td>变量名–</td><td></td><td>单目运算符</td></tr><tr><td></td><td>*</td><td>取值运算符</td><td>*指针变量</td><td></td><td>单目运算符</td></tr><tr><td></td><td>&amp;</td><td>取地址运算符</td><td>&amp;变量名</td><td></td><td>单目运算符</td></tr><tr><td></td><td>!</td><td>逻辑非运算符</td><td>!表达式</td><td></td><td>单目运算符</td></tr><tr><td></td><td>~</td><td>按位取反运算符</td><td>~表达式</td><td></td><td>单目运算符</td></tr><tr><td></td><td>sizeof</td><td>长度运算符</td><td>sizeof(表达式)</td><td></td><td></td></tr><tr><td>3</td><td>/</td><td>除</td><td>表达式/表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td>*</td><td>乘</td><td>表达式*表达式</td><td></td><td>双目运算符</td></tr><tr><td></td><td>%</td><td>余数（取模）</td><td>整型表达式/整型表达式</td><td></td><td>双目运算符</td></tr><tr><td>4</td><td>+</td><td>加</td><td>表达式+表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td>-</td><td>减</td><td>表达式-表达式</td><td></td><td>双目运算符</td></tr><tr><td>5</td><td>&lt;&lt;</td><td>左移</td><td>变量</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td>&gt;&gt;</td><td>右移</td><td>变量&gt;&gt;表达式</td><td></td><td>双目运算符</td></tr><tr><td>6</td><td>&gt;</td><td>大于</td><td>表达式&gt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td>&gt;=</td><td>大于等于</td><td>表达式&gt;=表达式</td><td></td><td>双目运算符</td></tr><tr><td></td><td>&lt;</td><td>小于</td><td>表达式</td><td></td><td>双目运算符</td></tr><tr><td></td><td>&lt;=</td><td>小于等于</td><td>表达式</td><td></td><td>双目运算符</td></tr><tr><td>7</td><td>==</td><td>等于</td><td>表达式==表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td>!=</td><td>不等于</td><td>表达式!= 表达式</td><td></td><td>双目运算符</td></tr><tr><td>8</td><td>&amp;</td><td>按位与</td><td>表达式&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>9</td><td>^</td><td>按位异或</td><td>表达式^表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>10</td><td>|</td><td>按位或</td><td>表达式|表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>逻辑与</td><td>表达式&amp;&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>12</td><td>||</td><td>逻辑或</td><td>表达式||表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>13</td><td>?:</td><td>条件运算符</td><td>表达式1? 表达式2: 表达式3</td><td>右到左</td><td>三目运算符</td></tr><tr><td>14</td><td>=</td><td>赋值运算符</td><td>变量=表达式</td><td>右到左</td><td></td></tr><tr><td></td><td>/=</td><td>除后赋值</td><td>变量/=表达式</td><td></td><td></td></tr><tr><td></td><td>*=</td><td>乘后赋值</td><td>变量*=表达式</td><td></td><td></td></tr><tr><td></td><td>%=</td><td>取模后赋值</td><td>变量%=表达式</td><td></td><td></td></tr><tr><td></td><td>+=</td><td>加后赋值</td><td>变量+=表达式</td><td></td><td></td></tr><tr><td></td><td>-=</td><td>减后赋值</td><td>变量-=表达式</td><td></td><td></td></tr><tr><td></td><td>&lt;&lt;=</td><td>左移后赋值</td><td>变量</td><td></td><td></td></tr><tr><td></td><td>&gt;&gt;=</td><td>右移后赋值</td><td>变量&gt;&gt;=表达式</td><td></td><td></td></tr><tr><td></td><td>&amp;=</td><td>按位与后赋值</td><td>变量&amp;=表达式</td><td></td><td></td></tr><tr><td></td><td>^=</td><td>按位异或后赋值</td><td>变量^=表达式</td><td></td><td></td></tr><tr><td></td><td>|=</td><td>按位或后赋值</td><td>变量|=表达式</td><td></td><td></td></tr><tr><td>15</td><td>,</td><td>逗号运算符</td><td>表达式,表达式,…</td><td>左到右</td><td>从左向右顺序运算</td></tr></tbody></table><h3 id="左结合和右结合"><a href="#左结合和右结合" class="headerlink" title="左结合和右结合"></a>左结合和右结合</h3><p>a=b+c+d </p><p>=是右结合的，所以先计算(b+c+d)，然后再赋值给a<br> +是左结合的，所以先计算(b+c)，然后再计算(b+c)+d </p><h2 id="C-中-一个-号-和-两个-号-的用法和作用"><a href="#C-中-一个-号-和-两个-号-的用法和作用" class="headerlink" title="C++中#(一个#号)和##(两个#号)的用法和作用"></a>C++中#(一个#号)和##(两个#号)的用法和作用</h2><p>C/C++ 的宏中，#的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> WARNIF(EXP) \</span></span><br><span class="line"><span class="meta">do&#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (EXP) \</span></span><br><span class="line"><span class="meta">    &#123;    \    </span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> #EXP <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">    &#125;   \    </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)    </span><br><span class="line">在实际使用中会出现下面所示的替换过程：</span><br><span class="line"><span class="built_in">WARN_IF</span>(div == <span class="number">0</span>); 被替换成以下代码</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (div == <span class="number">0</span>) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> <span class="string">&quot;div == 0&quot;</span> <span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>##连接符号由两个井号组成，其功能是在带参数的宏定义中将两个子串联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define MERGE1(x,y) x##y</span><br><span class="line">#define MERGE2(x, y)         x##y##x</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int aaabbb=1;</span><br><span class="line">    int aaabbbaaa = 20;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;classname = &quot; &lt;&lt; MERGE1(aaa,bbb) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;aaabbbccc = &quot; &lt;&lt; MERGE2(aaa, bbb) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各种阅读程序题"><a href="#各种阅读程序题" class="headerlink" title="各种阅读程序题"></a>各种阅读程序题</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061809858.png" alt="image-20220506180917624"></p><p>答案为-6</p><ul><li>前缀++和–的优先级比*作为乘号时高（和*作为取指针指向值时相同）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061815592.png" alt="image-20220506181515336"></p><p>答案为32</p><ul><li>++l先+了再返回结果，模拟一遍即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        x = y = z = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> xx, <span class="type">int</span> yy = <span class="string">&#x27;A&#x27;</span>, <span class="type">int</span> zz = <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = x + yy;</span><br><span class="line">        z = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> xx=<span class="number">65</span>,<span class="type">int</span> yy=<span class="number">66</span>):<span class="built_in">Base</span>(xx,yy)&#123;</span><br><span class="line">        y=xx;</span><br><span class="line">        x=yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出就是66 65，不涉及继承和其他奇怪的操作</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071534208.png" alt="image-20220507153437974"></p><p><code>s1.s.d[0]</code>被设置为<code>1</code>时，这个字节现在和<code>s2</code>的相应字节（仍然是<code>0</code>，因为<code>s2.s.d</code>被清零了）不同。根据<code>memcmp</code>的比较规则，因为<code>s1</code>的相应字节<code>1</code>在ASCII表中小于<code>s2</code>的相应字节<code>0</code>，所以<code>memcmp</code>返回-1。</p><p>不难理解答案是-1</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071538504.png" alt="image-20220507153813260"></p><p>答案是3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr=(<span class="type">int</span> *)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;*(ptr<span class="number">-6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;a</code>获取的是数组<code>a</code>的地址，但请注意它是一个指向整个数组的指针，类型为<code>int (*)[10]</code>。当对<code>&amp;a</code>执行<code>+1</code>操作时，指针会跳过整个数组<code>a</code>的内存大小，即它将指向数组<code>a</code>之后的内存地址。换句话说，<code>&amp;a + 1</code>不是指向数组第一个元素的下一个元素的指针，而是跳过了整个数组的指针。</p><p>因此，<code>ptr</code>实际上是指向<code>a</code>数组尾部后的那个整数的地址。现在，考虑到数组<code>a</code>有10个元素，所以<code>ptr</code>指向的是<code>a[10]</code>（注意这是一个超出数组边界的位置）。</p><p>当你做<code>*(ptr - 6)</code>操作时，你实际上是访问<code>a[10 - 6]</code>，即<code>a[4]</code>。根据数组的初始化，<code>a[4]</code>的值是5。</p><p>答案是5</p><p>首先注意，虽然a和&amp;a[0]的地址相同但是&amp;a+1和&amp;a[0]+1(a+1)的含义是不同的</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644470.png" alt="image-20220507164400287"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644743.png" alt="image-20220507164415561"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071626248.png" alt="image-20220507162648006"></p><p>一个int是4个字节，所以&amp;a+1相当于+了4*10。再-6*4，就是a[4]的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp =[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;b;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;<span class="built_in">q</span>(cmp);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这是大根堆</p><p>输出853</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> s=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *pt=&amp;s;</span><br><span class="line">    cout&lt;&lt;*((<span class="type">int</span> *)pt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为5</p><p>因为结构体不像数组，例如<code>int a[10]</code>, a就是指向数组首地址的指针，而这个地方<code>struct node *pt=&amp;s;</code> ，pt只是结构体s的首地址，而并不是指针，所以要加一个(int *)把这个地址转换为指针，才能对指针+1之后再解引用，如果不加<code>int *</code>会报错</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="/2023/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统面试"><a href="#操作系统面试" class="headerlink" title="操作系统面试"></a>操作系统面试</h1><h2 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h2><ul><li>进程（Process）是系统进行<strong>资源分配和调度</strong>的基本单位，线程（Thread）是CPU调度的最小单位；</li><li>线程依赖于进程而存在，一个进程至少有一个线程；</li><li>进程有自己的==独立地址空间==，线程==共享所属进程的地址空间==；</li><li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器s,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</li><li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的<strong>寄存器</strong>的内容，并不涉及存储器管理方面的操作，可见，<strong>进程切换的开销远大于线程切换的开销</strong>；</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li><li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。</li></ul><h3 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h3><ul><li>进程代码段</li><li>进程的公有数据（全局变量、静态变量…）</li><li>进程打开的文件描述符</li><li>进程的当前目录</li><li>信号处理器/信号处理函数：对收到的信号的处理方式</li><li>进程ID与进程组ID</li></ul><h3 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h3><ul><li>线程ID</li><li>一组寄存器的值</li><li>线程自身的栈（堆是共享的）</li><li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li><li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li></ul><h3 id="进程间的通信方式有哪些？"><a href="#进程间的通信方式有哪些？" class="headerlink" title="进程间的通信方式有哪些？"></a>进程间的通信方式有哪些？</h3><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203151051218" alt="img"></p><h4 id="第一类：传统的Unix通信机制"><a href="#第一类：传统的Unix通信机制" class="headerlink" title="第一类：传统的Unix通信机制"></a>第一类：传统的Unix通信机制</h4><h4 id="1-管道-匿名管道-pipe"><a href="#1-管道-匿名管道-pipe" class="headerlink" title="1. 管道/匿名管道(pipe)"></a>1. 管道/匿名管道(pipe)</h4><ul><li>管道是<strong>半双工</strong>的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li><li>只能用于父子进程或者兄弟进程之间(具有<strong>亲缘关系</strong>的进程);</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203151103048" alt="img"></p><p><strong>管道的实质：</strong><br>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>无名管道的优点：</strong></p><ul><li>简单易用</li></ul><p><strong>无名管道的缺点：</strong></p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>管道的缓冲区是有限的。</li></ul><h4 id="2-有名管道-FIFO"><a href="#2-有名管道-FIFO" class="headerlink" title="2.有名管道(FIFO)"></a>2.有名管道(FIFO)</h4><p><strong>有名管道的优点：</strong></p><p>允许无亲缘关系进程间的通信</p><p><strong>有名管道的缺点：</strong></p><ul><li>由于有名管道的名字存在于文件系统中，内容存放在内存中，所以它长期存于系统中，使用不当容易出错。</li><li>管道的缓冲区是有限的。</li></ul><h4 id="3-信号-Signal"><a href="#3-信号-Signal" class="headerlink" title="3.信号(Signal)"></a>3.信号(Signal)</h4><ul><li>信号可以在<strong>任何时候</strong>发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li><li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，<strong>保护上下文</strong>（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。</li></ul><p><strong>Linux系统中常用信号：</strong></p><ul><li><strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。（强制终止不能被无视）</li><li><strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。</li></ul><h4 id="4-消息-Message-队列"><a href="#4-消息-Message-队列" class="headerlink" title="4.消息(Message)队列"></a>4.消息(Message)队列</h4><ul><li><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p></li><li><p>与管道（<strong>无名管道</strong>：只存在于内存中的文件；<strong>命名管道</strong>：存在于实际的磁盘介质或者文件系统）不同的是消息队列是随内核持续的，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p></li><li><p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</p></li><li><p><strong>优点</strong>：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</p></li><li><p><strong>缺点</strong>：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</p></li></ul><h4 id="5-共享内存-share-memory"><a href="#5-共享内存-share-memory" class="headerlink" title="5. 共享内存(share memory)"></a>5. 共享内存(share memory)</h4><ul><li>使得多个进程可以可以直接读写同一块内存空间，是<strong>最快的</strong>可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li><li><strong>优点</strong>：无须复制，快捷，信息量大</li><li>缺点：<ul><li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此要考虑进程间的读写操作的同步问题</li><li>问题利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ul></li></ul><h4 id="6-信号量-semaphore"><a href="#6-信号量-semaphore" class="headerlink" title="6.信号量(semaphore)"></a>6.信号量(semaphore)</h4><ul><li>PV操作</li></ul><h4 id="7-套接字-socket"><a href="#7-套接字-socket" class="headerlink" title="7. 套接字(socket)"></a>7. 套接字(socket)</h4><p> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p><strong>套接字是支持TCP/IP的网络通信的基本操作单元</strong>，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p><h2 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h2><ul><li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制(Semaphore)<ul><li>无名线程信号量</li><li>命名线程信号量</li></ul></li><li>信号机制(Signal)：类似进程间的信号处理</li><li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>也称之为 共享-独占锁，一般用在读和写的次数有很大不同的场合。即对某些资源的访问会出现两种情况，一种是访问的排他性，需要独占，称之为写操作；还有就是访问可以共享，称之为读操作。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>是最常见的线程同步方式，它是一种特殊的变量，它有 lock 和 unlock 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取</p><h2 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h2><p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p><p>解决方法：</p><ul><li>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li><li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。（<strong>让低优先级暂时变高，赶紧释放占着的资源</strong>）</li></ul><h2 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h2><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p><p>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</p><p>以下情况不会产生僵尸进程：</p><ul><li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li><li>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入<code>WNOHANG</code>(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li><li>子进程结束时，系统会产生<code>SIGCHLD</code>(signal-child)信号，可以注册一个<strong>信号处理函数</strong>，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在<strong>信号处理函数</strong>开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li><li>也可以用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号，那么子进程结束后，内核会进行回收。</li></ul><h3 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h3><p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</p><h2 id="线程同步有哪些方式？"><a href="#线程同步有哪些方式？" class="headerlink" title="线程同步有哪些方式？"></a>线程同步有哪些方式？</h2><blockquote><p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p></blockquote><ul><li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li><li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过<code>ReleaseSemaphore</code>函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；</li><li><strong>事件</strong>  Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li><li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li></ul><h3 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h3><p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</p><h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁    的访问全局变量，所以上下文的切换非常快。</p><h5 id="协程多与线程进行比较？"><a href="#协程多与线程进行比较？" class="headerlink" title="协程多与线程进行比较？"></a>协程多与线程进行比较？</h5><ol><li>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程。</li><li>线程进程都是同步机制，而协程则是异步</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ol><h2 id="产生死锁的四个必要条件（破坏死锁的四个条件）"><a href="#产生死锁的四个必要条件（破坏死锁的四个条件）" class="headerlink" title="产生死锁的四个必要条件（破坏死锁的四个条件）"></a>产生死锁的四个必要条件（破坏死锁的四个条件）</h2><h3 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h3><p>一个资源只能由进程独占使用，若别的进程也要求该资源，则需等待直至其占用者释放。</p><h3 id="请求和保持条件"><a href="#请求和保持条件" class="headerlink" title="请求和保持条件"></a>请求和保持条件</h3><p>进程已经保持了至少一个资源，但又提出新的资源请求，而该资源又被其他进程占有。此时请求进程阻塞，但又不释放自己获得的资源。</p><h3 id="非剥夺条件"><a href="#非剥夺条件" class="headerlink" title="非剥夺条件"></a>非剥夺条件</h3><p>进程所获得的资源在未使用完之前，不能被其他进程夺走，而只能由自身释放。</p><h3 id="循环等待条件"><a href="#循环等待条件" class="headerlink" title="循环等待条件"></a>循环等待条件</h3><p>存在一个等待进程集合${p_0,p_1,…,p_n}$，$p_0$在等待$p_1$占用的资源，$p_1$在等待$p_2$占用的资源，$p_n$在等待$p_0$占用的资源。</p><h2 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h2><ul><li>页式存储：用户空间划分为大小相等的部分称为页，内存空间划分为同样大小的区域称为页框，分配时以页为单位按进程需要的页数分配，<strong>逻辑上相邻的页物理上不一定相邻</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205091158644.png" alt="截屏2022-05-09 11.57.43"></p><ul><li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，<strong>逻辑上相邻的段物理上也相邻</strong>占据连续空间，各段可以不相邻。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205091244361.png" alt="image-20220509124451301"></p><ul><li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202091841145.png" alt="image-20220209184143923"></p><p><strong>外碎片</strong>：外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。 <strong>内碎片</strong>：内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间； 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部<strong>碎片</strong>。</p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240328131938684.png" alt="image-20240328131938684"></p><h2 id="缓冲区溢出问题"><a href="#缓冲区溢出问题" class="headerlink" title="缓冲区溢出问题"></a>缓冲区溢出问题</h2><p>C 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C  对于数组引用不进行任何边界检查，因此<strong>对越界的数组元素的写操作会破坏存储在栈中的状态信息</strong>，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。</p><h3 id="防范方式"><a href="#防范方式" class="headerlink" title="防范方式"></a>防范方式</h3><p>防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。</p><ul><li>随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout  Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。</li><li>栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个<strong>随机产生的</strong>特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</li><li>限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。</li></ul><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p><ul><li>先来先服务</li><li>最短寻道时间优先</li><li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li></ul><h2 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h2><p>中断是指 <strong>CPU</strong> 对系统发生某事件时的这样一种响应: CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。</p><ul><li>中断——外部事件引起<strong>，</strong>正在运行的程序所不期望的</li><li>异常——内部执行指令引起</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识点</title>
      <link href="/2023/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库面试"><a href="#数据库面试" class="headerlink" title="数据库面试"></a>数据库面试</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><ul><li><p>事务（Transaction）是一个操作序列，不可分割的工作单位，以begin/start transaction</p><p>开始，以 rollback/commit 结束。</p></li><li><p><strong>Rollback</strong>在事务提交成功后不会修改数据库的内容。但对create drop select无效（没有意义）。值得注意的是，事务回滚<strong>rollback</strong>后，自增id依然自增，因为innodb的auto_increament的计数器记录的当前值是保存在内存中的，并不是存在于磁盘上，当mysql server处于运行的时候，这个计数值只会随着insert增长，不会随着delete而减少。而当mysql server启动时，当我们需要去查询auto_increment计数值时，mysql便会自动执行：SELECT MAX(id) FROM 表名 FOR UPDATE;语句来获得当前auto_increment列的最大值，然后将这个值放到auto_increment计数器中。所以就算Rollback MySQL的auto_increament计数器也不会作负运算。</p></li><li><p>commit会修改数据库内容。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 事务的隐式定义</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    name <span class="operator">=</span> <span class="string">&#x27;lily_1&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ID <span class="operator">=</span> <span class="string">&#x27;00121&#x27;</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 事务的显式定义</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    name <span class="operator">=</span> <span class="string">&#x27;lily_1&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    ID <span class="operator">=</span> <span class="string">&#x27;00123&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"># 提交事务或者撤销事务</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 也可以使用<span class="keyword">set</span>命令</span><br><span class="line"># 禁止自动提交</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"># 允许自动提交</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure><h3 id="事务的四个特性（ACID）"><a href="#事务的四个特性（ACID）" class="headerlink" title="事务的四个特性（ACID）"></a>事务的四个特性（ACID）</h3><ul><li><p><strong>A原子性</strong>：事务在逻辑上是不可分割的操作单元。要么所有操作提交成功，要么全部失败回滚。</p></li><li><p><strong>C一致性</strong>：所有的事务对一个数据的读取结果都是相同的。</p></li><li><p><strong>I隔离性</strong>：事务所做的修改在提交前，对其他事务是不可见的。(并发执行的事务之间不能相互影响)</p></li><li><p><strong>D持久性</strong>：一旦事务提交成功，对数据的修改是永久性的。</p></li></ul><h2 id="并发一致性的问题"><a href="#并发一致性的问题" class="headerlink" title="并发一致性的问题"></a>并发一致性的问题</h2><ul><li><p><strong>丢失修改（脏写）：</strong>一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。</p></li><li><p><strong>脏读：</strong>多个事务操作时。一个事务A读取了被另一个事务B修改、但未提交的数据，然后用这个数据做了业务处理后B突然回滚了这个数据。</p></li><li><p><strong>不可重复读：</strong>在同一个事务中（还没提交），某查询操作在一个时间读取一行数据和之后一个时间读取该行数据，发现数据已经发生修改。</p></li><li><p><strong>幻读：</strong>当事务在查询多次执行时，由于其他事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集。（数据条数不同）</p></li><li><p><strong>产生并发不一致问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制（事务隔离机制、MVCC 多版本隔离机制、锁机制）来保证隔离性。</strong></p></li></ul><h3 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h3><ul><li>未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202051431216.png" alt="image-20220205143158952"></p><p>Serializable（序列化）</p><p><strong>Oracle</strong> 默认的事务隔离级别是<strong>提交读</strong>,在此级别下，通过多版本的控制<strong>解决了幻读和不可</strong></p><p><strong>重复读</strong>。<strong>Mysql</strong> 显然没有，但可以通过在数据库中设置<strong>乐观锁</strong>字段或使用<strong>悲观锁</strong>来控制数</p><p>据一致性。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h4><p>认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修</p><p>改数据；应用于数据更新比较频繁的场景。</p><p><strong>悲观锁的实现方式：</strong>select … for update</p><h4 id="悲观锁的拓展内容"><a href="#悲观锁的拓展内容" class="headerlink" title="悲观锁的拓展内容"></a>悲观锁的拓展内容</h4><ul><li>需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for  update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status  from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。</li></ul><ul><li><p><strong>MySQL select…for update的Row Lock与Table Lock</strong></p><p>上面我们提到，使用select…for  update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level  Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table  Lock (将整个数据表单给锁住)。</p></li></ul><p><a href="https://www.cnblogs.com/wxgblogs/p/6849064.html">https://www.cnblogs.com/wxgblogs/p/6849064.html</a></p><h4 id="常见的悲观锁类型"><a href="#常见的悲观锁类型" class="headerlink" title="常见的悲观锁类型"></a>常见的悲观锁类型</h4><p><strong>排它锁 / X 锁：</strong>事务对数据加上 X 锁时，只允许此事务读取和修改此数据，其他事务不能对该数据加任何锁（select…for update）</p><p><strong>共享锁 / S 锁：</strong>加了 S 锁后，该事务只能对数据进行读取而不能修改，其他事务只能加 S 锁，不能加 X 锁（select…lock in share mode）</p><p><strong>意向锁：（表级锁）</strong></p><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；</p><p>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</p><p><strong>IS/IX 锁之间都是兼容的</strong></p><p><strong>好处：</strong>如果一个事务想要对整个表加 X 锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在 IX/IS/X/S锁就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202051624136.png" alt="image-20220205162448077"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。</p><p><strong>乐观锁的实现方式：</strong>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p><strong>一级封锁协议：</strong>事务在修改数据之前必须先对其加 X 锁，直到<strong>事务结束</strong>才释放。可以解决<strong>丢失修改</strong>问题（两个事务不能同时对一个数据加 X 锁，避免了修改被覆盖）；</p><p><strong>二级封锁协议：</strong>在一级的基础上，事务在读取数据之前必须先加 S 锁，<strong>读完后释放</strong>。可以</p><p>解决<strong>脏读</strong>问题（如果已经有事务在修改数据，就意味着已经加了 X 锁，此时想要读取数据的</p><p>事务并不能加 S 锁，也就无法进行读取，避免了读取脏数据）；</p><p><strong>三级封锁协议：</strong>在二级的基础上，事务在读取数据之前必须先加 S 锁，直到<strong>事务结束</strong>才能</p><p>释放。可以解决<strong>不可重复读</strong>问题（避免了在事务结束前其它事务对数据加 X 锁进行修改，保</p><p>证了事务期间数据不会被其它事务更新）</p><h3 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h3><p>MVCC 在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。</p><p><strong>创建版本号：</strong>创建一个数据行时的事务版本号（<strong>事务版本号：</strong>事务开始时的系统版本号；</p><p><strong>系统版本号：</strong>每开始一个新的事务，系统版本号就会自动递增）；<strong>删除版本号：</strong>删除操作时</p><p>的事务版本号；</p><p>各种操作：</p><p><strong>插入</strong>操作时，记录创建版本号；</p><p><strong>删除</strong>操作时，记录删除版本号；</p><p><strong>更新</strong>操作时，先记录删除版本号，再新增一行记录创建版本号；</p><p><strong>查询</strong>操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，</p><p>未提交读无需使用 MVCC</p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>是指所有的事务必须分两个阶段对数据项加锁和解锁。即<code>事务分两个阶段</code>，第一个阶段是<code>获得封锁</code>。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是<code>释放封锁</code>，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p><p>第一阶段是获得封锁的阶段，称为<code>扩展阶段</code>：其实也就是该阶段可以进入加锁操作，<code>在对任何数据进行读操作之前要申请获得S锁</code>，<code>在进行写操作之前要申请并获得X锁</code>，<code>加锁不成功，则事务进入等待状态</code>，直到加锁成功才继续执行。就是<code>加锁后就不能解锁</code>了。</p><p>第二阶段是释放封锁的阶段，称为<code>收缩阶段</code>：当事务释放一个封锁后，事务进入封锁阶段，在该阶段<code>只能进行解锁而不能再进行加锁操作</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202052232643.png" alt="image-20220205223230545"></p><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><h3 id="第一范式（1NF，Normal-Form）"><a href="#第一范式（1NF，Normal-Form）" class="headerlink" title="第一范式（1NF，Normal Form）"></a><strong>第一范式（1NF，Normal Form）</strong></h3><p><strong>属性不应该是可分的。</strong></p><p>如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。第一范式的合理遵循需要根据系统的实际需求来定。</p><p>eg：学生（学号，姓名，性别，出生年月日），如果业务需要最后一列再分成（出生年，出生月，出生日），它就不是一范式了。</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a><strong>第二范式（2NF）</strong></h3><p>每个非主属性完全依赖于主属性集（候选键集）</p><p>对记录的**<code>唯一性</code><strong>，要求记录有唯一标识，即实体的唯一性，即</strong>不存在部分依赖**；</p><p><strong>B 完全依赖于 A，就是说 A 中的所有属性唯一决定 B，属性少了就不能唯一决定，属性多了</strong></p><p><strong>则有冗余（叫部分依赖不叫完全依赖）。</strong></p><p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主</p><p>要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以</p><p>把多种数据保存在同一张数据库表中。</p><p><strong>主属性集/候选码集：</strong>某一组属性能够唯一确定其它的属性（主键就是从候选键集中选</p><p>的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属</p><p>性成为非主属性；</p><p>eg：</p><blockquote><p>表：学号、课程号、姓名、学分;</p></blockquote><p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里<strong>学分依赖课程号</strong>，<strong>姓名依赖与学号</strong>，所以不符合二范式。</p><p><strong>正确做法:</strong><br>学生：<code>Student</code>(学号, 姓名)；<br>课程：<code>Course</code>(课程号, 学分)；<br>选课关系：<code>StudentCourse</code>(学号, 课程号, 成绩)。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a><strong>第三范式（3NF）</strong></h3><p><strong>在 2NF 的基础上，非主属性不传递依赖于主属性。</strong></p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p><strong>传递依赖：如果 C 依赖于 B，B 依赖于 A，那么 C 传递依赖于 A；</strong></p><p>eg：</p><blockquote><p>表: 学号, 姓名, 年龄, 学院名称, 学院电话</p></blockquote><p>因为存在<strong>依赖传递</strong>: (学号) → (学生)→(所在学院) → (学院电话) 。这样学院电话可能就会成为重复的冗余信息。</p><p><strong>正确做法：</strong></p><p>学生：(学号, 姓名, 年龄, 所在学院)； </p><p>学院：(学院, 电话)。</p><h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><p><strong>一般说来，数据库只需满足第三范式（<code>3NF</code>）就行了。</strong></p><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，**<code>达到以空间换时间的目的</code>**。</p><p>〖例〗：如订单表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p><h2 id="UNION和UNION-ALL"><a href="#UNION和UNION-ALL" class="headerlink" title="UNION和UNION ALL"></a>UNION和UNION ALL</h2><p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p><p>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p><a href="https://www.cnblogs.com/canger/p/9760217.html%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C">https://www.cnblogs.com/canger/p/9760217.html数据库详细操作</a></p><h2 id="存储过程（procedure）"><a href="#存储过程（procedure）" class="headerlink" title="存储过程（procedure）"></a>存储过程（procedure）</h2><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。</p><h3 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h3><ul><li>函数有1个返回值,而存储过程是通过参数返回的,可以有多个或者没有</li><li>函数一般情况下是用来计算并返回一个计算结果；存储过程一般是用来完成特定的数据操作（比如修改、插入数据库表或执行某些DDL语句等等)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202051958770.png" alt="image-20220205195856716"></p><h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3><h4 id="in参数例子"><a href="#in参数例子" class="headerlink" title="in参数例子"></a>in参数例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //  # 声明//为分割符</span><br><span class="line">CREATE PROCEDURE demo_in_parameter(IN p_in int)  </span><br><span class="line">    BEGIN   </span><br><span class="line">    SELECT p_in;   </span><br><span class="line">    SET p_in=2;   </span><br><span class="line">    SELECT p_in;   </span><br><span class="line">    END//  </span><br><span class="line">DELIMITER ;  #结束声明//为分割符</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  mysql &gt; <span class="variable constant_">SET</span> <span class="variable">@p_in</span>=<span class="number">1</span>;  </span><br><span class="line"><span class="number">2</span>.  mysql &gt; <span class="variable constant_">CALL</span> demo_in_parameter(<span class="variable">@p_in</span>);  </span><br><span class="line"><span class="number">3</span>.  +------+  </span><br><span class="line"><span class="number">4</span>.  |<span class="params"> p_in </span>|  </span><br><span class="line"><span class="number">5</span>.  +------+  </span><br><span class="line"><span class="number">6</span>.  |<span class="params">   1  </span>|   </span><br><span class="line"><span class="number">7</span>.  +------+  </span><br><span class="line"><span class="number">8</span>.   </span><br><span class="line"><span class="number">9</span>.  +------+  </span><br><span class="line"><span class="number">10</span>. |<span class="params"> p_in </span>|  </span><br><span class="line"><span class="number">11</span>. +------+  </span><br><span class="line"><span class="number">12</span>. |<span class="params">   2  </span>|   </span><br><span class="line"><span class="number">13</span>. +------+  </span><br><span class="line"><span class="number">14</span>. </span><br><span class="line"><span class="number">15</span>.mysql&gt; <span class="variable constant_">SELECT</span> <span class="variable">@p_in</span>;  </span><br><span class="line"><span class="number">16</span>.+-------+  </span><br><span class="line"><span class="number">17</span>.|<span class="params"> @p_in </span>|  </span><br><span class="line"><span class="number">18</span>.+-------+  </span><br><span class="line"><span class="number">19</span>.|<span class="params">  1    </span>|  </span><br><span class="line"><span class="number">20</span>.+-------+  </span><br></pre></td></tr></table></figure><p>以上可以看出，<code>p_in</code>虽然在存储过程中被修改，但并不影响<code>@p_in</code>的值</p><h4 id="out参数例子"><a href="#out参数例子" class="headerlink" title="out参数例子"></a>out参数例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //  </span><br><span class="line">CREATE PROCEDURE demo_out_parameter(OUT p_out int)  </span><br><span class="line">    BEGIN </span><br><span class="line">    SELECT p_out;  </span><br><span class="line">    SET p_out=</span><br><span class="line">    SELECT p_out;  </span><br><span class="line">    END //  </span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  mysql &gt; <span class="variable constant_">SET</span> <span class="variable">@p_out</span>=<span class="number">1</span>;  </span><br><span class="line"><span class="number">2</span>.  mysql &gt; <span class="variable constant_">CALL</span> sp_demo_out_parameter(<span class="variable">@p_out</span>);  </span><br><span class="line"><span class="number">3</span>.  +-------+  </span><br><span class="line"><span class="number">4</span>.  |<span class="params"> p_out </span>|   </span><br><span class="line"><span class="number">5</span>.  +-------+  </span><br><span class="line"><span class="number">6</span>.  |<span class="params"> NULL  </span>|   </span><br><span class="line"><span class="number">7</span>.  +-------+  </span><br><span class="line"><span class="number">8</span>.   </span><br><span class="line"><span class="number">9</span>.  +-------+  </span><br><span class="line"><span class="number">10</span>. |<span class="params"> p_out </span>|  </span><br><span class="line"><span class="number">11</span>. +-------+  </span><br><span class="line"><span class="number">12</span>. |<span class="params">   2   </span>|   </span><br><span class="line"><span class="number">13</span>. +-------+  </span><br><span class="line"><span class="number">14</span>. </span><br><span class="line"><span class="number">15</span>.mysql&gt; <span class="variable constant_">SELECT</span> <span class="variable">@p_out</span>;  </span><br><span class="line"><span class="number">16</span>.+-------+  </span><br><span class="line"><span class="number">17</span>.|<span class="params"> p_out </span>|  </span><br><span class="line"><span class="number">18</span>.+-------+  </span><br><span class="line"><span class="number">19</span>.|<span class="params">   2   </span>|  </span><br><span class="line"><span class="number">20</span>.+-------+  </span><br></pre></td></tr></table></figure><h4 id="INOUT参数例子"><a href="#INOUT参数例子" class="headerlink" title="INOUT参数例子"></a>INOUT参数例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //   </span><br><span class="line">CREATE PROCEDURE demo_inout_parameter(INOUT p_inout int)   </span><br><span class="line">BEGIN </span><br><span class="line">    SELECT p_inout;  </span><br><span class="line">    SET p_inout=2;  </span><br><span class="line">    SELECT p_inout;   </span><br><span class="line"> END //   </span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  mysql &gt; <span class="variable constant_">SET</span> <span class="variable">@p_inout</span>=<span class="number">1</span>;  </span><br><span class="line"><span class="number">2</span>.  mysql &gt; <span class="variable constant_">CALL</span> demo_inout_parameter(<span class="variable">@p_inout</span>) ;  </span><br><span class="line"><span class="number">3</span>.  +---------+  </span><br><span class="line"><span class="number">4</span>.  |<span class="params"> p_inout </span>|  </span><br><span class="line"><span class="number">5</span>.  +---------+  </span><br><span class="line"><span class="number">6</span>.  |<span class="params">    1    </span>|  </span><br><span class="line"><span class="number">7</span>.  +---------+  </span><br><span class="line"><span class="number">8</span>.   </span><br><span class="line"><span class="number">9</span>.  +---------+  </span><br><span class="line"><span class="number">10</span>. |<span class="params"> p_inout </span>|   </span><br><span class="line"><span class="number">11</span>. +---------+  </span><br><span class="line"><span class="number">12</span>. |<span class="params">    2    </span>|  </span><br><span class="line"><span class="number">13</span>. +---------+  </span><br><span class="line"><span class="number">14</span>. </span><br><span class="line"><span class="number">15</span>.mysql &gt; <span class="variable constant_">SELECT</span> <span class="variable">@p_inout</span>;  </span><br><span class="line"><span class="number">16</span>.+----------+  </span><br><span class="line"><span class="number">17</span>.|<span class="params"> @p_inout </span>|   </span><br><span class="line"><span class="number">18</span>.+----------+  </span><br><span class="line"><span class="number">19</span>.|<span class="params">    2     </span>|  </span><br><span class="line"><span class="number">20</span>.+----------+ </span><br></pre></td></tr></table></figure><h3 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>预先编译，</strong>而不需要每次运行时编译，<strong>提高了数据库执行效率；</strong></li></ul><p>封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行 SQL 语句，可以<strong>减少网络通信量；</strong></p><ul><li><p><strong>具有可复用性，</strong>减少了数据库开发的工作量；</p></li><li><p><strong>安全性高，</strong>可以让没有权限的用户通过存储过程间接操作数据库；</p></li><li><p><strong>更易于维护</strong></p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><p><strong>可移植性差，</strong>存储过程将应用程序绑定到了数据库上；（本来应该由程序做的事情交给数据库去做）</p><p><strong>开发调试复杂，</strong>没有好的 IDE；</p><p><strong>修改复杂，</strong>需要重新编译，有时还需要更新程序中的代码以更新调用</p><p>小型程序完全无用。对于小型web应用来说，它的使用价值就更小了，反而会拖累开发进度。</p><h2 id="like：模糊查询"><a href="#like：模糊查询" class="headerlink" title="like：模糊查询"></a>like：模糊查询</h2><ul><li><p>%：表示任意 0 个或多个字符</p></li><li><p>like：模糊查询</p></li><li><p>_：代表单个字符</p></li><li><p>like不区分大小写，如果需要区分加入BINARY</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202052110054.png" alt="image-20220205210921307"></p></li><li><p>‘%’通配符可以到匹配任意字符，但是不能匹配 NULL。也就是说 “%”匹配不到 tb_students_info 数据表中值为 NULL 的记录。</p></li><li><p>如果查询内容中包含通配符，可以使用“\”转义符</p></li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于<strong>保证数据完整性</strong>（比如可以检验或转换数据）。</p><h2 id="索引失效的情况？"><a href="#索引失效的情况？" class="headerlink" title="索引失效的情况？"></a>索引失效的情况？</h2><ul><li><p>以“%”开头的 LIKE 语句； </p></li><li><p>OR 语句前后没有同时使用索引；</p></li><li><p>数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）；</p></li><li><p>对于组合索引，必须满足 最左匹配原则/最左前缀原则 (最左优先，eg：多列索引 col1、col2 和 col3，则 索引生效的情形包括 col1 或 col1，col2 或 col1，col2，col3)；</p></li><li><p>如果 MySQL 估计全表扫描比索引快，则不使用索引（比如非常小的表）</p></li><li><p>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p></li></ul><h2 id="在哪些地方适合创建索引？"><a href="#在哪些地方适合创建索引？" class="headerlink" title="在哪些地方适合创建索引？"></a>在哪些地方适合创建索引？</h2><ul><li><p>主键和外键（连接两张表的列）上</p></li><li><p>某列经常作为最大最小值；</p></li><li><p>经常被查询的字段；</p></li><li><p>经常出现在 ORDER BY/GROUP BY/DISDINCT 后面的字段</p></li></ul><h2 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h2><ul><li><p>只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次 IO 操作获取的数据越大效率越高）；</p></li><li><p>建立索引的字段应该非空，在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用 0、一个特殊的值或者一个空串代替 NULL；</p></li><li><p>选择数据密度大（唯一值占总数的百分比很大）的字段作索引</p></li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061447738.png" alt="image-20220206144712368"></p><p>一般mysql主键上的就是聚集索引</p><h3 id="⚠️聚集索引比起非聚集索引的优缺点"><a href="#⚠️聚集索引比起非聚集索引的优缺点" class="headerlink" title="⚠️聚集索引比起非聚集索引的优缺点"></a>⚠️聚集索引比起非聚集索引的优缺点</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</li><li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li><li>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。</li><li>非聚集索引:物理存储不按照索引排序；非聚集索引就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。</li><li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚集索引：索引的叶节点就是数据节点。而非聚集索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li><li>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入），查询数据比非聚集数据的速度快。</li></ul><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>应</td><td>应</td></tr><tr><td>返回某范围内的数据</td><td>应</td><td>不应</td></tr><tr><td>一个或极少不同值</td><td>不应</td><td>不应</td></tr><tr><td>小数目的不同值</td><td>应</td><td>不应</td></tr><tr><td>大数目的不同值</td><td>不应</td><td>应</td></tr><tr><td>频繁更新的列</td><td>不应</td><td>应</td></tr><tr><td>外键列</td><td>应</td><td>应</td></tr><tr><td>主键列</td><td>应</td><td>应</td></tr><tr><td>频繁修改索引列</td><td>不应</td><td>应</td></tr></tbody></table><h3 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h3><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a><strong>稠密索引</strong></h4><p>数据库中的每个搜索键值都有一个索引记录。这样可以加快搜索速度，但需要更多空间来存储索引记录本身。索引记录包含搜索键值和指向磁盘上实际记录的指针。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061622257.png" alt="image-20220206162245117"></p><h4 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a><strong>稀疏索引</strong></h4><p>  在稀疏索引中，不会为每个搜索关键字创建索引记录。要搜索记录，我们首先按索引记录进行操作，然后到达数据的实际位置。如果索引里没有，那么系统将开始顺序搜索，直到找到所需的数据为止。</p><ul><li>只有当关系按搜索码排列顺序存储时才能使用稀疏索引，换句话说也就是只有索引是聚集索引时才能使用稀疏索引。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061622766.png" alt="image-20220206162257646"></p><h3 id="关于组合索引"><a href="#关于组合索引" class="headerlink" title="关于组合索引"></a>关于组合索引</h3><p>索引的底层是一颗 B+树，那么组合索引当然还是一颗 B+树，只不过组合索引的健值数量不是一个，而是多个。构建一颗 B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+树。</p><h2 id="索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>索引的优缺点，什么时候使用索引，什么时候不能使用索引</h2><p>索引最大的好处是提高查询速度，缺点是更新数据时效率低，因为要同时更新索引。</p><p>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。</p><h2 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h2><ul><li><p>二叉查找树：左节点的值小于根节点，右节点的值大于根节点。但有可能形成一条链。</p></li><li><p>红黑树：特殊的二叉查找树，每个节点有红黑两种颜色，根节点和叶子结点都是黑色。如果一个节点是红色的，则它的子节点必须是黑色的。从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p></li><li><p>平衡二叉树（AVL-tree）：所有子树高度之差的绝对值不超过1的二叉查找树，有效避免了成链的问题。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061506221.png" alt="image-20220206150600066"></p><ul><li>B树：多叉的平衡树，节点大小也是左小右大，并且从左到右递增。假设$$N$$($N&gt;=2$)叉的B树，非叶子结点的字节点数$&gt;1且&lt;=N$ 枝节点的关键字数量大于等于$ceil(m/2)-1$个且小于等于$M-1$个</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061513430.png" alt="image-20220206151309322"></p><h2 id="数据库索引的实现原理（B-树）"><a href="#数据库索引的实现原理（B-树）" class="headerlink" title="数据库索引的实现原理（B+树）"></a>数据库索引的实现原理（B+树）</h2><ul><li><p>B+树：B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。<strong>B+树的非叶子节点只存索引</strong>，所以同样大小的磁盘页可以容纳更多的节点元素，所以数据量相同的情况下，<strong>B+树更矮胖，所以IO次数更少</strong>。</p><p><strong>B+树只有叶子节点才会存真正的数据</strong>，所以每次查找一定会找到叶子节点，但B树有可能只要找到中间节点就结束了，所以<strong>B+树的查找性能比B树更加稳定</strong>。</p><p>B树的范围查询需要繁琐的中序遍历，但B+树的叶子节点是用链表相连的，所以只需要遍历链表即可。<strong>B+树自带排序功能，范围查询简单。</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061550202.png" alt="image-20220206155018079"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202061546347.png" alt="image-20220206154659245"></p><h2 id="列举几种表连接方式"><a href="#列举几种表连接方式" class="headerlink" title="列举几种表连接方式"></a>列举几种表连接方式</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202052325855.png" alt="image-20220205232521723"></p><ul><li>内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集<ul><li>自然连接：显示属性相同的列，去除重复的属性</li><li>等值连接：所有属性相同的列都显示，包括重复的</li></ul></li><li>外连接（Outer Join）<ul><li>左连接：左边表的所有数据（整个表）都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；</li><li>右连接：和左连接相反；</li><li>全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据</li></ul></li><li>交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）</li></ul><h2 id="什么是视图？什么是游标？"><a href="#什么是视图？什么是游标？" class="headerlink" title="什么是视图？什么是游标？"></a>什么是视图？什么是游标？</h2><ul><li><p>视图：从数据库的基本表中通过查询选取出来的数据组成的</p><p>虚拟表</p><p>（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：</p><ul><li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>；</li><li><strong>简化</strong>复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；</li></ul></li><li><p>游标（Cursor）：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。</p></li></ul><h2 id="关于having"><a href="#关于having" class="headerlink" title="关于having"></a>关于having</h2><p>where、聚合函数、having 在from后面的执行顺序：where&gt;聚合函数(sum,min,max,avg,count)&gt;having</p><p>若须引入聚合函数来对group by 结果进行过滤 则只能用having。（ 是先执行聚合函数还是先过滤 然后比对我上面列出的执行顺序 一看便知）<br>HAVING语句通常与GROUP BY语句联合使用，用来过滤由GROUP BY语句返回的记录集。<br>HAVING语句的存在弥补了WHERE关键字不能与聚合函数联合使用的不足。<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, … column_n, aggregate_function (expression)</span><br><span class="line">FROM tables</span><br><span class="line">WHERE predicates</span><br><span class="line">GROUP BY column1, column2, … column_n</span><br><span class="line">HAVING condition1 … condition_n;</span><br></pre></td></tr></table></figure><p>如果想查询平均分高于80分的学生记录可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, COUNT(course) as numcourse, AVG(score) as avgscore</span><br><span class="line">FROM student</span><br><span class="line">GROUP BY id</span><br><span class="line">HAVING AVG(score)&gt;=80;</span><br></pre></td></tr></table></figure><p>在这里，如果用WHERE代替HAVING就会出错。</p><h3 id="注意事项-："><a href="#注意事项-：" class="headerlink" title="注意事项 ："></a>注意事项 ：</h3><p>1、where 后不能跟聚合函数，因为where执行顺序大于聚合函数。<br>2、where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>3、having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p><h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><p><strong>(1)from</strong> </p><p><strong>(2) join</strong></p><p><strong>(3) on</strong> </p><p><strong>(4) where</strong> </p><p><strong>(5)group by</strong></p><p><strong>(6) avg,sum…. （组函数）</strong></p><p><strong>(7)with rollup/cube</strong>（rollup和cube的区别：若group by x,y，rollup会算每个x的total和总的total，cube则会算出每个x的total，每个y的total和总的total，如果group by中有n列，rollup会计算n种组合，那cube就会计算$2^{n}-1$种组合。<a href="https://blog.csdn.net/shenqingkeji/article/details/52860843">详细说明</a>）</p><p><strong>(8)having</strong> </p><p><strong>(9) select</strong> </p><p><strong>(10) distinct</strong> </p><p><strong>(11) order by</strong></p><p><strong>(12) LIMIT/OFFSET</strong> </p><p>每一步生成一个虚拟表然后将这个虚拟表交给下一步去操作。（order by生成的是游标，所以order by子句的查询不能用于表达式）</p><h2 id="MySQL-的两种存储引擎-InnoDB-和-MyISAM-的区别"><a href="#MySQL-的两种存储引擎-InnoDB-和-MyISAM-的区别" class="headerlink" title="MySQL 的两种存储引擎 InnoDB 和 MyISAM 的区别"></a>MySQL 的两种存储引擎 InnoDB 和 MyISAM 的区别</h2><ul><li><p>InnoDB 支持事务，可以进行 Commit 和 Rollback；</p></li><li><p>MyISAM 只支持<strong>表级锁</strong>，而 InnoDB 还支持<strong>行级锁</strong>，提高了并发操作的性能；</p></li><li><p>InnoDB 支持<strong>外键</strong>；</p></li><li><p>MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢；</p></li><li><p>MyISAM 支持压缩表和空间数据索引，InnoDB <strong>需要更多的内存和存储</strong>；</p></li><li><p>InnoDB 支持<strong>热备份</strong></p></li></ul><h3 id="索引的区别"><a href="#索引的区别" class="headerlink" title="索引的区别"></a>索引的区别</h3><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>不管是主键索引、唯一键索引或者普通索引，其索引都属于稀疏索引</li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li>若一个主键被定义，该主键则作为密集索引</li><li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li><li>若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）</li><li>非主键索引（稀疏索引）存储相关键位和它对应的主键值，包含两次查找</li></ul><h3 id="热备份和冷备份"><a href="#热备份和冷备份" class="headerlink" title="热备份和冷备份"></a>热备份和冷备份</h3><p><strong>热备份：</strong>在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错</p><p><strong>冷备份：</strong>数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>MyISAM 管理非事务表。它提供高速存储和检索（MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的 SELECT），还是可以使用 MyISAM；</li><li>InnoDB 支持事务，并发情况下有很好的性能，基本可以替代 MyISAM</li></ul><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><h3 id="ifnull函数"><a href="#ifnull函数" class="headerlink" title="ifnull函数"></a>ifnull函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(expression, alt_value)</span><br></pre></td></tr></table></figure><p>如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。</p><h3 id="LIMIT-和OFFSET"><a href="#LIMIT-和OFFSET" class="headerlink" title="LIMIT 和OFFSET"></a>LIMIT 和OFFSET</h3><blockquote><p>使用limit 可以实现分页比如</p><p>limit 0,5 是从1到5条，</p><p>limit 5，3 是从,6到8条，</p><p>使用limit offset 时</p><p>limit 5 offset 0 从 1 到5 条</p><p>limit 5 offset 5 从 6 到10 条</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LEETCODE问题集</title>
      <link href="/2022/02/25/LEETCODE%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>/2022/02/25/LEETCODE%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找</p><p>把问题转换为找两个数组中第k大的数，当n+m为奇数，中位数是两个数组中第$(m+n+1)/2$个元素，当n+m为偶数，中位数是第$(m+n)/2$和$(m+n)/2+1$个数的平均数。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203012113696.png"></p><p>实现比较恶心，每个数组分别定义一个偏移量offs1和offs2，令<code>mid1=offs1+k/2-1,mid2=offs2+k/2-1</code>每次比较<code>a[mid1]</code>和<code>b[mid2]</code>，根据上面的思路，<code>a[mid1]&gt;=b[mid2]</code>那<code>mid1及以前的数字</code>都可被排除了，<code>偏移量offset1+=k/2</code>(因为包括<code>a[mid1]</code>所以是<code>k/2-1+1</code>)。因为现在已经排除了<code>k/2</code>个数字，<code>k-=k/2</code>。反之亦然。</p><p>现在还有一个需要考虑的就是边界情况，有可能<code>offs1+k/2-1</code>已经超过数组范围，所以要和数组长度<code>n</code>取一个<code>min</code>，同理在更新<code>offs1</code>和<code>k</code>的时候也要取<code>min</code>，因为如果<code>mid1</code>超过数组范围的话可以排除的数的个数就不是<code>k/2</code>个，而是<code>n</code>个。我们知道当<code>k==1</code>时答案就是此时<code>a[offs1],b[offs2]</code>的最小值。因为到这一步意味着我们已经排除了<code>k-1</code>个数字，只差最后一个就能找到第k大的元素。但如果k还没到1就有一边数组超出边界了呢？如果a数组二分到头了，那就直接返回<code>b[offs2+k-1]</code>就是答案了。考虑a数组为空的情况，<code>offs2=0</code>，就相当于直接找<code>b[k-1]</code>（下标从0开始）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k,vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> offs1=<span class="number">0</span>,offs2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid1,mid2;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//cout&lt;&lt;offs1&lt;&lt;&#x27; &#x27;&lt;&lt;offs2&lt;&lt;&#x27; &#x27;&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;mid1&lt;&lt;&#x27; &#x27;&lt;&lt;mid2&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            <span class="keyword">if</span>(offs1&gt;=n)<span class="keyword">return</span> nums2[offs2+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(offs2&gt;=m)<span class="keyword">return</span> nums1[offs1+k<span class="number">-1</span>];      </span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">min</span>(nums1[offs1],nums2[offs2]);</span><br><span class="line">            mid1=<span class="built_in">min</span>(offs1+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>),mid2=<span class="built_in">min</span>(offs2+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums1[mid1]&lt;=nums2[mid2])&#123;</span><br><span class="line">                offs1+=<span class="built_in">min</span>(k/<span class="number">2</span>,n);</span><br><span class="line">                k=k-<span class="built_in">min</span>(k/<span class="number">2</span>,n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                offs2+=<span class="built_in">min</span>(k/<span class="number">2</span>,m);  </span><br><span class="line">                k=k-<span class="built_in">min</span>(k/<span class="number">2</span>,m);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans,k;</span><br><span class="line">        n=nums1.<span class="built_in">size</span>(),m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">check</span>((n+m+<span class="number">1</span>)/<span class="number">2</span>,nums1,nums2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">double</span>(<span class="built_in">check</span>((n+m)/<span class="number">2</span>,nums1,nums2))+<span class="built_in">double</span>(<span class="built_in">check</span>((n+m)/<span class="number">2</span>+<span class="number">1</span>,nums1,nums2)))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">double</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>$f[i][j]$表示s的前i个字符和p的前j个字符匹配情况。</p></li><li><p>$p[j]!=’*’$</p><ul><li>$f[i][j]=f[i-1][j-1]&amp;&amp;(s[i]==p[j]||p[j]==’.’)$</li><li>当$i,j$前面的都相等，并且当前$s[i]=p[j]$或者$p[j]$为’.’说明$f[i][j]=true$</li></ul></li><li><p>$p[j]==’*’$</p><ul><li>$f[i][j]=f[i][j-2]||f[i-1][j-2]&amp;&amp;s[i]==p[j]||f[i-2][j-2]&amp;&amp;s[i]==p[j]&amp;&amp;s[i-1]==p[j]$</li><li>‘*’可以代表多个字符，第一项意味着*前面的字符有0个(相当于*和前面的字符共两个字符一起消去了所以是$f[i][j-2]$)，第二项是*可以代表一个它前面的字符，以此类推。</li></ul></li><li><p>但遍历一遍*的可能情况是$O(n)$的，考虑优化。</p><ul><li>$f[i][j]=f[i][j-2]||f[i-1][j-2]&amp;&amp;s[i]==p[j-1]||f[i-2][j-2]&amp;&amp;s[i]==p[j-1]&amp;&amp;s[i-1]==p[j-1]$</li><li>$f[i-1][j]=f[i-1][j-2]||f[i-2][j-2]&amp;&amp;s[i-1]==p[j-1]||f[i-3][j-2]&amp;&amp;s[i-1]==p[j-1]&amp;&amp;s[i-2]==p[j-1]$</li><li>综上可得$f[i][j]=f[i][j-2]||f[i-1][j]&amp;&amp;(s[i]==p[j-1])$,只需要保留上一层循环的结果即可。时间复杂度$O(1)$,(这里为什么是$p[j-1]$是因为$p[j]$是’*’)</li><li>类似于完全背包的优化方案</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">char</span> a,<span class="type">char</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b||b==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> dp[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=p.<span class="built_in">length</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//空串可以和空串匹配</span></span><br><span class="line">        s=<span class="string">&quot; &quot;</span>+s,p=<span class="string">&quot; &quot;</span>+p;<span class="comment">//下标从1开始方便计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;<span class="comment">//j从1开始，因为j=0意味着p是空串，空串一定不会和s匹配，所以j=0没有意义</span></span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=m&amp;&amp;p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)<span class="keyword">continue</span>;<span class="comment">//如果这个字符后一个是*直接跳过它</span></span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;p[j]!=<span class="string">&#x27;*&#x27;</span>)&#123;<span class="comment">//因为i是从0开始的，所以要i大于1才能进行这一步</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&amp;&amp;<span class="built_in">judge</span>(s[i],p[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j]==<span class="string">&#x27;*&#x27;</span>)&#123;<span class="comment">//这里对i的判断写在了里面，是因为当i=0的时候同样要进行dp[i][j]=dp[i][j-2]的转移（当p可以匹配空串时）</span></span><br><span class="line">                    dp[i][j]=dp[i][j<span class="number">-2</span>]||i&amp;&amp;dp[i<span class="number">-1</span>][j]&amp;&amp;<span class="built_in">judge</span>(s[i],p[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,(r-l)*<span class="built_in">min</span>(h[l],h[r]));</span><br><span class="line">            <span class="keyword">if</span>(h[l]&lt;=h[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt;v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string path,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;n||r&gt;n||r&gt;l)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==n&amp;&amp;r==n)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(path+<span class="string">&#x27;(&#x27;</span>,l+<span class="number">1</span>,r,n);</span><br><span class="line">        <span class="built_in">dfs</span>(path+<span class="string">&#x27;)&#x27;</span>,l,r+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203100958658.png" alt="image-20220310095806090"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123; <span class="string">&quot;()&quot;</span> &#125;;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">dp[<span class="number">1</span>] = &#123; <span class="string">&quot;()&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (string p : dp[j])</span><br><span class="line"><span class="keyword">for</span> (string q : dp[i - j - <span class="number">1</span>]) &#123;</span><br><span class="line">string str = <span class="string">&quot;(&quot;</span> + p + <span class="string">&quot;)&quot;</span> + q;</span><br><span class="line">dp[i].<span class="built_in">push_back</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251401401.png" alt="img"></p><p>栈里面存的是最后一个没有被匹配的括号的下标。</p><ul><li>如果是’(‘直接入栈。</li><li>是’)’如果栈内有元素就将栈顶弹出。弹出后栈空了说明该右括号失配</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="comment">//栈空了说明能匹配的都匹配完了还多出当前这个失配的右括号</span></span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                  <span class="comment">//存最后一个没有被匹配的&#x27;)&#x27;的下标。</span></span><br><span class="line">                    st.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,i-st.<span class="built_in">top</span>());<span class="comment">//取每一段的最大值</span></span><br><span class="line">              <span class="comment">//当前位置减去上一个失配的位置就是这一段有效括号序列的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>左指针和右指针分别从两端开始，维护一个lmax和rmax，分别代表左右两边当前的最高高度。注意如果$h[l]&lt;h[r]$移动左指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> lmax=<span class="number">0</span>,rmax=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(h[l]&lt;=h[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(lmax&gt;h[l])ans+=lmax-h[l];</span><br><span class="line">                lmax=<span class="built_in">max</span>(lmax,h[l]);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rmax&gt;h[r])ans+=rmax-h[r];</span><br><span class="line">                rmax=<span class="built_in">max</span>(rmax,h[r]);</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281121048.png" alt="截屏2022-02-28 11.21.09"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;h[i]&gt;h[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> t=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> l=st.<span class="built_in">top</span>();</span><br><span class="line">                ans+=(i-l<span class="number">-1</span>)*<span class="built_in">max</span>(<span class="number">0</span>,(<span class="built_in">min</span>(h[i],h[l])-h[t]));</span><br><span class="line">            &#125;<span class="comment">//这里和max取一个0是为了特判h[t]比min(h[i],h[l])大的情况</span></span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>螺旋矩阵2改一改，考虑一下行列不同的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector &lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m=a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> N=n,M=m;</span><br><span class="line">        n--;</span><br><span class="line">        m--;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= N * M) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= m; i++) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[c][i]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = c + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[i][m]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= c; i--) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[n][i]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; N * M)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= c + <span class="number">1</span>; i--) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[i][c]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202251328471.png" alt="image-20220225132826296" style="zoom: 25%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));<span class="comment">//静态vector</span></span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>,l=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;=n*n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=c;i&lt;=l;i++)&#123;</span><br><span class="line">                a[c][i]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=c+<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">                a[i][l]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=c;i--)&#123;</span><br><span class="line">                a[l][i]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=c+<span class="number">1</span>;i--)&#123;</span><br><span class="line">                a[i][c]=cnt;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            c++;</span><br><span class="line">            l--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84.柱状图中最大的矩形</a></h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172112336.png" alt="image-20240329172112336"></p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240329172149246.png" alt="image-20240329172149246"></p><p>详细解释：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/">https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/142012/bao-li-jie-fa-zhan-by-liweiwei1419/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);<span class="comment">//处理边界情况</span></span><br><span class="line">        <span class="type">int</span> n=heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i]&lt;heights[st.<span class="built_in">top</span>()])&#123;<span class="comment">//当前高度小于栈顶高度 说明以栈顶为高度的长方形的右边界找到了</span></span><br><span class="line">                <span class="type">int</span> h=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;=h)&#123;<span class="comment">//找右边界</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=i-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组遍历完了栈里还有剩的</span></span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> h=heights[st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[st.<span class="built_in">top</span>()]&gt;=h)&#123;<span class="comment">//找右边界</span></span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=n-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85.最大矩形"></a><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85.最大矩形</a></h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>给定一个<code>heights[i][j]</code>记录第<code>j</code>列连续的1的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0               1 0 1 0 0 </span><br><span class="line">1 0 1 1 1     --&gt;       2 0 2 1 1 </span><br><span class="line">1 1 1 1 1     --&gt;       3 1 3 2 2 </span><br><span class="line">1 0 0 1 0               4 0 0 3 0 </span><br></pre></td></tr></table></figure><p>有了<code>heights[i][j]</code>后就相当于对每一层<code>i</code>求柱状图中最大的矩形(上一题)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> heights[<span class="number">205</span>][<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(heights[i<span class="number">-1</span>][j])heights[i][j]=heights[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            heights[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        heights[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for(int j=0;j&lt;n;j++)&#123;</span></span><br><span class="line">            <span class="comment">//     cout&lt;&lt;heights[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][j]&lt;heights[i][st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    <span class="type">int</span> h=heights[i][st.<span class="built_in">top</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][st.<span class="built_in">top</span>()]&gt;=h)&#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> w=j-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> h=heights[i][st.<span class="built_in">top</span>()];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">top</span>()!=<span class="number">-1</span>&amp;&amp;heights[i][st.<span class="built_in">top</span>()]&gt;=h)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w=n-st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,h*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="88-合并两个有序数组-https-leetcode-cn-problems-merge-sorted-array-description"><a href="#88-合并两个有序数组-https-leetcode-cn-problems-merge-sorted-array-description" class="headerlink" title="[88.合并两个有序数组][https://leetcode.cn/problems/merge-sorted-array/description/]"></a>[88.合并两个有序数组][<a href="https://leetcode.cn/problems/merge-sorted-array/description/]">https://leetcode.cn/problems/merge-sorted-array/description/]</a></h2><ul><li>用双指针倒着插入可以不用多开一个数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=m<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> idx=m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)nums1=nums2;</span><br><span class="line">        <span class="keyword">while</span>(idx&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;=nums2[j])&#123;</span><br><span class="line">                    nums1[idx]=nums2[j];</span><br><span class="line">                    idx--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nums1[idx]=nums1[i];</span><br><span class="line">                    nums1[i]=<span class="number">0</span>;</span><br><span class="line">                    idx--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[idx]=nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[idx]=nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">                idx--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>对于这颗二叉树，可能的路径情况有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a</span><br><span class="line"> / \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure><ol><li>b + a + c</li><li>b + a + a 的父结点</li><li>a + c + a 的父结点</li></ol><p>把b节点思考成一坨左子树，c节点思考成一坨右子树。</p><p>如果b整体比0小那直接不用选了，c同理。</p><p>考虑从小往上递归。对于每一个节点，他都有可能作为一个”转折点”，或者作为一个单边继续向上递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxx=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;left));<span class="comment">//u的左子树，如果u的左子树比0还小那就直接不选了</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;right));<span class="comment">//u的右子树，如果u的右子树比0还小那就直接不选了</span></span><br><span class="line">            maxx=<span class="built_in">max</span>(maxx,u-&gt;val+l+r);<span class="comment">//选u作为那个&quot;转折点&quot;</span></span><br><span class="line">            <span class="keyword">return</span> u-&gt;val+<span class="built_in">max</span>(l,r);<span class="comment">// 返回经过u的&quot;单边&quot;最大分支给当前u的父节点计算使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LCR-153-二叉树中和为目标的值"><a href="#LCR-153-二叉树中和为目标的值" class="headerlink" title="LCR 153.二叉树中和为目标的值"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/description/">LCR 153.二叉树中和为目标的值</a></h2><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>&amp;&amp;sum==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,sum);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,sum);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathTarget</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和-1"><a href="#124-二叉树中的最大路径和-1" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>对于这颗二叉树，可能的路径情况有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a</span><br><span class="line"> / \</span><br><span class="line">b   c</span><br></pre></td></tr></table></figure><ol><li>b + a + c</li><li>b + a + a 的父结点</li><li>a + c + a 的父结点</li></ol><p>把b节点思考成一坨左子树，c节点思考成一坨右子树。</p><p>如果b整体比0小那直接不用选了，c同理。</p><p>考虑从小往上递归。对于每一个节点，他都有可能作为一个”转折点”，或者作为一个单边继续向上递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxx=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* u)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;left));<span class="comment">//u的左子树，如果u的左子树比0还小那就直接不选了</span></span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(u-&gt;right));<span class="comment">//u的右子树，如果u的右子树比0还小那就直接不选了</span></span><br><span class="line">            maxx=<span class="built_in">max</span>(maxx,u-&gt;val+l+r);<span class="comment">//选u作为那个&quot;转折点&quot;</span></span><br><span class="line">            <span class="keyword">return</span> u-&gt;val+<span class="built_in">max</span>(l,r);<span class="comment">// 返回经过u的&quot;单边&quot;最大分支给当前u的父节点计算使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236.二叉树的最近公共祖先</a></h2><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>用到了后序遍历的特点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>||root==p||root==q)<span class="keyword">return</span> root;<span class="comment">//只要当前根节点是p和q中的任意一个，就返回（因为不能比这个更深了，再深p和q中的一个就没了）</span></span><br><span class="line">        <span class="comment">//根节点不是p和q中的任意一个，那么就继续分别往左子树和右子树找p和q</span></span><br><span class="line">        TreeNode *l=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *r=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">nullptr</span>)<span class="keyword">return</span> r;<span class="comment">//左子树都找完了都没找到p和q,那p和q肯定都在右子树里</span></span><br><span class="line">        <span class="keyword">if</span>(r==<span class="literal">nullptr</span>)<span class="keyword">return</span> l;<span class="comment">//右子树都找完了都没找到p和q,那p和q肯定都在左子树里</span></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//p和q分别存在在左右子树中, 这时候root也搜到最近的公共父节点了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>事先存一个空节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *curr=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;<span class="comment">//当前节点的指针指向上一个元素</span></span><br><span class="line">            pre=head;<span class="comment">//更新上一个元素</span></span><br><span class="line">            head=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>$O(2*n)$</p><p>找到left的前一个节点，left节点，right的后一个节点，right节点。对left到right这一段链表进行反转操作，然后再接回去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//虚拟头节点</span></span><br><span class="line">        dnode-&gt;next=head;</span><br><span class="line">        ListNode *pre=dnode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l=pre;<span class="comment">//left的前一个节点</span></span><br><span class="line">        ListNode *r=pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//r:right的后一个节点</span></span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//st:left节点</span></span><br><span class="line">        ListNode *st=pre-&gt;next;</span><br><span class="line">        ListNode *ed=pre-&gt;next;</span><br><span class="line">        ListNode *last=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//null-&gt;2-&gt;3-&gt;4 ----&gt; null&lt;-2&lt;-3&lt;-4</span></span><br><span class="line">        <span class="keyword">while</span>(ed!=r)&#123;</span><br><span class="line">            ListNode *curr=ed-&gt;next;</span><br><span class="line">            ed-&gt;next=last;</span><br><span class="line">            last=ed;</span><br><span class="line">            ed=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//last:right节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转后left变成了right，right变成了left</span></span><br><span class="line">        l-&gt;next=last;</span><br><span class="line">        <span class="comment">//last是反转后的头</span></span><br><span class="line">        st-&gt;next=r;</span><br><span class="line">        <span class="comment">//st是反转后尾，所以st的next要指向r（right的后一个节点）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>$O(n)$</p><p>头插法</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251505396.png" alt="image-20220425150558317"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281517760.png" alt="截屏2022-02-28 15.15.40"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281519688.png" alt="截屏2022-02-28 15.16.30"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202202281518532.png" alt="截屏2022-02-28 15.16.30"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251503559.png" alt="image-20220425150336331"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dnode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dnode-&gt;next=head;</span><br><span class="line">        ListNode *pre=dnode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        ListNode *cur=pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">       <span class="comment">//pre-&gt;next永远指向反转的第一个节点</span></span><br><span class="line">     <span class="comment">//cur其实一直是left节点，只是在被不停的头插，挤到了后面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            <span class="comment">//首先,next永远指向cur的下一个</span></span><br><span class="line">             next=cur-&gt;next;</span><br><span class="line">          <span class="comment">//当前节点的下一个节点变成next的下一个节点(要把next拿去头插了)</span></span><br><span class="line">             cur-&gt;next=next-&gt;next;</span><br><span class="line">          <span class="comment">//cur的下一个节点(next)指向第一个节点，那它就变成了第一个节点(头插)</span></span><br><span class="line">             next-&gt;next=pre-&gt;next;</span><br><span class="line">          <span class="comment">//更新第一个节点为next</span></span><br><span class="line">             pre-&gt;next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dnode-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251801080.png" alt="image-20220425180147001"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802499.png" alt="image-20220425180200422"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802054.png" alt="image-20220425180212978"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802879.png" alt="image-20220425180221773"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802987.png" alt="image-20220425180232876"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802218.png" alt="image-20220425180241094"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802264.png" alt="image-20220425180249157"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251802457.png" alt="image-20220425180256346"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803573.png" alt="image-20220425180314490"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204251803797.png" alt="image-20220425180322689"></p><p>temp对应代码中的pre</p><p>node1对应head</p><p>node2对应nxt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">break</span>;<span class="comment">//不是双数个节点的情况(单个节点找不到换的)</span></span><br><span class="line">            pre-&gt;next=head-&gt;next;</span><br><span class="line">            ListNode *nxt=head-&gt;next;</span><br><span class="line">            head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">            nxt-&gt;next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h4><p>一开始写成了这样（没有新建nxt节点保存head-&gt;next），会进入死循环。因为head-&gt;next已经被更新为head-&gt;next-&gt;next了，所以head-&gt;next-&gt;next相当于是(head-&gt;next-&gt;next)-&gt;next</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">break</span>;</span><br><span class="line">            pre-&gt;next=head-&gt;next;   </span><br><span class="line">            head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        retur</span><br></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><h3 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h3><p>先记录链表的总长度记为<code>remain</code>用<code>92. 反转链表 II</code>的头插法，每次头插k个，插完k个将pre置换成上一组翻转的最后一个，也就是<code>cur</code>，因为<code>cur</code>本来是第一个节点，一直被头插插到最后一个了。同时也要更新<code>cur</code>为<code>pre-&gt;next</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode* cntNode=head;</span><br><span class="line">        <span class="type">int</span> remain=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cntNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cntNode=cntNode-&gt;next;</span><br><span class="line">            remain++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line">        ListNode *cur=head;</span><br><span class="line">        ListNode *nxt;</span><br><span class="line">        <span class="keyword">while</span>(remain&gt;=k)&#123;      </span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>;<span class="comment">//翻转k个节点需要翻转k-1次，所以cnt从1开始</span></span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;k)&#123;</span><br><span class="line">                nxt=cur-&gt;next;</span><br><span class="line">                cur-&gt;next=nxt-&gt;next;</span><br><span class="line">                nxt-&gt;next=cur;</span><br><span class="line">                nxt-&gt;next=pre-&gt;next;</span><br><span class="line">                pre-&gt;next=nxt;          </span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=pre-&gt;next;</span><br><span class="line">            remain-=k;<span class="comment">//翻转了k个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><h3 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h3><p>1.用一个map记录队列中数的情况，入队value，<code>mp[value]++</code>。出队q.front()，<code>mp[q.front()]--</code>，这里需要注意当mp[q.front()]为0时，要把<code>mp.erase(q.front());</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        it=mp.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        mp[value]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            mp[t]--;</span><br><span class="line">            <span class="keyword">if</span>(!mp[t])mp.<span class="built_in">erase</span>(t);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>2.一个双端单调队列记录最大值，一个普通队列记录队列真实的出入顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> d.<span class="built_in">front</span>();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">while</span> (!d.<span class="built_in">empty</span>() &amp;&amp; d.<span class="built_in">back</span>() &lt; value) &#123;</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        d.<span class="built_in">push_back</span>(value);</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(!d.<span class="built_in">empty</span>()&amp;&amp;d.<span class="built_in">front</span>()==t)&#123;</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s1,s2;</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t=s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121.买卖股票的最佳时机</a></h2><h3 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h3><p>贪心</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minn=<span class="number">100005</span>;</span><br><span class="line">        <span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minn=<span class="built_in">min</span>(minn,prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)maxx=<span class="built_in">max</span>(maxx,prices[i]-minn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机2"><a href="#122-买卖股票的最佳时机2" class="headerlink" title="122.买卖股票的最佳时机2"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机2</a></h2><h3 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h3><p>状态机DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//f[i][0]未持有股票</span></span><br><span class="line">        <span class="comment">//f[i][1]持有股票</span></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);<span class="comment">//没股票的前一次可以是没股票和卖了一支股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//有股票的前一次可以是有股票或者买了一支股票</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>],dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机3"><a href="#123-买卖股票的最佳时机3" class="headerlink" title="123.买卖股票的最佳时机3"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机3</a></h2><h3 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h3><p>状态机DP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//f[i][0]:从来没有买过股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][1]:第一次买股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][2]:卖掉一次股票的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][3]:卖掉一次股票，又买了一次的最大收益</span></span><br><span class="line">        <span class="comment">//f[i][4]:卖掉两次股票的最大收益</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=dp[<span class="number">0</span>][<span class="number">3</span>]=dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">-1e6</span>;<span class="comment">//这三种情况在第一支股票时均不可能发生</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">2</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">3</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">                dp[i][<span class="number">4</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[i][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][1]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][2]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][3]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][4]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-买卖股票的最佳时机4"><a href="#124-买卖股票的最佳时机4" class="headerlink" title="124.买卖股票的最佳时机4"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">124.买卖股票的最佳时机4</a></h2><h3 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h3><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240325224319278.png" alt="image-20240325224319278"></p><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/image-20240326110105688.png" alt="image-20240326110105688"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k,vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">100005</span>][<span class="number">105</span>][<span class="number">2</span>];<span class="comment">//考虑前i支股票，买卖了j次，当前没有/有股票的最大收益（以买作为一次交易，因为买了肯定要卖）</span></span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i<span class="number">-1</span>]);<span class="comment">//没股票的前一次可以是没股票和卖了一支股票</span></span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i<span class="number">-1</span>]);<span class="comment">//有股票的前一次可以是有股票或者买了一支股票</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;=n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;=k;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;dp[i][j][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][j][1]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[n][i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="146-LRU缓存-https-leetcode-cn-problems-lru-cache-description"><a href="#146-LRU缓存-https-leetcode-cn-problems-lru-cache-description" class="headerlink" title="[146.LRU缓存][https://leetcode.cn/problems/lru-cache/description/]"></a>[146.LRU缓存][<a href="https://leetcode.cn/problems/lru-cache/description/]">https://leetcode.cn/problems/lru-cache/description/]</a></h2><h3 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h3><p>unordered_map+双链表，主要复习stl的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;lis;</span><br><span class="line">    <span class="comment">//存iterator指向链表</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,pair&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt;mp;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//find()返回的是一个iterator,所以这里要先—&gt;再.</span></span><br><span class="line">            <span class="comment">//更新key再链表中的位置</span></span><br><span class="line">            lis.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key].second=(--lis.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">size</span>()&gt;=cap)&#123;</span><br><span class="line">                <span class="type">int</span> rmkey=lis.<span class="built_in">front</span>();</span><br><span class="line">                lis.<span class="built_in">pop_front</span>();</span><br><span class="line">                mp.<span class="built_in">erase</span>(rmkey);</span><br><span class="line">            &#125;</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key]=&#123;value,--lis.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//修改了已有key的value，更新该key在链表中的位置</span></span><br><span class="line">            lis.<span class="built_in">erase</span>(it-&gt;second.second);</span><br><span class="line">            lis.<span class="built_in">push_back</span>(key);</span><br><span class="line">            mp[key]=&#123;value,--lis.<span class="built_in">end</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a><a href="https://leetcode.cn/problems/majority-element/description">169.多数元素</a></h2><h3 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h3><p>候选人(<code>cand_num</code>)初始化为 <code>nums[0]</code>，票数 <code>count</code> 初始化为 1。<br>当遇到与 <code>cand_num</code> 相同的数，则票数 <code>count = count + 1</code>，否则票数 <code>count = count - 1</code>。<br>当票数 <code>count</code> 为 0 时，更换候选人，并将票数 <code>count</code> 重置为 1。<br>遍历完数组后，<code>cand_num</code> 即为最终答案。</p><p>为何这行得通呢？<br>投票法是遇到相同的则 <code>票数 + 1</code>，遇到不同的则 <code>票数 - 1</code>。<br>且“多数元素”的个数 &gt; ⌊ n/2 ⌋，其余元素的个数总和 &lt;= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。<br>这就相当于每个 “多数元素” 和其他元素 两两相互抵消，抵消到最后肯定还剩余 至少1个 “多数元素“。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cand_num=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==cand_num)cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)cand_num=i,cnt=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189.轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/description/">189.轮转数组</a></h2><ul><li>循环数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)curr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           nums[i]=curr[(i+n-k%n)%n];</span><br><span class="line">           <span class="comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;(i+n-k%n)%n&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>O(1)空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        k=k%n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+k,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300.最长上升子序列</a></h2><h3 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h3><p><code>dp[i]</code>意为以<code>nums[i]</code>这个数字结尾的最长上升子序列长度，所以转移方程考虑<code>dp[i]=max(dp[k]+1) if nums[i]&gt;nums[k] k=0...i-1</code></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对于每一个长度的上升子序列，只有结尾最小的是有用的。例如<code>3 1 2 1 8 5 6</code>，以3和1结尾的都是长度为1的最长上升子序列，但是1比3更好，所以3就没用了。</p><ul><li>一个猜想：随着最长上升子序列长度的增加，不同长度的上升子序列的最小结尾也是单调递增的（反证法可得）</li></ul><p><img src="https://raw.githubusercontent.com/reinhart-l/FigureBed2/master/1711265135869.png" alt="1711265135869"></p><ul><li>由上存储一个数组<code>q[i]</code>（存的是所有长度为i的上升子序列的结尾最小值），假设一个数a，要求它的最长上升子序列，只需找到<code>q</code>中比它小的数中最大的数，假设为<code>q[j]</code>，因为<code>q[j]</code>是小于a的最大的数，那么<code>q[j+1]</code>一定是大于等于a的，所以可以用a去更新<code>q[j+1]</code></li><li>不懂就去看调试</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> q[<span class="number">2505</span>]; <span class="comment">//q[i]代表最长上升子序列长度为i时的结尾最小值</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        q[<span class="number">0</span>]=<span class="number">-2e4</span>;<span class="comment">//求的是小于某个数最大的数，保证小于的数一定存在</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=len;</span><br><span class="line">            <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;q[mid])&#123;</span><br><span class="line">                    l=mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="built_in">max</span>(len,r+<span class="number">1</span>);</span><br><span class="line">            q[r+<span class="number">1</span>]=nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line">            <span class="comment">//     cout&lt;&lt;q[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;&#x27;\n&#x27;&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692.前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/description/">692.前K个高频单词</a></h2><h3 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h3><p>主要展示优先队列自定义运算符较为简单的一种方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stru</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stru &amp;a)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.n!=n)<span class="keyword">return</span> a.n &gt; n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.id &lt; id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;string&gt;&amp; words, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:words)&#123;</span><br><span class="line">            mp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;stru&gt;heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">            stru x=&#123;i.second,i.first&#125;;</span><br><span class="line">            heap.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt;ans;</span><br><span class="line">        <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> top=heap.<span class="built_in">top</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(top.id);</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(!k)<span class="keyword">break</span>;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果是sort可以这么写</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stru</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125; edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stru a, stru b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + n - <span class="number">1</span>, cmp);</span><br></pre></td></tr></table></figure><h2 id="1631-最小体力消耗路径"><a href="#1631-最小体力消耗路径" class="headerlink" title="1631. 最小体力消耗路径"></a><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h2><h3 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h3><p>注意因为可以走回头路，所以不是DP，魔改dijkstra。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;g[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j, <span class="type">int</span> c,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;c&amp;&amp;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;r&amp;&amp;j&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> r = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> c = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;c;</span></span><br><span class="line">        <span class="comment">//先bfs一遍把图建出来</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(vis[t.first][t.second])<span class="keyword">continue</span>;</span><br><span class="line">            vis[t.first][t.second]=<span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">judge</span>(x,y,c,r)&amp;&amp;!vis[x][y])&#123;</span><br><span class="line">                    <span class="type">int</span> idx=t.first*r+t.second;</span><br><span class="line">                    <span class="type">int</span> idx2=x*r+y;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;idx&lt;&lt;&#x27; &#x27;&lt;&lt;idx2&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">                    <span class="type">int</span> di=<span class="built_in">abs</span>(heights[t.first][t.second]-heights[x][y]);</span><br><span class="line">                    g[idx].<span class="built_in">push_back</span>(&#123;idx2,di&#125;);</span><br><span class="line">                    g[idx2].<span class="built_in">push_back</span>(&#123;idx,di&#125;);</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;c*r;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto j:g[i])&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;j.second&lt;&lt;&#x27; &#x27;&lt;&lt;j.first&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;c*r;i++)cout&lt;&lt;dis[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="keyword">return</span> dis[c*r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])<span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[ver].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> j = g[ver][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j.first] &gt; <span class="built_in">max</span>(distance , j.second)) &#123;</span><br><span class="line">                dis[j.first] = <span class="built_in">max</span>(distance , j.second);</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j.first], j.first&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo基于cactus仙人掌主题最全美化客制教程</title>
      <link href="/2022/01/19/%E4%BD%BF%E7%94%A8hexo%E5%9F%BA%E4%BA%8Ecactus%E4%BB%99%E4%BA%BA%E6%8E%8C%E4%B8%BB%E9%A2%98%E6%9C%80%E5%85%A8%E7%BE%8E%E5%8C%96%E5%AE%A2%E5%88%B6%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/19/%E4%BD%BF%E7%94%A8hexo%E5%9F%BA%E4%BA%8Ecactus%E4%BB%99%E4%BA%BA%E6%8E%8C%E4%B8%BB%E9%A2%98%E6%9C%80%E5%85%A8%E7%BE%8E%E5%8C%96%E5%AE%A2%E5%88%B6%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>话不多说先上个自己的网站 <a href="https://reinhart-l.github.io/">Across the Cosmos</a>，目前还是用的github page，域名已经购买了但还没有备案，后续打算自己买个服务器再将博客部署上去，之后有空也会更新一篇相关的教程。</p></li><li><p>最近无聊试着用hexo搭了一下个人网站，如果还不会使用和部署hexo，可以参考<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">这篇博客</a>,作者写得非常细致，从安装hexo一直到将自己的博客部署到github（不过作者用的主题是next），照着一步步做应该不会有什么问题。如果遇到问题可以参考一下我这篇<a href="https://reinhart-l.github.io/2022/01/14/%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%A5%E5%BF%97%20PART.1/">问题日志</a>，希望可以帮到你。</p></li><li><p>当我把我的博客部署好后，我陷入了选择困难症。好看的主题实在是太多了，不知道怎么选。虽然next、butterfly等主题网上教程很多，但是布局和功能我自认为稍微有点复杂，而且我实在不想和这么多人撞博客。几经波折我最终选择了cactus 仙人掌这个主题（<a href="https://github.com/probberechts/hexo-theme-cactus">github仓库</a>，<a href="https://probberechts.github.io/hexo-theme-cactus/">网站demo</a>）。这个主题一共有四种风格。整体非常简洁大气。<img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913239.png" alt="image-20220119164127894"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913102.png" alt="image-20220119164424710"></p><ul><li>你也许一开始也会跟我有意义的焦虑：这个博客太简约了，而且网上的教程又少，会不会很多自己想要的功能都没法实现？本篇博客就致力于教你用cactus最大化客制你自己的博客。</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="安装cactus主题"><a href="#安装cactus主题" class="headerlink" title="安装cactus主题"></a>安装cactus主题</h3><ul><li><p>进入hexo所在的文件夹（我是<code> cd ./Desktop/Blog</code>）</p></li><li><p>执行<code>git clone https://github.com/probberechts/hexo-theme-cactus.git themes/cactus</code>。</p><p>如果timeout就用ssh连接<code>git cline git@github.com:probberechts/hexo-theme-cactus.git themes/cactus</code></p></li><li><p>然后在<code>./_config.yml</code>中修改<code>theme</code></p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># theme: landscape</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">cactus</span></span><br></pre></td></tr></table></figure><h3 id="切换主题的风格"><a href="#切换主题的风格" class="headerlink" title="切换主题的风格"></a>切换主题的风格</h3><ul><li>前面提到了cactus主题有四个风格，切换风格只需要进入<code>./themes/cactus/_config.yml</code>中找到<code>colorscheme</code>修改就完事，注意每次修改完都需要<code>hexo clean</code> <code>hexo g </code>才会生效</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the color scheme.</span></span><br><span class="line"><span class="comment"># Available color schemes are &#x27;dark&#x27;, &#x27;light&#x27;, &#x27;classic&#x27; and &#x27;white&#x27;.</span></span><br><span class="line"><span class="comment"># Alternatively, add your own custom color scheme to source/css/_colors.</span></span><br><span class="line"><span class="attr">colorscheme:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><h3 id="导航栏相关"><a href="#导航栏相关" class="headerlink" title="导航栏相关"></a>导航栏相关</h3><h4 id="新建一个导航栏的项"><a href="#新建一个导航栏的项" class="headerlink" title="新建一个导航栏的项"></a>新建一个导航栏的项</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913291.png" alt="image-20220119171740127"></p><ul><li>在<code>./themes/cactus/_config.yml</code>找到<code>nav</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span></span><br><span class="line">  <span class="attr">articles:</span> <span class="string">/archives/</span></span><br><span class="line">  <span class="attr">projects:</span> <span class="string">http://github.com/probberechts</span></span><br><span class="line">  <span class="attr">LINK_NAME:</span> <span class="string">URL</span></span><br></pre></td></tr></table></figure><p>​    直接在nav下面添加就行，添加完这一项之后可以让它指向一个链接（例如projcets），也可以让它指向站内的一个页面。新建一个页面执行<code>hexo new page xxx</code>，然后这个页面的路径就是<code>/xxx/</code></p><ul><li>更新后会在<code>./themes/cactus/source</code>中发现一个和page名称一样的文件夹</li></ul><h4 id="让导航栏中的某一项显示内容在首页"><a href="#让导航栏中的某一项显示内容在首页" class="headerlink" title="让导航栏中的某一项显示内容在首页"></a>让导航栏中的某一项显示内容在首页</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913732.png" alt="image-20220119171913748"></p><ul><li>以project为例，只需在<code>./themes/cactus/source</code>中创建<code>/_data/projects.json</code>，然后修改json文件为</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="string">&quot;name&quot;</span><span class="string">:&quot;Hexo&quot;</span>,</span><br><span class="line">       <span class="string">&quot;url&quot;</span><span class="string">:&quot;https://hexo.io/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;desc&quot;</span><span class="string">:&quot;A</span> <span class="string">fast</span>, <span class="string">simple</span> <span class="string">&amp;</span> <span class="string">powerful</span> <span class="string">blog</span> <span class="string">framework&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="string">&quot;name&quot;</span><span class="string">:&quot;Font</span> <span class="string">Awesome&quot;</span>,</span><br><span class="line">       <span class="string">&quot;url&quot;</span><span class="string">:&quot;http://fontawesome.io/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;desc&quot;</span><span class="string">:&quot;The</span> <span class="string">iconic</span> <span class="string">font</span> <span class="string">and</span> <span class="string">CSS</span> <span class="string">toolkit&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="在导航栏添加搜索功能"><a href="#在导航栏添加搜索功能" class="headerlink" title="在导航栏添加搜索功能"></a>在导航栏添加搜索功能</h4><ul><li>在<code>./themes/cactus/_config.yml</code>中找到<code>nav</code>    新建search标签</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">/search/</span></span><br></pre></td></tr></table></figure><ul><li><p>执行<code>npm install hexo-generator-search --save</code></p></li><li><p>执行<code>hexo new page search</code></p></li><li><p>进入<code>./themes/cactus/source/serch/index.md</code>，修改md文件的头为</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: Search</span><br><span class="line"><span class="section">type: search</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><ul><li>更新之后进入网站，点击search就可以搜索了</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913828.png" alt="image-20220119172956786"></p><h3 id="新增标签功能"><a href="#新增标签功能" class="headerlink" title="新增标签功能"></a>新增标签功能</h3><ul><li><p>只需要在每篇文章的头部添加</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: Tags and Categories</span><br><span class="line">date: 2017-12-24 23:29:53</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Foo</span><br><span class="line"><span class="bullet">-</span> Bar</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>​        就可以在首页看到</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913263.png" alt="image-20220119173507249"></p><ul><li>每篇文章可以有两个tag，tag的顺序影响其重要程度</li></ul><h3 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h3><ul><li>cactus支持Disqus和Utterances两个平台的评论功能，只需要在<code>./themes/cactus/_config.yml</code>分别找到它们就行。</li><li>以Disqus为例，把enable设置为true，然后再去<a href="%5Bhttps://disqus.com/admin/create/%5D(http://disqus.com/admin/create/)">Disqus官网</a>注册个账号,认证邮箱后在<code>shortname</code>处填上自己的昵称就行</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">SITENAME</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913213.png" alt="image-20220119174056064"></p><ul><li>之后就能愉快的评论了，不过Disqus现在好像必须要梯子才能正常使用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191742742.png" alt="image-20220119174234665"></p><h3 id="添加其他社交平台链接"><a href="#添加其他社交平台链接" class="headerlink" title="添加其他社交平台链接"></a>添加其他社交平台链接</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913761.png" alt="image-20220119180743421"></p><ul><li>在<code>./themes/cactus/_config.yml</code>搜索<code>Social media links</code></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social_links:</span></span><br><span class="line">  <span class="attr">github:</span> <span class="string">your-github-url</span></span><br><span class="line">  <span class="attr">twitter:</span> <span class="string">your-twitter-url</span></span><br><span class="line">  <span class="attr">NAME:</span> <span class="string">your-NAME-url</span></span><br></pre></td></tr></table></figure><p>然后前面就是社交平台的名称，后面就是你该社交平台的url，注意这里只能选<a href="https://fontawesome.com/v5.15/icons?d=gallery&p=2">Font awesome</a>上有的icon，才会显示对应的icon，进入网站搜索社交平台的英文名就能看到是否有这个icon了，这里列出几个比较常见的：<code>weibo</code> <code>weixin</code> <code>zhihu</code> <code>rss</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913161.png" alt="image-20220119181130127"></p><h3 id="增加数据分析"><a href="#增加数据分析" class="headerlink" title="增加数据分析"></a>增加数据分析</h3><ul><li>在<code>./themes/cactus/_config.yml</code>中，搜索<code>analytics</code>，cactus支持以下几种数据分析功能，说白了就是后台管理。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">&#x27;UA-49627206-1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">baidu_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">2e6da3c375c8a87f5b664cea6d4cb29c</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cloudflare_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">0dabb6e21848405483a237e6a7b6ed04</span></span><br><span class="line"></span><br><span class="line"><span class="attr">umami_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">e77e68be-f6e4-4br3-9365-2b76b57cd571</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://analytics.domain.com</span></span><br></pre></td></tr></table></figure><ul><li>以百度分析为统计，先去<a href="https://tongji.baidu.com/web/38068506/welcome/login">百度统计官网</a>注册一个账号，然后在网站列表点击<code>新增网站</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913461.png" alt="image-20220119182033084"></p><ul><li>填写相关信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913538.png" alt="image-20220119182152990"></p><ul><li>然后在<code>代码管理-&gt;代码获取</code>页面复制这一段，这就是你的<code>tracking_id</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913420.png" alt="image-20220119182521144"></p><ul><li>然后回到<code>./themes/cactus/_config.yml</code>，修改这里的<code>id</code>，<code>enabled</code>设置为<code>true</code></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">2e6da3c375c8a87f5b664cea6d4cb29c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>进入百度统计的<code>代码管理-&gt;代码安装检查</code>，点击<code>开始检查</code>，如果显示代码安装正确，过一会就能显示你网站统计的数据了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913736.png" alt="image-20220119182832891"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913062.png" alt="image-20220119182858428"></p><h3 id="自定义字体-颜色和网站logo-icon"><a href="#自定义字体-颜色和网站logo-icon" class="headerlink" title="自定义字体/颜色和网站logo/icon"></a>自定义字体/颜色和网站logo/icon</h3><h4 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h4><ul><li>进入<code>./themes/cactus/source/css/colors</code>中有四个文件，对应不同风格的样式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913264.png" alt="image-20220119183134175"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$color-background = #<span class="number">1</span>d1f21</span><br><span class="line">$color-footer-mobile<span class="number">-1</span> = <span class="built_in">lighten</span>($color-background, <span class="number">2</span>%)</span><br><span class="line">$color-footer-mobile<span class="number">-2</span> = <span class="built_in">lighten</span>($color-background, <span class="number">10</span>%)</span><br><span class="line">$color-background-code = <span class="built_in">lighten</span>($color-background, <span class="number">2</span>%)</span><br><span class="line">$color-border = #<span class="number">908</span>d8d</span><br><span class="line">$color-meta = #<span class="number">908</span>d8d</span><br><span class="line">$color-meta-code = #<span class="number">908</span>d8d</span><br><span class="line">$color-link = <span class="built_in">rgba</span>(<span class="number">212</span>, <span class="number">128</span>, <span class="number">170</span>, <span class="number">1</span>)</span><br><span class="line">$color-text = #c9cacc      <span class="comment">//正文</span></span><br><span class="line">$color-accent<span class="number">-3</span> = <span class="meta">#cccccc  <span class="comment">//副副标题</span></span></span><br><span class="line">$color-accent<span class="number">-2</span> = <span class="meta">#eeeeee  <span class="comment">//副标题</span></span></span><br><span class="line">$color-accent<span class="number">-1</span> = #ff6a00  <span class="comment">//主标题</span></span><br><span class="line">$color-quote = #ccffb6</span><br><span class="line">$highlight = hexo-<span class="built_in">config</span>(<span class="string">&quot;highlight&quot;</span>) || <span class="string">&quot;rainbow&quot;</span></span><br></pre></td></tr></table></figure><ul><li>别的参数我没有调过，大家可以自己修改试一试</li></ul><h4 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h4><ul><li>进入<code>./themes/cactus/source/css/_variables.styl</code>，就可以修改字体了</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">Fonts</span></span><br><span class="line"><span class="string">$font-family-body</span> <span class="string">=</span> <span class="string">&quot;Menlo&quot;</span><span class="string">,</span> <span class="string">&quot;Meslo LG&quot;</span><span class="string">,</span> <span class="string">monospace</span></span><br><span class="line"><span class="string">$font-family-mono</span> <span class="string">=</span> <span class="string">&quot;Menlo&quot;</span><span class="string">,</span> <span class="string">&quot;Meslo LG&quot;</span><span class="string">,</span> <span class="string">monospace</span></span><br><span class="line"><span class="string">$font-size</span> <span class="string">=</span> <span class="string">14px</span></span><br><span class="line"><span class="string">$line-height</span> <span class="string">=</span> <span class="number">1.725</span></span><br><span class="line"><span class="string">$page-width</span> <span class="string">=</span> <span class="string">0rem</span> <span class="string">+</span> <span class="string">(hexo-config(&quot;page_width&quot;)</span> <span class="string">||</span> <span class="number">39</span><span class="string">)</span></span><br><span class="line"><span class="string">//</span> <span class="string">Logo</span></span><br><span class="line"><span class="string">$logo-width</span> <span class="string">=</span> <span class="string">0px</span> <span class="string">+</span> <span class="string">(hexo-config(&quot;logo.width&quot;)</span> <span class="string">||</span> <span class="number">0</span><span class="string">)</span></span><br><span class="line"><span class="string">$logo-height</span> <span class="string">=</span> <span class="string">0px</span> <span class="string">+</span> <span class="string">(hexo-config(&quot;logo.height&quot;)</span> <span class="string">||</span> <span class="number">0</span><span class="string">)</span></span><br><span class="line"><span class="string">$logo-grayout</span> <span class="string">=</span> <span class="string">hexo-config(&quot;logo.grayout&quot;)</span> <span class="string">||</span> <span class="literal">false</span></span><br><span class="line"><span class="string">//</span> <span class="string">Colors</span></span><br><span class="line"><span class="string">$colors</span> <span class="string">=</span> <span class="string">hexo-config(&quot;colorscheme&quot;)</span> <span class="string">||</span> <span class="string">&quot;dark&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可用的字体在<code>./themes/cactus/source/lib/</code>中，cactus自带的只有<code>meslo-LG</code> <code>vazir-font</code>两种，有需要可以自己下载。</li></ul><h4 id="自定义网站logo-icon"><a href="#自定义网站logo-icon" class="headerlink" title="自定义网站logo/icon"></a>自定义网站logo/icon</h4><ul><li>在<code>./themes/cactus/source/images/</code>下有四张图片</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913511.png" alt="image-20220119184002386"></p><ul><li><code>apple-touch-icon</code>是苹果产品将网站的快捷方式添加到主屏幕所显示的logo</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191841233.jpg" alt="991642588859_.pic" style="zoom:25%;" /><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191841250.jpg" alt="1001642588860_.pic" style="zoom:25%;" /></p><ul><li>logo就是显示在你网页上的那个东西，<a href="https://www.designevo.com/logo-maker/">设计logo的网站</a>，里面有很多半成品，拿来就能用。</li><li>favicon-192x192就是192x192像素的logo.png，网上随便找个软件就能压缩</li><li>favicon.ico有点难搞，因为它一个文件里面有不同规格的ico，我是用了一个叫<a href="https://tool.brmind.cn/index.html">氢贝</a>的软件弄的，里面可以直接将各种图片格式转化为多规格的ico，非常方便。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191913013.png" alt="image-20220119185225204"></p><h3 id="添加点击量功能"><a href="#添加点击量功能" class="headerlink" title="添加点击量功能"></a>添加点击量功能</h3><ul><li>进入<code>./themes/cactus/_config.yml</code>添加下面一段代码</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启访问量统计功能(不蒜子)</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>进入<code>./themes/cactus/layout/_partial/footer.ejs</code>将其全部修改覆盖为</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;footer</span> <span class="string">id=&quot;footer&quot;&gt;</span></span><br><span class="line">      <span class="string">&lt;div</span> <span class="string">class=&quot;footer-left&quot;&gt;</span></span><br><span class="line">        &lt;%=<span class="language-ruby"> __(<span class="string">&#x27;footer.copyright&#x27;</span>) </span>%&gt; <span class="string">&amp;copy;</span></span><br><span class="line">        &lt;%<span class="language-ruby"> var endYear = (theme.copyright &amp;&amp; theme.copyright.end_year) ? theme.copyright.end_year : new <span class="title class_">Date</span>().getFullYear() </span>%&gt;</span><br><span class="line">        &lt;%<span class="language-ruby"> var startYear = (theme.copyright &amp;&amp; theme.copyright.start_year) ? theme.copyright.start_year : new <span class="title class_">Date</span>().getFullYear() </span>%&gt;</span><br><span class="line">        &lt;%=<span class="language-ruby"> startYear &gt;= endYear ? endYear : startYear + <span class="string">&quot;-&quot;</span> + endYear </span>%&gt;</span><br><span class="line">        &lt;%=<span class="language-ruby"> config.author |<span class="params"></span>| config.title </span>%&gt;</span><br><span class="line">      <span class="string">&lt;/div&gt;</span></span><br><span class="line">      <span class="string">&lt;div</span> <span class="string">class=&quot;footer-right&quot;&gt;</span></span><br><span class="line">        <span class="string">&lt;nav&gt;</span></span><br><span class="line">          <span class="string">&lt;ul&gt;</span></span><br><span class="line">            &lt;%<span class="language-ruby"> <span class="keyword">for</span> (var i <span class="keyword">in</span> theme.nav) &#123; </span>%&gt;<span class="string">&lt;!--</span></span><br><span class="line">          <span class="string">--&gt;&lt;li&gt;&lt;a</span> <span class="string">href=&quot;&lt;%-</span> <span class="string">url_for(theme.nav[i])</span> <span class="string">%&gt;&quot;&gt;&lt;%=</span> <span class="string">__(&#x27;nav.&#x27;+i).replace(&quot;nav.&quot;,</span> <span class="string">&quot;&quot;</span><span class="string">)</span> <span class="string">%&gt;&lt;/a&gt;&lt;/li&gt;&lt;!--</span></span><br><span class="line">        <span class="string">--&gt;&lt;%</span> <span class="string">&#125;</span> <span class="string">%&gt;</span></span><br><span class="line">          <span class="string">&lt;/ul&gt;</span></span><br><span class="line">          <span class="string">&lt;ul&gt;</span></span><br><span class="line">            &lt;%<span class="language-ruby"> <span class="keyword">if</span> (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; </span>%&gt;</span><br><span class="line">              <span class="string">&lt;!--</span> <span class="string">不蒜子统计</span> <span class="string">--&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">id=&quot;busuanzi_container_site_pv&quot;&gt;</span></span><br><span class="line">                  <span class="string">本站总访问量&lt;span</span> <span class="string">id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span></span><br><span class="line">              <span class="string">&lt;/span&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">id=&quot;busuanzi_container_site_uv&quot;</span> <span class="string">style=&#x27;display:none&#x27;&gt;</span></span><br><span class="line">                      <span class="string">本站访客数&lt;span</span> <span class="string">id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人</span></span><br><span class="line">              <span class="string">&lt;/span&gt;</span></span><br><span class="line">            <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">            &lt;%<span class="language-ruby"> &#125; </span>%&gt;</span><br><span class="line">          <span class="string">&lt;/ul&gt;</span></span><br><span class="line">        <span class="string">&lt;/nav&gt;</span></span><br><span class="line">      <span class="string">&lt;/div&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="string">&lt;/footer&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>有前端基础的可以加在footer的别的位置甚至加在header.ejs里，核心代码就是</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="language-ruby"> <span class="keyword">if</span> (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; </span>%&gt;</span><br><span class="line">              <span class="string">&lt;!--</span> <span class="string">不蒜子统计</span> <span class="string">--&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">id=&quot;busuanzi_container_site_pv&quot;&gt;</span></span><br><span class="line">                  <span class="string">本站总访问量&lt;span</span> <span class="string">id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span></span><br><span class="line">              <span class="string">&lt;/span&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span></span><br><span class="line">              <span class="string">&lt;span</span> <span class="string">id=&quot;busuanzi_container_site_uv&quot;</span> <span class="string">style=&#x27;display:none&#x27;&gt;</span></span><br><span class="line">                      <span class="string">本站访客数&lt;span</span> <span class="string">id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人</span></span><br><span class="line">              <span class="string">&lt;/span&gt;</span></span><br><span class="line">            <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">            &lt;%<span class="language-ruby"> &#125; </span>%&gt;</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201191910672.png" alt="image-20220119191035534"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul><li>其他的一些功能可以去看<a href="https://github.com/probberechts/hexo-theme-cactus">cactus官方文档</a></li><li>如果之后还发现了有趣的功能会持续更新</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021GDUFS新手赛D-DUNE 题解</title>
      <link href="/2022/01/18/2021GDUFS%E6%96%B0%E6%89%8B%E8%B5%9BD-DUNE%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/01/18/2021GDUFS%E6%96%B0%E6%89%8B%E8%B5%9BD-DUNE%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p> <em>这个沙漠星球，我们称之为厄拉科斯（Arrakis）。</em> </p><p> <em>而它的原住民称其母星为沙丘（Dune）。</em> </p><p> <em>厄拉科斯在繁星的映衬下逐渐出现：一个沙漠世界。</em> </p><p> <em>一股巨大的铁锈色沙暴飓风正在厄拉科斯的赤道上缓慢地移动。</em><br> <em>一艘隐形飞船驾向厄拉科斯大地：造型奇异的双座工具，完全光滑，深黑，没有标志……</em> </p><p>厄崔迪家族从哈克南家族手中接过了厄拉科斯的统治权,现在正是将所有物资运往厄拉科斯的关键时刻.厄崔迪男爵不想出任何问题,于是委托你——厄崔迪家族的首席飞船调度员,来安排飞船的航线.</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你要安排的航线系统可以表示成一个二维的平面图.你的飞船调度室在$(0,0)$.从西到东,从南到北各有100条航道.不同的运输飞船会同时从各个航道的起点,可以表示为$(0,i)$或$(j,0)$ $(1&lt;=i&lt;=100,1&lt;=j&lt;=100)$以<strong>相同速度</strong>起飞,现在有n架从西到东和m架从南到北的飞船,(每条航道上最多只能有一架飞船),在保证所有飞船都不相撞的情况下,想要运输最多的物资——也就是让能同时起飞的飞船最多.你想知道具体能最多让多少架飞船同时起飞?<br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181916982.jpeg"></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数$n(1&lt;=n&lt;=100)$和一个整数$m(1&lt;=m&lt;=100)$,表示$n$架从西向东和$m$架从南面向北的飞船,第二行输入$n$个飞船分别起飞的航道,第三行输入$m$个飞船分别起飞的航道.(保证输入的每一条航道上只有一个飞船)</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数,表示最多可以保留的飞船数.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>注意到所有飞船都是相同速度，那么$X_{i}$会和$Y_j$航道上的飞船当且仅当$i=j$。所以只要统计所有$i=j$的情况，减去任意一艘，最后就是答案。</li></ul><ul><li>$O(n^2)$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i, j;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">bool</span> v[<span class="number">105</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v[x] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (v[x])</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n+m-ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>$O(n)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="type">int</span> x, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">a[x]=<span class="number">1</span>;</span><br><span class="line">    ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span>(a[x] != <span class="number">1</span>)ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021GDUFS新手赛F-Reinhart的德州扑克 题解</title>
      <link href="/2022/01/18/2021GDUFS%E6%96%B0%E6%89%8B%E8%B5%9BF-Reinhart%E7%9A%84%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/01/18/2021GDUFS%E6%96%B0%E6%89%8B%E8%B5%9BF-Reinhart%E7%9A%84%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/U188446">https://www.luogu.com.cn/problem/U188446</a></p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p><em>德州扑克是目前世界上最流行的扑克游戏，全世界有众多相关的比赛，例如是 WSOP，WPT，EPT等，也让这款游戏的玩法变得层出不穷，丰富多变。</em> </p><p> <em>不要被简单的游戏规则而误导，复杂多变的比赛状况，让这款游戏在高水平的竞技中会变得非常复杂，这也让人们为德州扑克给出了这样一句评价“用一刻就能学会，但要用一生才能掌握”。</em> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在我们并不在乎游戏规则是什么,因为Reinhart是一个德州扑克高手,他对于德州扑克的规则烂熟于心,不过他每次都记不得牌型的大小关系,他知道你是一个编程高手,所以他想让你帮他写一个程序:输入五张牌的大小和花色,输出这五张牌能组成的最大牌型.你能帮帮他吗?</p><p>为了降低你的编程难度,我们规定:</p><ol><li><strong>输入的牌都是来源于同一副扑克牌.</strong></li><li><strong>输入的牌的点数都是非递减的.</strong></li><li><strong>所有花色没有大小之分.</strong></li></ol><p>下面给出各牌型,(从大到小)</p><ol><li><strong>皇家同花顺(ROYAL FLUSH)</strong>:五张顺连的牌(点数连续单调递增),<strong>且最大的一张牌是A(Ace)</strong>,并且五张牌的花色相同.</li><li><strong>同花顺(STRAIGHT FLUSH)</strong>:五张顺连的牌(点数连续单调递增),<strong>不规定最大的一张牌是A(Ace)</strong>,并且五张牌的花色相同.</li><li><strong>四条(FOUR OF A KIND)</strong>:至少四张牌的点数相同.</li><li><strong>葫芦(FULL HOUSE)</strong>:至少三张牌的点数相同,并且除此之外还有两张牌的点数相同.</li><li><strong>同花(FLUSH)</strong>:五张牌的花色都相同.</li><li><strong>顺子(STRAIGHT)</strong>:五张顺连的牌(点数连续单调递增),不要求五张牌的花色相同.</li><li><strong>特别注意</strong>:由于Reinhart是个谨慎的人,所以比<strong>三条(THREE OF A KIND)</strong>(包括三条)小的牌型Reinhart不在乎他们的大小关系,你只需要告诉Reinhart弃牌就行<br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/20211109183539.png"></li></ol><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入两行,每行五个数字,第一行的第$i$个字符表示第$i$张扑克的点数,<br>第二行的第$i$个数字表示第$i$张扑克花色.<strong>(保证输入的牌的点数是非递减的)</strong></p><p>点数和对应输入的数字:</p><ul><li>2 - 10 对应 2 - 10</li><li>J(Jack) 对应 11</li><li>(Queen) 对应 12</li><li>K(King) 对应 13</li><li>A(Ace) 对应 14</li></ul><p>花色和对应输入的数字:</p><ul><li>黑桃(Spades) 对应 1</li><li>方片(Diamonds) 对应 2</li><li>红桃(Hearts) 对应 3</li><li>梅花(Clubs) 对应 4</li></ul><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出这五张牌能组成的最大牌型.</p><ul><li>如果最大是皇家同花顺输出”ROYAL FLUSH”</li><li>如果最大是同花顺输出”STRAIGHT FLUSH”</li><li>如果最大是四条输出”FOUR OF A KIND”</li><li>如果最大是葫芦输出”FULL HOUSE”</li><li>如果最大是同花输出”FLUSH”</li><li>如果最大是顺子输出”STRAIGHT”</li><li>如果最大的牌型小于等于三条输出”FOLD”,劝Reinhart弃牌.</li><li>输出不包括引号</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>按照题意模拟即可，虽然题目规定输入一定是非递减输入，但要仍然要注意一些顺序问题，具体见代码。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>], b[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        b[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ma = <span class="built_in">max</span>(ma, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a[<span class="number">0</span>] + <span class="number">1</span> == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">1</span>] + <span class="number">1</span> == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">2</span>] + <span class="number">1</span> == a[<span class="number">3</span>] &amp;&amp; a[<span class="number">3</span>] + <span class="number">1</span> == a[<span class="number">4</span>]) &amp;&amp; ma == <span class="number">5</span> &amp;&amp; a[<span class="number">4</span>] == <span class="number">14</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ROYAL FLUSH&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a[<span class="number">0</span>] + <span class="number">1</span> == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">1</span>] + <span class="number">1</span> == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">2</span>] + <span class="number">1</span> == a[<span class="number">3</span>] &amp;&amp; a[<span class="number">3</span>] + <span class="number">1</span> == a[<span class="number">4</span>]) &amp;&amp; ma == <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;STRAIGHT FLUSH&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a[<span class="number">0</span>] == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">0</span>] == a[<span class="number">3</span>]) || (a[<span class="number">1</span>] == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">1</span>] == a[<span class="number">3</span>] &amp;&amp; a[<span class="number">1</span>] == a[<span class="number">4</span>])) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FOUR OF A KIND&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a[<span class="number">0</span>] == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">3</span>] == a[<span class="number">4</span>]) || (a[<span class="number">2</span>] == a[<span class="number">3</span>] &amp;&amp; a[<span class="number">2</span>] == a[<span class="number">4</span>] &amp;&amp; a[<span class="number">0</span>] == a[<span class="number">1</span>])) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FULL HOUSE&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FLUSH&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] + <span class="number">1</span> == a[<span class="number">1</span>] &amp;&amp; a[<span class="number">1</span>] + <span class="number">1</span> == a[<span class="number">2</span>] &amp;&amp; a[<span class="number">2</span>] + <span class="number">1</span> == a[<span class="number">3</span>] &amp;&amp; a[<span class="number">3</span>] + <span class="number">1</span> == a[<span class="number">4</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;STRAIGHT&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FOLD&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HEXO搭建博客问题日志</title>
      <link href="/2022/01/14/%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/14/%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解决-Failed-to-connect-to-github-com-port-443-connection-timed-out"><a href="#1-解决-Failed-to-connect-to-github-com-port-443-connection-timed-out" class="headerlink" title="1.解决 Failed to connect to github.com port 443:connection  timed out"></a>1.解决 Failed to connect to github.com port 443:connection  timed out</h3><ul><li>当使用<code>hexo d</code>的时候，一直连接超时。</li></ul><h4 id="方案汇总："><a href="#方案汇总：" class="headerlink" title="方案汇总："></a>方案汇总：</h4><ul><li><p>换一个网络，或等一段时间可能会好</p></li><li><p>执行<code>git config --global --unset http.proxy</code></p></li><li><p>进入<code>hexo</code>文件夹里的<code>_config.yml</code>文件</p><p>将<code>repo: https://github.com/xxx/xxx.io.git</code>更改为ssh地址</p><p><code>repo: git@github.com:xxx/xxx.github.io.git</code></p><p>一定要注意yml文件的格式问题（:后有空格）</p></li><li><p>去<a href="https://www.ipaddress.com/">这个网站</a>，搜出github.com的ip地址后记下来</p></li></ul><p>​    <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180057595.png" alt="image-20220113113517292"></p><p>​        执行<code>sudo vi /etc/hosts</code>,按<code>a</code>进行插入，插入一条<code>140.82.114.4 github.com</code>(具体ip地址根据你当时的查询结果而定)，然后按<code>esc</code>再按两次大写的<code>Z</code>退出。这时候再执行<code>hexo d</code>应该就不会出现超时的问题了，但你可能会发现执行几次<code>hexo d</code>之后超时问题又会出现，这个时候你就再<code>sudo vi /etc/hosts</code>重新查询一下github的ip地址然后修改一下，如果查出来和之前的插入的是相同的就直接吧插入的删掉，再执行<code>hexo d</code>，如果还是不行就再插入，多试几次就好了。</p><h3 id="2-解决remote-Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead"><a href="#2-解决remote-Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead" class="headerlink" title="2.解决remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead."></a>2.解决remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</h3><p>请看<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015.">这篇博客</a></p><h3 id="3-解决remote-Permission-to-xxx-xxx-github-io-git-denied-to-xxx"><a href="#3-解决remote-Permission-to-xxx-xxx-github-io-git-denied-to-xxx" class="headerlink" title="3.解决remote: Permission to xxx/xxx.github.io.git denied to xxx."></a>3.解决remote: Permission to xxx/xxx.github.io.git denied to xxx.</h3><p>fatal: unable to access ‘<a href="https://github.com/reinhart-l/reinhart-l.github.io.git/&#39;">https://github.com/reinhart-l/reinhart-l.github.io.git/&#39;</a>: The requested URL returned error: 403</p><ul><li><p>当<code>hexo d</code>成功后让你输入用户名和密码，可能会出现以上报错</p><p>注意这里输入的密码是github的token token如何获取请看<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">这篇博客</a></p></li></ul><h4 id="方案汇总：-1"><a href="#方案汇总：-1" class="headerlink" title="方案汇总："></a>方案汇总：</h4><ul><li><p>若报错形如<code>remote: Permission to XXXA/xxxx.git denied to XXXB</code></p><p>可能是电脑上有多个ssh密钥和用户导致的，详细解决可以看<a href="https://blog.csdn.net/hahahhahahahha123456/article/details/81104977">这篇博客</a></p></li><li><p>若用户名和密钥对应，去github检查一下token的repo权限有没有开。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180057052.png" alt="image-20220113115241999"></p></li></ul><h3 id="4-解决hexo搭建Github博客上传后，网页显示404问题"><a href="#4-解决hexo搭建Github博客上传后，网页显示404问题" class="headerlink" title="4.解决hexo搭建Github博客上传后，网页显示404问题"></a>4.解决hexo搭建Github博客上传后，网页显示404问题</h3><ul><li><p>进入<code>hexo</code>文件夹里的<code>_config.yml</code>文件</p><p>将<code>repo: git@github.com:xxx/xxx.github.io.git</code>更改为https地址</p><p><code>repo: https://github.com/xxx/xxx.github.io.git</code></p></li><li><p>其他解决方案参考<a href="https://blog.csdn.net/dajian790626/article/details/78595684">这篇博客</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA 挖地雷</title>
      <link href="/2021/10/18/PTA%20%E6%8C%96%E5%9C%B0%E9%9B%B7/"/>
      <url>/2021/10/18/PTA%20%E6%8C%96%E5%9C%B0%E9%9B%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h3><p>在一个地图上有n个地窖（n≤200）,每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径，并规定路径都是单向的,且保证都是小序号地窖指向大序号地窖，也不存在可以从一个地窖出发经过若干地窖后又回到原来地窖的路径。某人可以从任意一处开始挖地雷，然后沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使他能挖到最多的地雷。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行：地窖的个数；</p><p>第二行：为依次每个地窖地雷的个数；</p><p>下面若干行：</p><p>xi yi 表示从xi可到yi，xi&lt;yi。</p><p>最后一行为”0 0”表示结束。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>k1-k2−…−kv 挖地雷的顺序 挖到最多的雷。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span><span class="number">-4</span><span class="number">-5</span><span class="number">-6</span></span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>本题是一个数字三角形模型的动态规划,定义$dp[i]$为到第i个点能挖到的最多地雷数,因为题目保证都是小序号地窖指向大序号地窖,所以转移方程为$dp[j]=max(dp[j],dp[i]+p[j])$($p[j]是点j的地雷数$).本题难点是记录路径.我们可以用一个数组path[i],每次dp方程转移时记录转移到该点的上一个点是谁($path[j]=i$),最后再找到能挖到最多地雷数的那个点,倒序输出path即可.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h3><ul><li>如果wa最后一个点可以试试这个测试样例:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>记得要将$dp[i]初始化为p[i]$</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">205</span>],n,dp[<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;,path[<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;,pre[<span class="number">205</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;p[i];</span><br><span class="line">dp[i]=p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">0</span>&amp;&amp;v==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">vis[u][v]=<span class="literal">true</span>;<span class="comment">//vis[u][v]意思是u这个点可以到v这个点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i][j]&amp;&amp;dp[i]+p[j]&gt;dp[j])&#123;</span><br><span class="line">dp[j]=dp[i]+p[j];</span><br><span class="line">path[j]=i;<span class="comment">//记录路径</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i]&gt;ans)&#123;</span><br><span class="line">ans=dp[i];</span><br><span class="line">k=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pre[<span class="number">0</span>]=k;<span class="comment">//pre[i]作用是倒序记录path</span></span><br><span class="line"><span class="type">int</span> d=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(path[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">pre[d]=path[k];</span><br><span class="line">k=path[k];</span><br><span class="line">d++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;pre[d<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=d<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;pre[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（南京）E.Evil Coordinate (分类讨论+模拟)</title>
      <link href="/2021/10/13/%E7%AC%AC%2045%20%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E5%8D%97%E4%BA%AC%EF%BC%89E.Evil%20Coordinate%20(%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA+%E6%A8%A1%E6%8B%9F)/"/>
      <url>/2021/10/13/%E7%AC%AC%2045%20%E5%B1%8A%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88ICPC%EF%BC%89%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%EF%BC%88%E5%8D%97%E4%BA%AC%EF%BC%89E.Evil%20Coordinate%20(%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA+%E6%A8%A1%E6%8B%9F)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/21739/E">https://ac.nowcoder.com/acm/contest/21739/E</a></p><ul><li>这题有更简单的做法(枚举UDLR全排列),我用这个分类讨论的方法折腾了2个半小时才终于AC….</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><ul><li><p>1.首先我们可以想到,给定了一个走法的序列,不管这个序列的排列是怎样,它的终点一定确定了.所以炸弹(mx,my)如果在起点(0,0)或终点(x,y)那结果肯定是$Impossible$.</p></li><li><p>2.还有一种$Impossible$的情况就是当X轴方向没有步数($Cnt_R=0&amp;&amp;<br>Cnt_L=0$)且炸弹在Y轴方向的必经之路上;当Y轴方向没有步数($Cnt_U=0&amp;&amp;<br> Cnt_D=0$)且炸弹在X轴方向的必经之路上.</p></li><li><p>3.除去上面两种,剩余情况都是总能找到一个序列使机器人不经过炸弹的. 我们可以分情况讨论:</p><ul><li><p>a.终点不在坐标轴上</p><p>我们将路径简化为两种,先横着走再后竖着走和先竖着走再横着走.</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ab7e903d73c29fe534f33e64787498d8.png" alt="image-20211013230143511"></p></li></ul><p>这种情况比较简单,只需要判断炸弹是否在任意一条路径上,那么不走这条路径即可.例如:若炸弹在1上,那就走2;若炸弹在2上或者炸弹在其他地方,那就走1.</p><ul><li><p>b.终点在坐标轴上</p><p>这种情况看似简单,实则比较复杂.例如:终点在Y轴上,那说明L和R的步数相等.但先L或先R可能会对答案造成影响,所以我们要进行一些判断.例如:炸弹若在X轴下方,那么我们先U后D肯定不会有问题;炸弹若在Y轴左方,那先R和L肯定不会有问题.(会有问题的我们已经在第二种impossible中筛掉了).这里语言描述起来会比较麻烦,直接看代码应该会比较好理解.</p></li></ul></li><li><p>4.最后要注意一下正负号的问题,然后把每种情况交代清楚,应该就能AC了.</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll mx, my;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tong</span><span class="params">(ll x, ll y)</span> </span>&#123;<span class="comment">//判断两个数是否同号</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, ll&gt; mp;</span><br><span class="line">    cin &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">    string path;</span><br><span class="line">    cin &gt;&gt; path;</span><br><span class="line">    <span class="type">int</span> len = path.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;L&#x27;</span>)mp[<span class="string">&#x27;L&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (path[i] == <span class="string">&#x27;R&#x27;</span>)mp[<span class="string">&#x27;R&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (path[i] == <span class="string">&#x27;U&#x27;</span>)mp[<span class="string">&#x27;U&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (path[i] == <span class="string">&#x27;D&#x27;</span>)mp[<span class="string">&#x27;D&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x = mp[<span class="string">&#x27;R&#x27;</span>] - mp[<span class="string">&#x27;L&#x27;</span>];<span class="comment">//计算终点（一定会到达）</span></span><br><span class="line">    ll y = mp[<span class="string">&#x27;U&#x27;</span>] - mp[<span class="string">&#x27;D&#x27;</span>];</span><br><span class="line">    <span class="comment">//炸弹的位置在终点或起点</span></span><br><span class="line">    <span class="keyword">if</span> ((mx == x &amp;&amp; my == y) || (mx == <span class="number">0</span> &amp;&amp; my == <span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//只能在Y轴移动，炸弹在必经之路上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((!mp[<span class="string">&#x27;L&#x27;</span>] &amp;&amp; !mp[<span class="string">&#x27;R&#x27;</span>]) &amp;&amp; (<span class="built_in">tong</span>(my, y) &amp;&amp; <span class="built_in">abs</span>(my) &lt;= <span class="built_in">abs</span>(y) &amp;&amp; mx == <span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//只能在X轴移动，炸弹在必经之路上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((!mp[<span class="string">&#x27;U&#x27;</span>] &amp;&amp; !mp[<span class="string">&#x27;D&#x27;</span>]) &amp;&amp; (<span class="built_in">tong</span>(mx, x) &amp;&amp; <span class="built_in">abs</span>(mx) &lt;= <span class="built_in">abs</span>(x) &amp;&amp; my == <span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//L和R最终抵消了</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            string ans;</span><br><span class="line">            <span class="keyword">if</span> (mx &gt; <span class="number">0</span>) &#123;<span class="comment">//炸弹在Y轴右侧，那么就先走左面</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (my &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//炸弹在X轴下侧，那么就先走上面</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (my &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//U和D最终抵消了</span></span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            string ans;</span><br><span class="line">            <span class="keyword">if</span> (my &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//炸弹在X轴上侧，那么就先走下面</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span>) &#123;<span class="comment">//炸弹在Y轴左侧，那么就先走右面</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点不在坐标轴上，可以通过先横后竖或者先竖后横的方法走</span></span><br><span class="line">        <span class="keyword">if</span> ((my == <span class="number">0</span> || mx == x)) &#123;<span class="comment">//如果炸弹不在先横后竖的走法上，那就走先竖后横</span></span><br><span class="line">            string ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            string ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;L&#x27;</span>]; i++) ans += <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;R&#x27;</span>]; i++) ans += <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;U&#x27;</span>]; i++) ans += <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[<span class="string">&#x27;D&#x27;</span>]; i++) ans += <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA 租用游艇问题</title>
      <link href="/2021/10/12/PTA%20%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/12/PTA%20%E7%A7%9F%E7%94%A8%E6%B8%B8%E8%89%87%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>长江游艇俱乐部在长江上设置了n个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n所需的最少租金。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h2><p>第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的第1到第n-1 行，第i行表示第i站到第i+1站,第i+2站, … , 第n站的租金。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">15</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><p>我们可以想到如果要求第1个站到第n站的租金最小值,所可以$O(N^2)$枚举1-&gt;n站之间所有可能的情况——比如从第1个站到第3个站可以直接从第1个站到第3个站，也可以从第1个站先到第2个站再从第2个站到第3个站.所以我们需要用一个数组$dp[i][j]$记录第i个站到第j个站的最小租金,不断通过枚举更新这个数组,最终$dp[1][n]$就是第1个站到第n个站的最小租金,也就是我们要求的答案.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> r[<span class="number">205</span>][<span class="number">205</span>];<span class="comment">//r[i][j]定义是从第i个站到第j个站的租金值</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">205</span>][<span class="number">205</span>];<span class="comment">//dp[i][j]定义是从第i个站到第j个站的租金最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);<span class="comment">//初始化dp数组，因为我们要求的是租金最小值，所以将dp数组全部初始化为一个很大的值</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; r[i][j];</span><br><span class="line">            dp[i][j] = r[i][j];<span class="comment">//初始化dp数组 从第i个站到第j个站的值先初始为r[i][j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt; j; k++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="built_in">min</span>(dp[<span class="number">1</span>][j], dp[<span class="number">1</span>][k] + dp[k][j]);<span class="comment">//对于1-&gt;n之间所有的站两两之间都枚举所有情况然后取其最小值</span></span><br><span class="line">            <span class="comment">//比如从第1个站到第3个站可以直接从第1个站到第3个站，也可以从第1个站先到第2个站再从第2个站到第3个站</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为所有站两两之间的租法全部遍历过了，所以保证了结果的正确性</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n];<span class="comment">//根据题意我们要求的是第1个站到第n个站的租金最小值，所以dp[1][n]为所求，输出即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCPC 2021 网络预选赛重赛 hdu 7131-Nun Heh Heh Aaaaaaaaaaa (计数dp-公共子序列模型)</title>
      <link href="/2021/10/11/CCPC%202021%20%E7%BD%91%E7%BB%9C%E9%A2%84%E9%80%89%E8%B5%9B%20%E9%87%8D%E8%B5%9B%20hdu%207131-Nun%20Heh%20Heh%20Aaaaaaaaaaa%20(%E8%AE%A1%E6%95%B0dp-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B)/"/>
      <url>/2021/10/11/CCPC%202021%20%E7%BD%91%E7%BB%9C%E9%A2%84%E9%80%89%E8%B5%9B%20%E9%87%8D%E8%B5%9B%20hdu%207131-Nun%20Heh%20Heh%20Aaaaaaaaaaa%20(%E8%AE%A1%E6%95%B0dp-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B)/</url>
      
        <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=7131">http://acm.hdu.edu.cn/showproblem.php?pid=7131</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个序列s,求其[前缀是𝚗𝚞𝚗𝚑𝚎𝚑𝚑𝚎𝚑,后缀是&gt;=1个a]的子序列个数</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>先求出子序列为nunhehheh的个数,定义dp(i,j)为s的前i个字符中和nunhehheh匹配到第j个个数.然后预处理出i后面有多少个a,记为a[i],对于每个dp(i,9)乘$2^{a[i]}$再相加即可得到所有方案数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;avx&quot;</span>,<span class="string">&quot;sse2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">15</span>];</span><br><span class="line">ll a[N];</span><br><span class="line">ll poww[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    string p = <span class="string">&quot;@nunhehheh&quot;</span>;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    ll len =<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len+<span class="number">1</span>; i++) &#123;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//与s中第i个字符一个都不匹配的数量是1</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>)a[i] = (a[i + <span class="number">1</span>] + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i] = a[i + <span class="number">1</span>];<span class="comment">//预处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j])dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] % mod;<span class="comment">//算公共序列个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            ans += (dp[i][<span class="number">8</span>] * (poww[a[i]] - <span class="number">1</span>)) % mod;<span class="comment">//注意这里是dp[i][8].如用dp[i][9]算答案会重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    poww[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e5</span>;i++)&#123;</span><br><span class="line">       poww[i] =(poww[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 218-ABCDEF 题解</title>
      <link href="/2021/09/12/AtCoder%20Beginner%20Contest%20218-ABCDEF%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/09/12/AtCoder%20Beginner%20Contest%20218-ABCDEF%20%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://atcoder.jp/contests/abc218/tasks">https://atcoder.jp/contests/abc218/tasks</a></p><h3 id="A-Weather-Forecast"><a href="#A-Weather-Forecast" class="headerlink" title="A - Weather Forecast"></a>A - Weather Forecast</h3><p>水题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(s[n<span class="number">-1</span>]==<span class="string">&#x27;o&#x27;</span>)cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B-qwerty"><a href="#B-qwerty" class="headerlink" title="B - qwerty"></a>B - qwerty</h3><p>水题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        s+=<span class="built_in">char</span>(a[i]+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-Shapes"><a href="#C-Shapes" class="headerlink" title="C - Shapes"></a>C - Shapes</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h4><p>两个$N<em>N$矩阵A,B都由</em>和#构成,你可以对B进行任意次90度旋转(正逆时针都可)和对#图形进行整体的平移,如果最后B能和A完全一样输出Yes,否则输出No</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h4><p>枚举每一种有效的旋转(最多三次),然后每次都将A和B的#图形移到最左上角,看#的数目和位置是否一致.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="type">char</span> a[maxn][maxn], b[maxn][maxn], c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; ma;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; save1, save2;</span><br><span class="line"><span class="type">bool</span> ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> mnr = INF, mnc = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                save1.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                mnr = <span class="built_in">min</span>(mnr, i);</span><br><span class="line">                mnc = <span class="built_in">min</span>(mnc, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; save1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        save1[i].first -= mnr;</span><br><span class="line">        save1[i].second -= mnc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (save1.<span class="built_in">size</span>() != save2.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it: save1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ma[it])<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ok = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> mnr = INF, mnc = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)cin &gt;&gt; a[i][j], c[i][j] = a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line">            <span class="keyword">if</span> (b[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                save2.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">                mnr = <span class="built_in">min</span>(mnr, i);</span><br><span class="line">                mnc = <span class="built_in">min</span>(mnc, j);<span class="comment">//找到最左上角的那个#</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; save2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        save2[i].first -= mnr;<span class="comment">//将所有#向左上角移</span></span><br><span class="line">        save2[i].second -= mnc;</span><br><span class="line">        ma[save2[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                c[j][n - i + <span class="number">1</span>] = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)a[i][j] = c[i][j];</span><br><span class="line">        <span class="built_in">check</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">if</span> (ok)<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="D-Rectangles"><a href="#D-Rectangles" class="headerlink" title="D - Rectangles"></a>D - Rectangles</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意:"></a>题意:</h4><p>在二维平面上给n个坐标,求坐标能构成的所有平行于X,Y轴的矩形的数目.</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解:"></a>题解:</h4><p>以x坐标为基准,当y轴相等时,如果下一条边和这条边的长度、位置都相同,那就可以构成一个矩形.所以只需要枚举所有点,当两个点y坐标相同时记录下两点构成的线段的位置和长度,当下一次又出现同一位置和长度的线段时,就可以构成一个矩形… 以此类推.用一个map记录</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">vector&lt;PII&gt;v;</span><br><span class="line">map&lt;pair&lt;ll,<span class="type">double</span> &gt; ,ll&gt;cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        v.<span class="built_in">pb</span>(&#123;x,y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].se == v[j].se) &#123;</span><br><span class="line">                ll len = <span class="built_in">abs</span>(v[i].fi - v[j].fi);</span><br><span class="line">                <span class="type">double</span> xx = (v[i].fi + v[j].fi) * <span class="number">1.0</span> / <span class="number">2.0</span>;</span><br><span class="line">                ans += cnt[&#123;len, xx&#125;];</span><br><span class="line">                cnt[&#123;len, xx&#125;]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Destruction"><a href="#E-Destruction" class="headerlink" title="E - Destruction"></a>E - Destruction</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意:"></a>题意:</h4><p>给一个无向图,让你从中选出几个边,要求选出的边权总和最大并且剩下的图要是一个连通图.</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解:"></a>题解:</h4><p>要选出的边权总和最大,那就是让剩下的连通图边权总和最小,我们可以很容易想到最小生成树.但直接跑最小生成树是不行的,因为它有负边权.而负边我们是肯定不会选的,所以我们只需要特判一下,只要我们在跑最小生成树只要碰到负边权我们就给把它放进图里.(这样虽然不是树了但可以保证我们得到正确的答案)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span> <span class="comment">//重载运算符以便于能直接sort</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)<span class="comment">//找到的祖宗不相等说明不连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w &lt; <span class="number">0</span>)res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum - <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-Blocked-Roads"><a href="#F-Blocked-Roads" class="headerlink" title="F - Blocked Roads"></a>F - Blocked Roads</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意:"></a>题意:</h4><p>给定一个n个点,m条边的有向图,边权为1,对每个边i,求把这个边去掉的1-n的最短距离.</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解:"></a>题解:</h4><p>因为m最大是400<em>399.所以不能直接枚举边bfs.但我们可以想到,对于1-&gt;n的最短路来说,最多应该只有n-1条边是有效的,所以我们可以先bfs求一遍正常的1-&gt;n的最短路,把有效的边标记出来.然后再枚举m条边,如果这条边没有被标记过,说明去不去掉它对1-n的最短距离没有影响,所以直接输出1-n的最短距离.否则,就再在原图上求一次去掉边i的bfs,时间复杂度是</em>$O_{(N*(N+M))}$</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;pair&lt;int,int&gt;</span>,int&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N*N];</span><br><span class="line"><span class="type">int</span> dis[N], dis2[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">bool</span> st[N*N];</span><br><span class="line">map&lt;PII, <span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;<span class="type">int</span>, PII &gt; mp2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[t].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = g[t][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            dis[j] = dis[t] + <span class="number">1</span>;</span><br><span class="line">            pre[j] = t;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    dis2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[t].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = g[t][i];</span><br><span class="line">            <span class="keyword">if</span> (t == x &amp;&amp; j == y)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis2[j] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            dis2[j] = dis2[t] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        mp[&#123;a, b&#125;] = i;</span><br><span class="line">        mp2[i] = &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> now = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[&#123;pre[now], now&#125;]) &#123;</span><br><span class="line">            st[mp[&#123;pre[now], now&#125;]] = <span class="literal">true</span>;<span class="comment">//标记有效边</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        now = pre[now];</span><br><span class="line">        <span class="keyword">if</span> (now == <span class="number">1</span> || !now)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])cout &lt;&lt; dis[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis2, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis2);</span><br><span class="line">            <span class="type">int</span> x = mp2[i].fi;</span><br><span class="line">            <span class="type">int</span> y = mp2[i].se;</span><br><span class="line">            <span class="built_in">bfs2</span>(x, y);</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; dis2[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 113 C. Jury Meeting (思维+组合数学)</title>
      <link href="/2021/09/09/Educational%20Codeforces%20Round%20113%20C.%20Jury%20Meeting%20(%E6%80%9D%E7%BB%B4+%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6)/"/>
      <url>/2021/09/09/Educational%20Codeforces%20Round%20113%20C.%20Jury%20Meeting%20(%E6%80%9D%E7%BB%B4+%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1569/problem/C">https://codeforces.com/contest/1569/problem/C</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h4><p>n个数,每经过一个数它就-1,如果当所有数减完的时候没有一个数连续减了两次那这样一个序列就叫好序列,求所有好序列的数量,答案mod998244353</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h4><p>我们可以发现不管n是多少,到最后我们都只用看只剩下最后两个数的情况,而剩下的两个数肯定是最大数和次大数.</p><p>所以我们可以分以下三种情况讨论:</p><p><strong>1.最大数=次大数</strong></p><p>和位置无关,所有排列的序列都是好序列,答案为n!</p><p><strong>2.最大数&gt;=次大数+2</strong></p><p>所有序列都不是好序列,答案为0</p><p><strong>3.最大数只有一个,且次大数和最大数的差值为1</strong></p><p>我们通过观察可以发现,至少有一个次大数要在最大数的右边才是好序列,那么答案可以为全排列减去次大数全都在最大数左边的情况.</p><p>次大数圈都在最大数左边的方案数可以通过枚举最大数的位置来计算:</p><p>我们设有cnt个次大数,那么最大数就可以放在n~cnt+1的位置上.设最大数的位置为i,最大数左边的空位就是i-1个,右边的空位就是n- i个,次大数只能放在左边的位置,所以有$\binom{cnt}{i-1}$种放法,现在已经放了cnt个次大数和一个最大数,所以还剩下n-cnt-1个数,剩下的数可以随意放所以就是$(n-cnt-1)!$放法.</p><p>$(n-cnt-1)!*\binom{cnt}{i-1}$就是最大数放在第i个位置时不合法的方案数,枚举i从n~cnt+1,依次减掉即可.</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)res = res * a % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line">ll a[N];</span><br><span class="line">ll pre[N];<span class="comment">//pre[i]=1*2*...*i</span></span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(ll nn, ll mm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[nn] * <span class="built_in">qpow</span>(pre[nn - mm], mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll maxx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="keyword">if</span> (a[n - <span class="number">1</span>] &gt;= a[n - <span class="number">2</span>] + <span class="number">2</span>)cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[n - <span class="number">1</span>] == a[n - <span class="number">2</span>])cout &lt;&lt; pre[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[n - <span class="number">2</span>])cnt++;<span class="comment">//最大值不能在所有次大值的最右边</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = pre[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= cnt + <span class="number">1</span>; i--) &#123; <span class="comment">//i是最大值的位置 枚举i所在位置不是好序列的方案数</span></span><br><span class="line">            ll res = (<span class="built_in">A</span>(i - <span class="number">1</span>, cnt) * pre[n - cnt - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            ans = (ans - res + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2e5</span>; i++) &#123;</span><br><span class="line">        pre[i] = (pre[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 面向对象 | 继承与多态 简单理解和实例</title>
      <link href="/2021/09/06/JAVA%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20_%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%20%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/09/06/JAVA%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20_%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%20%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="程序需求"><a href="#程序需求" class="headerlink" title="程序需求"></a>程序需求</h2><p>1.编写一个 Cat 类，实现 1 个 shout()方法，该方法可以输出小猫的叫声“喵” </p><p>2.修改以上程序，为 Cat 类声明一个字段 name 和一个有参的构造函数，以便在实例化对象时，可以设置对象的名字；并使 shout()方法可以根据 name 的值输出对象的名字，如“我的名字叫…，喵”，同时实现默认构造函数。 </p><p>3.修改以上程序， 自行设计一个有参构造函数并调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name + <span class="string">&quot; Meow Meow Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.修改以上程序，利用私有字段和 get/set 方法实现能够控制猫的叫声的功能，让它叫几声，它就叫几声，并且能够输出叫声，但是最多叫 10 声。</p><p>5.修改以上程序，设计一个静态变量和静态方法统计并显示生成的实例个数。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;<span class="comment">//猫叫方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n,<span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Meow &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setN</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//设置猫的叫声数量</span></span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;<span class="comment">//返回实例个数</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.在上一堂课实现的程序基础上，仿照 Cat 类增加一个 Dog 类，也有 shout()方法，能够输出“我的名字叫…. 汪！汪！”等功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;<span class="comment">//狗叫方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n,<span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Woof &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setN</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//设置狗的叫声数量</span></span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;<span class="comment">//返回实例个数</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.分析 Cat 和 Dog 类的程序，可以发现它们有非常相似的代码。请建立一个父类 Animal 类，把Cat 和 Dog 相同的代码尽量放到 Animal 类中。</p><p>8.分析以上程序，可以发现 Cat 和 Dog 类都有 shout（）方法，只是叫的声音不同。请修改上述程序，为 Animal 类建立一个 shout()方法，然后让 Cat 和 Dog 去重写这个 shout()方法，实现多态。</p><p>9.在以上程序的基础上，增加牛和羊两种动物，而且都要叫出自己的声音。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setN</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//设置狗的叫声数量</span></span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;<span class="comment">//返回实例个数</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Meow &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Woof &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Mou &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Mie&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.分析以上程序，可以发现四种动物的 shout()方法中，除了动物叫的声音不同外，几乎是相同的。请把该方法在 Animal 类中实现，但是由于各种动物的叫声不同，需要增加一个方法 getSound()，在子类中获得各种动物的叫声。经过重构，所有的重复都放到父类中，子类变得非常简洁，而且容易修改。</p><p>11.由于 Animal 类根本不可能实例化也不需要实例化，所以可以把实例化没有任何意义的父类改成抽象类。请在以上程序的基础上，将 Animal 类改为抽象类，同时 getSound（）也应改为抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String Sound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(Sound+<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setN</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//设置动物的叫声数量</span></span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;<span class="comment">//返回实例个数</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Meow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Woof&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Mou&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Mie&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.在四种动物中，Cat 和 Dog 能捉老鼠，请将这个功能设计成接口，并分别由 Cat 和 Dog 两种动物继承实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CatchMouse</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Catch</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String Sound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(n, <span class="number">10</span>); i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(Sound+<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setN</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//设置狗的叫声数量</span></span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">()</span> &#123;<span class="comment">//返回实例个数</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">CatchMouse</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Meow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Catch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;as a cat caught a mouse&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">CatchMouse</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Woof&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Catch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;as a dog caught a mouse&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Mou&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSound</span><span class="params">()</span>&#123;</span><br><span class="line">        Sound=<span class="string">&quot;Mie&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181828750.png" alt="image-20210906204507440"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces Round 730 D1. RPD and Rap Sheet (Easy Version)题解</title>
      <link href="/2021/07/08/CodeForces%20Round%20730%20D1.%20RPD%20and%20Rap%20Sheet%20(Easy%20Version)%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/07/08/CodeForces%20Round%20730%20D1.%20RPD%20and%20Rap%20Sheet%20(Easy%20Version)%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1543">Codeforces Round #730 (Div. 2)</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>t组数据,每组给一个n和k,(easy version里面k=2) 每一次系统会输入一个初始的密码(初始密码是一个在$[0,n-1]$的随机值),你可以最多输出n次询问,如果猜对了密码系统会输入1,否则输入0.但密码不是不变的,每次会根据如下公式变化<br>$$<br>旧密码\bigoplus新密码=询问值<br>$$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><p>设初始密码为X,第i次询问值为$P_i$,新密码为Y</p><p>根据异或的交换律得到<br>$$<br>旧密码\bigoplus新密码=询问值\to 旧密码\bigoplus询问值=新密码\to X\bigoplus P_i=Y<br>$$<br>根据异或的结合律<br>$$<br>(((X\bigoplus P_1) \bigoplus P_2 )\bigoplus … P_i)=X\bigoplus (P_1 \bigoplus P_2 \bigoplus … P_i)<br>$$<br><strong>所以可以把初始密码每次异或一个询问值得到一个新密码简化为是在异或了一堆询问值后得到一个新密码.</strong></p><p>现在我们假设$P_i=(i-1)\bigoplus P_1 \bigoplus P_2 \bigoplus … P_{i-1}$</p><p>可以得到<br>$$<br>P_{X+1}=X\bigoplus (P_1 \bigoplus P_2 \bigoplus … P_i\bigoplus… P_{X})<br>$$<br>我们惊奇的发现初始密码X异或上前X个询问的值就是<br>$$<br>X\bigoplus (P_1 \bigoplus P_2 \bigoplus … P_i\bigoplus… P_{X})<br>$$<br>所以询问到第X+1次时其询问值一定等于当前密码的值</p><p>还可以想到另一种<br>$$<br>P_1=0\P_i=(i-1)\bigoplus(i-2) \ 2&lt;=i&lt;=n<br>$$<br>因为<br>$$<br>第X+1次询问:P_{X+1}=X\bigoplus(X-1)\<br>而初始密码在经过X次询问等于X\bigoplus(0\bigoplus1\bigoplus 2\bigoplus1\bigoplus3\bigoplus2\bigoplus…X-1\bigoplus X-2)\to X\bigoplus(X-1)<br>$$<br>所以询问到第X+1次也可以得到当前密码值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;((i<span class="number">-1</span>)^(i<span class="number">-2</span>))&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            cin &gt;&gt; res;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cisco Packet Tracer 创建虚拟局域网 | 配置静态路由 | 配置RIP协议</title>
      <link href="/2021/06/04/Cisco%20Packet%20Tracer%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%20_%20%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%20_%20%E9%85%8D%E7%BD%AERIP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/06/04/Cisco%20Packet%20Tracer%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%20_%20%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%20_%20%E9%85%8D%E7%BD%AERIP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819966.png" alt="在这里插入图片描述"></p><h3 id="PC0配置"><a href="#PC0配置" class="headerlink" title="PC0配置"></a><strong>PC0配置</strong></h3><p><img src="https://img-blog.csdnimg.cn/20210604201955803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlaW5oYXJ0X0w=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="PC1配置"><a href="#PC1配置" class="headerlink" title="PC1配置"></a><strong>PC1配置</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819542.png" alt="image-20220118181959497"></p><h3 id="PC2配置"><a href="#PC2配置" class="headerlink" title="PC2配置"></a><strong>PC2配置</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819015.png" alt="在这里插入图片描述"></p><h3 id="Switch0配置"><a href="#Switch0配置" class="headerlink" title="Switch0配置"></a><strong>Switch0配置</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181820475.png" alt="image-20220118182016420"></p><h3 id="switch1配置"><a href="#switch1配置" class="headerlink" title="switch1配置"></a><strong>switch1配置</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181820031.png" alt="image-20220118182032959"><img src="" alt="在这里插入图片描述"></p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p><strong>PC0和PC2同属vlan2，PC1属于vlan1，所以PC0和2可以互相ping通，而PC0和PC1ping不通</strong><br><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819469.png" alt="在这里插入图片描述"></p><h2 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181820467.png" alt="image-20220118182048424"></p><h3 id="PC1"><a href="#PC1" class="headerlink" title="PC1"></a>PC1</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819667.png" alt="在这里插入图片描述"></p><h3 id="PC2"><a href="#PC2" class="headerlink" title="PC2"></a>PC2</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181820250.png"></p><p>PC1 Fa0/0 接口 $\to$ router1 Fa1/0 接口</p><p>PC2 Fa0/0 接口 $\to$ router2 Fa1/0 接口</p><p>Router1 serial 2/0 $\to$  router2 serial 2/0</p><h3 id="Router1"><a href="#Router1" class="headerlink" title="Router1"></a>Router1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">         --- System Configuration Dialog ---</span><br><span class="line"></span><br><span class="line">Would you like to enter the initial configuration dialog? [yes/no]: no # 选择no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press RETURN to get started!</span><br><span class="line"></span><br><span class="line">r1&gt;enable # 进入admin模式</span><br><span class="line">r1#</span><br><span class="line">r1#configure terminal # 进入管理终端</span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">r1(config)#interface FastEthernet1/0 # 进入端口1/0</span><br><span class="line">r1(config-if)#ip address 192.168.1.1 255.255.255.0 # 配置端口的ip地址</span><br><span class="line">r1(config-if)#no shutdown # 开启此端口,使它转发数据</span><br><span class="line">%LINK-5-CHANGED: Interface FastEthernet1/0, changed state to up</span><br><span class="line"></span><br><span class="line">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet1/0, changed state to up</span><br><span class="line"></span><br><span class="line">r1(config-if)#exit # 退出</span><br><span class="line"></span><br><span class="line">r1(config)#interface serial 2/0 # 进入S2/0端口模式</span><br><span class="line">r1(config-if)#no shutdown # 开启此端口</span><br><span class="line"></span><br><span class="line">%LINK-5-CHANGED: Interface Serial2/0, changed state to down</span><br><span class="line">r1(config-if)#ip address 192.168.2.1 255.255.255.0 # 配置此端口的ip地址</span><br><span class="line">r1(config-if)#clock rate 9600 # 配置此端口的时钟速率</span><br><span class="line">r1(config-if)#exit # 退出</span><br><span class="line"></span><br><span class="line">r1(config)#ip route 192.168.3.0 255.255.255.0 192.168.2.2 # 配置静态路由</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="router2"><a href="#router2" class="headerlink" title="router2"></a>router2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">         --- System Configuration Dialog ---</span><br><span class="line"></span><br><span class="line">Would you like to enter the initial configuration dialog? [yes/no]: no # 选择no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press RETURN to get started!</span><br><span class="line"></span><br><span class="line">r1&gt;enable # 进入admin模式</span><br><span class="line">r1#</span><br><span class="line">r1#configure terminal # 进入管理终端</span><br><span class="line">Enter configuration commands, one per line.  End with CNTL/Z.</span><br><span class="line">r1(config)#interface FastEthernet1/0 # 进入端口1/0</span><br><span class="line">r1(config-if)#ip address 192.168.3.1 255.255.255.0 # 配置端口的ip地址</span><br><span class="line">r1(config-if)#no shutdown # 开启此端口,使它转发数据</span><br><span class="line">%LINK-5-CHANGED: Interface FastEthernet1/0, changed state to up</span><br><span class="line"></span><br><span class="line">%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet1/0, changed state to up</span><br><span class="line"></span><br><span class="line">r1(config-if)#exit # 退出</span><br><span class="line"></span><br><span class="line">r1(config)#interface serial 2/0 # 进入S2/0端口模式</span><br><span class="line">r1(config-if)#no shutdown # 开启此端口</span><br><span class="line"></span><br><span class="line">%LINK-5-CHANGED: Interface Serial2/0, changed state to down</span><br><span class="line">r1(config-if)#ip address 192.168.2.2 255.255.255.0 # 配置此端口的ip地址</span><br><span class="line">r1(config-if)#exit # 退出</span><br><span class="line"></span><br><span class="line">r1(config)#ip route 192.168.1.0 255.255.255.0 192.168.2.1 # 配置静态路由</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181821878.png" alt="image-20220118182107838"></p><h3 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h3><ul><li>真机实验一定要关闭防火墙</li><li>DTE线不用调节时钟频率(clock rate) ,DCE线需要</li></ul><h3 id="静态路由配置实验参考博客："><a href="#静态路由配置实验参考博客：" class="headerlink" title="静态路由配置实验参考博客："></a>静态路由配置实验参考博客：</h3><p><a href="https://blog.csdn.net/Muyunuu/article/details/117045655">https://blog.csdn.net/Muyunuu/article/details/117045655</a></p><h2 id="rip配置"><a href="#rip配置" class="headerlink" title="rip配置"></a>rip配置</h2><ul><li>只需删除静态路由实验中创建的路由表，再将其修改成RIP协议即可<h3 id="Router1-1"><a href="#Router1-1" class="headerlink" title="Router1"></a>Router1</h3><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819967.png" alt="在这里插入图片描述"></li></ul><h3 id="Router2"><a href="#Router2" class="headerlink" title="Router2"></a>Router2</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819988.png" alt="在这里插入图片描述"></p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181819000.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinhart&#39;s problem set</title>
      <link href="/2021/01/17/Reinhart&#39;s%20problem%20set/"/>
      <url>/2021/01/17/Reinhart&#39;s%20problem%20set/</url>
      
        <content type="html"><![CDATA[<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><h3 id="序列最大收益"><a href="#序列最大收益" class="headerlink" title="序列最大收益"></a><a href="https://www.acwing.com/problem/content/3502/">序列最大收益</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>相邻元素的值分别为可以获得收益现在给一个序列,可以删除最多k个元素使得这个序列的收益之和最大.</p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><h5 id="集合dp-i-j"><a href="#集合dp-i-j" class="headerlink" title="集合dp[i][j]"></a>集合dp[i][j]</h5><ul><li>表示只考虑前i个数，共删除了j个数，且第i个数没被删掉</li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li>最大值</li></ul><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>参考最长上升子序列模型</p><ul><li><p>以第i的前一个数作为划分条件</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181242366.png" alt="image-20210516112707913"></p></li></ul><p>i的前一个数有可能不存在，也有可能是第1个数…第i-1个数</p><p>所以得出此图</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050474.png" alt="image-20210516132250608"></p><p>1～K中还有j-(i-k-1)个数没删，而由于右边的值已经确定（就是）所以根据前面状态表示的定义可以得出<br>$$<br>dp[k,j-(i-k-1)]+w[a_k,a_j]<br>$$</p><h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><p>第一个数和最后一个数是不用删的，因为是&gt;=0的数，且1的左边，n的右边都已经没有数字了，删除1或n后不会产生新的数字组合，导致答案只减不增。</p><h3 id="E-Equal-Sentences"><a href="#E-Equal-Sentences" class="headerlink" title="E - Equal Sentences"></a><a href="https://vjudge.net/problem/HDU-6806">E - Equal Sentences</a></h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给一段话S，每段话有n个词，给定另一段话T，这段话所包含的词以及和S是一模一样的，唯一不同的就是词的顺序，T[i]和S[i]不同但只能在的范围内不同，也就是说S[i]必须要在T[i-1,i+1]内找到和S[i]相同的词，这样就算是T和S almost equal（包含S自己）问能找到多少个这样的T</p><h4 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h4><p>不难发现只要将S相邻两个词交换位置就可以得到一种情况，并且如果相邻两个词若是相同的交换它们不会增加方案数</p><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050562.png" alt="image-20210518005024148"></p><h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><h5 id="集合dp-i"><a href="#集合dp-i" class="headerlink" title="集合dp[i]"></a>集合dp[i]</h5><ul><li>长度为i的所有方案数</li></ul><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><ul><li>方案数</li></ul><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>参考最长上升子序列模型</p><p>以i的前一个字符作为划分条件</p><p>如果前一个字符(s[i-1])和s[i]相等，那如果s[i]和s[i-1]交换不会增加方案数，所以dp[i]=dp<a href="%E9%95%BF%E5%BA%A6%E4%B8%BAi%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%A1%88%E6%95%B0%E5%B0%B1%E7%AD%89%E4%BA%8E%E9%95%BF%E5%BA%A6%E4%B8%BAi-1%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%A1%88%E6%95%B0">i-1</a></p><p>如果前一个字符和s[i]不相等，s[i]和s[i-1]交换会增加方案数，s[i]和s[i-1]交换后s[i-1]变为s[i]，所以又新增了dp[i-2]的方案数，所以dp[i]=dp[i-1]+dp[i-2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod =<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line">string s[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>();</span><br><span class="line">    cin.<span class="built_in">tie</span>();</span><br><span class="line">    cout.<span class="built_in">tie</span>();</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">            cin&gt;&gt;s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>])dp[i]=dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i]=(dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n]%mod&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h2><h3 id="C-Hills"><a href="#C-Hills" class="headerlink" title="C.Hills"></a><a href="https://blog.csdn.net/weixin_30737363/article/details/94926310">C.Hills</a></h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>现在有 n 座连在一起的山，高度从左到右分别为。现在你有一台挖掘机，每分钟可以令某一个 减一。你可以在 且  的山峰 盖房子。问对于 中的每个整数 ，盖  栋房子至少需要多长时间。<img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/20211113125748.png" alt="截屏2021-11-13 12.57.38"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span> h[<span class="number">5050</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">5050</span>][<span class="number">5050</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">0x3fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(i+<span class="number">1</span>)/<span class="number">2</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">1</span>]=<span class="built_in">Min</span>(f[i<span class="number">-2</span>][j<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">Max</span>(<span class="number">0</span>,h[i<span class="number">-1</span>]-h[i]+<span class="number">1</span>),</span><br><span class="line">                           f[i<span class="number">-2</span>][j<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">Max</span>(<span class="number">0</span>,h[i<span class="number">-1</span>]-<span class="built_in">Min</span>(h[i],h[i<span class="number">-2</span>])+<span class="number">1</span>));</span><br><span class="line">            f[i][j][<span class="number">0</span>]=<span class="built_in">Min</span>(f[i<span class="number">-1</span>][j][<span class="number">0</span>],</span><br><span class="line">                           f[i<span class="number">-1</span>][j][<span class="number">1</span>]+<span class="built_in">Max</span>(<span class="number">0</span>,h[i]-h[i<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">Min</span>(f[n][i][<span class="number">0</span>],f[n][i][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Unstable-String"><a href="#C-Unstable-String" class="headerlink" title="C. Unstable String"></a><a href="https://codeforces.com/contest/1535/problem/C">C. Unstable String</a></h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>t 组询问，每次给定一个仅包含字符11 或 00 或 ?? 字符串s。定义一个子串是不稳定的当且仅当子串中任意相邻两数均不相同，如 101010…101010…或 010101…010101…。其中 ? 可以变为 11 或 00 其中一种。请求出给定的 𝑠s 中最多可以有的不稳定子串个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">200005</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//dp[i][0]表示以i结尾的串，并且s[i]是0，有多少种符合要求的串</span></span><br><span class="line">      <span class="comment">////dp[i][1]表示以i结尾的串，并且s[i]是1，有多少种符合要求的串</span></span><br><span class="line">      <span class="comment">//若s[i]是问号则取dp[i][1]和dp[i][0]的最大值（看把s[i]换成1还是换成0能取得更多的符合要求的串）</span></span><br><span class="line">        <span class="type">char</span> s[<span class="number">200005</span>];</span><br><span class="line">        cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//            if(s[i]==&#x27;?&#x27;)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>]=dp[i][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//?可以变成0或1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;(s+1)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(dp[i][<span class="number">0</span>], dp[i][<span class="number">1</span>]);<span class="comment">//题目默认要求将?最优的变成0或1</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-Gas-Pipeline"><a href="#C-Gas-Pipeline" class="headerlink" title="C. Gas Pipeline"></a><a href="https://codeforces.com/problemset/problem/1207/C">C. Gas Pipeline</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>二进制01串。为1代表这个地方得是高度为2的柱子，为0代表可以为高度为1或者2的柱子。起点和终点柱子高度都为1。同时横向走的时候需要管道。柱子的单位花费是b，管道的单位花费是a。问怎么安排使得花费最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//s[i]是第i个格子 dp[i][2]是第i根柱子 n个格子 n+1根柱子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    ll a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][<span class="number">1</span>] + a + <span class="number">2</span> * b, dp[i][<span class="number">0</span>] + <span class="number">2</span> * a + <span class="number">2</span> * b);</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][<span class="number">1</span>] + <span class="number">2</span> * a + b, dp[i][<span class="number">0</span>] + a + b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>] + a + <span class="number">2</span> * b;<span class="comment">//如果第i个格子为1 第i根柱子不可能为1个单位</span></span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = LLINF;<span class="comment">//如果第i个格子为1 第i+1根柱子不可能为1个单位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][<span class="number">0</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公共子序列模型"><a href="#公共子序列模型" class="headerlink" title="公共子序列模型"></a>公共子序列模型</h2><h3 id="PTA-两个字符串的所有最长公共子序列"><a href="#PTA-两个字符串的所有最长公共子序列" class="headerlink" title="PTA 两个字符串的所有最长公共子序列"></a><a href="https://pintia.cn/problem-sets/1719377570499891200/exam/problems/1719377856505286656?type=7&page=0">PTA 两个字符串的所有最长公共子序列</a></h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>求出所有的公共子序列，如果没有输出NO</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从<code>DP[n][m]</code>倒叙往后找</p><ul><li>若<code>a[i] b[j]</code>相等，那这一位则是LCS中的一位，然后递推到<code>i-1 j-1</code></li><li>若<code>a[i] b[j]</code>不相等，则需要比较<code>DP[i-1][j] DP[i][j-1]</code>大小<ul><li>若<code>DP[i-1][j]!=D[i][j-1]</code>则往较长的那个进行递推</li><li>若<code>DP[i-1][j]==D[i][j-1]</code>则两个都进行递推</li></ul></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>], b[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>], n, m;</span><br><span class="line">set&lt;string&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go_back</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">            str = a[i] + str;</span><br><span class="line">            i --, j --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                i --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &lt; dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">go_back</span>(i - <span class="number">1</span>, j, str);</span><br><span class="line">                <span class="built_in">go_back</span>(i, j - <span class="number">1</span>, str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">length</span>()) s1.<span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; (a+<span class="number">1</span>) &gt;&gt; (b+<span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(a+<span class="number">1</span>), m = <span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[n][m]==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">go_back</span>(n, m, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: s1) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-chokudai"><a href="#C-chokudai" class="headerlink" title="C - chokudai"></a><a href="https://atcoder.jp/contests/abc211/tasks/abc211_c?lang=en">C - chokudai</a></h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>算和子串p匹配的子序列个数</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line">ll dp[N][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    <span class="type">char</span> p[] = <span class="string">&quot;@chokudai&quot;</span>;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">strlen</span>(s+<span class="number">1</span>);i++)dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">strlen</span>(s+<span class="number">1</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j])dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] +dp[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;dp[<span class="built_in">strlen</span>(s+<span class="number">1</span>)][<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nun-Heh-Heh-Aaaaaaaaaaa"><a href="#Nun-Heh-Heh-Aaaaaaaaaaa" class="headerlink" title="Nun Heh Heh Aaaaaaaaaaa"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=7131">Nun Heh Heh Aaaaaaaaaaa</a></h3><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>给定一个序列s,求其[前缀是𝚗𝚞𝚗𝚑𝚎𝚑𝚑𝚎𝚑,后缀是&gt;=1个a]的子序列个数</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>先求出子序列为nunhehheh的个数,定义dp(i,j)为s的前i个字符中和nunhehheh匹配到第j个个数.然后预处理出i后面有多少个a,记为a[i],对于每个dp(i,9)乘再相加即可得到所有方案数</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target(<span class="string">&quot;avx&quot;</span>,<span class="string">&quot;sse2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">15</span>];</span><br><span class="line">ll a[N];</span><br><span class="line">ll poww[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    string p = <span class="string">&quot;@nunhehheh&quot;</span>;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    ll len =<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len+<span class="number">1</span>; i++) &#123;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//与s中第i个字符一个都不匹配的数量是1</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>)a[i] = (a[i + <span class="number">1</span>] + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i] = a[i + <span class="number">1</span>];<span class="comment">//预处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j])dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] % mod;<span class="comment">//算公共序列个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            ans += (dp[i][<span class="number">8</span>] * (poww[a[i]] - <span class="number">1</span>)) % mod;<span class="comment">//注意这里是dp[i][8].如用dp[i][9]算答案会重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    poww[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e5</span>;i++)&#123;</span><br><span class="line">       poww[i] =(poww[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="D-The-Fair-Nut-and-the-Best-Path"><a href="#D-The-Fair-Nut-and-the-Best-Path" class="headerlink" title="D. The Fair Nut and the Best Path"></a><a href="https://codeforces.com/problemset/problem/1084/D">D. The Fair Nut and the Best Path</a></h3><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>到达一个点得到这个点的价值，经过一个边花费这个边的价值，求得到的最大价值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];<span class="comment">//存每个点快乐指数</span></span><br><span class="line">vector&lt;PLL &gt; tree[N];</span><br><span class="line">ll dp[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span> </span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> son = tree[u][i].first;</span><br><span class="line">        <span class="keyword">if</span> (son == father)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(son, u);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans , dp[son] + dp[u] - tree[u][i].second);<span class="comment">//dp[son] + dp[u] - tree[u][i].second:倒v的形状,最大值+次大值</span></span><br><span class="line">        dp[u] = <span class="built_in">max</span>(dp[u], dp[son] + w[u] - tree[u][i].second);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[u]);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dp[i] = w[i], ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ll a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        tree[b].<span class="built_in">pb</span>(&#123;a, c&#125;);</span><br><span class="line">        tree[a].<span class="built_in">pb</span>(&#123;b, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Parsa’s-Humongous-Tree"><a href="#C-Parsa’s-Humongous-Tree" class="headerlink" title="C. Parsa’s Humongous Tree"></a><a href="https://codeforces.com/contest/1529/problem/C">C. Parsa’s Humongous Tree</a></h3><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>有一颗树,每个结点都有一个取值范围,答案为所有相邻点的绝对值之差之和,现在要你确定每个点的值,求最大答案.</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050500.png" alt="image-20211113214145142"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪心的要么取端点要么取右端点即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200005</span>,M=N*<span class="number">2</span>;<span class="comment">//无向图边数*2</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],h[N],idx;</span><br><span class="line"><span class="type">int</span> l[N],r[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i ; i=ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j==fa)<span class="keyword">continue</span>;<span class="comment">//不能往上面搜</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[j][<span class="number">0</span>]+<span class="built_in">abs</span>(l[u]-l[j]),dp[j][<span class="number">1</span>]+<span class="built_in">abs</span>(l[u]-r[j]));<span class="comment">//dp[i][0]是第i个点取左边</span></span><br><span class="line">        dp[u][<span class="number">1</span>]+=<span class="built_in">max</span>(dp[j][<span class="number">0</span>]+<span class="built_in">abs</span>(r[u]-l[j]),dp[j][<span class="number">1</span>]+<span class="built_in">abs</span>(r[u]-r[j]));<span class="comment">//d p[i][1]是第i个点取右边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span> e);</span><br><span class="line">        <span class="built_in">memset</span>(ne,<span class="number">0</span>,<span class="keyword">sizeof</span> ne);</span><br><span class="line">        <span class="built_in">memset</span>(l,<span class="number">0</span>,<span class="keyword">sizeof</span> l);</span><br><span class="line">        <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span> r);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">            l[i]=<span class="built_in">read</span>();</span><br><span class="line">            r[i]=<span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            a=<span class="built_in">read</span>();</span><br><span class="line">            b=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(a, b);</span><br><span class="line">            <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);<span class="comment">//以1为分界点</span></span><br><span class="line">        cout&lt;&lt;<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">1</span>],dp[<span class="number">1</span>][<span class="number">0</span>])&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;=n ; ++i) &#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;dp[i][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i][1]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="D-FG-operation"><a href="#D-FG-operation" class="headerlink" title="D - FG operation"></a><a href="https://atcoder.jp/contests/abc220/tasks/abc220_d">D - FG operation</a></h3><p>给一个N长度只有0到9的序列，做以下两个操作F：将（x+y）%10 G：将（x*y）%10（x和y是序列最前面的两个数），将结果放入序列最前面，直到只剩下一个数。算出每个数剩下的可能个数。</p><p>由于序列是固定的（作为y），所以dp枚举0到9所有数（作为x），将F和G的结果加入下一层，即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atcoder/all&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> atcoder;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> mint = modint998244353;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    mint dp[n+<span class="number">1</span>][<span class="number">10</span>];<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][(j+a[i+<span class="number">1</span>])%<span class="number">10</span>] += dp[i][j];</span><br><span class="line">            dp[i+<span class="number">1</span>][(j*a[i+<span class="number">1</span>])%<span class="number">10</span>] += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll K=<span class="number">0</span>;K&lt;=<span class="number">9</span>;K++)&#123;</span><br><span class="line">        cout&lt;&lt;dp[n][K].<span class="built_in">val</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集-最小生成树-次小生成树"><a href="#并查集-最小生成树-次小生成树" class="headerlink" title="并查集/最小生成树/次小生成树"></a>并查集/最小生成树/次小生成树</h2><h3 id="D-Sum-of-Maximum-Weights"><a href="#D-Sum-of-Maximum-Weights" class="headerlink" title="D - Sum of Maximum Weights"></a><a href="https://atcoder.jp/contests/abc214/tasks/abc214_d?lang=en">D - Sum of Maximum Weights</a></h3><h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050523.png" alt="image-20211113220021550"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050189.png" alt="image-20211113220712515"></p><p>带权并查集:记录额外信息的并查集,此处记录的信息是集合的大小siz</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stru</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125; edges[N];</span><br><span class="line"><span class="type">int</span> fa[N], siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stru a, stru b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x)fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(a), y = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        siz[y] += siz[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; edges[i].u &gt;&gt; edges[i].v &gt;&gt; edges[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + n - <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += (ll) edges[i].w * (ll) siz[<span class="built_in">find</span>(edges[i].u)] * (ll) siz[<span class="built_in">find</span>(edges[i].v)];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;ans&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="built_in">merge</span>(edges[i].u, edges[i].v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PTA-社交集群-https-pintia-cn-problem-sets-1496741922278645760-problems-1496742006529630216"><a href="#PTA-社交集群-https-pintia-cn-problem-sets-1496741922278645760-problems-1496742006529630216" class="headerlink" title="[PTA 社交集群][https://pintia.cn/problem-sets/1496741922278645760/problems/1496742006529630216]"></a>[PTA 社交集群][<a href="https://pintia.cn/problem-sets/1496741922278645760/problems/1496742006529630216]">https://pintia.cn/problem-sets/1496741922278645760/problems/1496742006529630216]</a></h3><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><p>给n个人，每个人有k种爱好，[1,1000]的正整数代表不同爱好的编号。有部分相同爱好的人为一个集群。现在问这n个人一共组成了多少个集群，每个集群有多少人</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>对于每个人的k个爱好，把这k个爱好用并查集merge成一坨，然后直接遍历并查集p[1-1000]就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> p[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)p[i]=i;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:&quot;</span>,&amp;m);</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            cin&gt;&gt;y;</span><br><span class="line">            p[<span class="built_in">find</span>(x)]=p[<span class="built_in">find</span>(y)];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i]=p[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mp[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        mp[<span class="built_in">find</span>(a[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(mp+<span class="number">1</span>,mp+<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(mp+<span class="number">1</span>,mp+<span class="number">1001</span>);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[i]&gt;<span class="number">0</span>)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag)cout &lt;&lt; mp[i], tag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> d[N][N] ;<span class="comment">// d[i][j]代表i到j点的路径上最大的一条边 (如果N较大可以用哈希表)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path[N]; <span class="comment">//扩展路径，path数组，缩写p</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> vis;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span> <span class="comment">//重载运算符以便于能直接sort</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> component = <span class="number">1</span>;<span class="comment">//连通分量数量</span></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        path[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;   <span class="comment">// 初始化并查集和路径</span></span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)<span class="comment">//找到的祖宗不相等说明不连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            edges[i].vis = <span class="literal">true</span>;<span class="comment">//标记进去最小生成树的集合</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j:path[a])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k:path[b]) &#123;</span><br><span class="line">                    d[j][k] = d[k][j] = w; <span class="comment">//d[i][j]代表i到j点的路径上最大的一条边(之前排过序,w是递增的)</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j:path[a]) path[b].<span class="built_in">push_back</span>(j); <span class="comment">//合并路径,标记a能到b</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i) != <span class="built_in">find</span>(i + <span class="number">1</span>)) &#123; component++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (component &gt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="type">int</span> res=INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span> (!edges[i].vis)  <span class="comment">//枚举每条没加入最小生成树的集合</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, ans + edges[i].w - d[edges[i].a][edges[i].b]);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>)cout &lt;&lt; <span class="string">&quot;No MST\n&quot;</span> &lt;&lt; component;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;ans)cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PTA-最小生成树的唯一性"><a href="#PTA-最小生成树的唯一性" class="headerlink" title="PTA-最小生成树的唯一性"></a><a href="https://pintia.cn/problem-sets/1714311041381445632/exam/problems/1714311145664425986?type=7&page=0">PTA-最小生成树的唯一性</a></h3><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>给定一个带权无向图，如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一。本题就要求你计算最小生成树的总权重，并且判断其是否唯一。</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>通过求并查集数量可得联通集个数，通过求次小生成树和最小生成树比较可得最小生成树是否唯一。</p><h3 id="E-Destruction"><a href="#E-Destruction" class="headerlink" title="E - Destruction"></a><a href="https://atcoder.jp/contests/abc218/tasks/abc218_e">E - Destruction</a></h3><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>给一个无向图,让你从中选出几个边,要求选出的边权总和最大并且剩下的图要是一个连通图.</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>要选出的边权总和最大,那就是让剩下的连通图边权总和最小,我们可以很容易想到最小生成树.但直接跑最小生成树是不行的,因为它有负边权.而负边我们是肯定不会选的,所以我们只需要特判一下,只要我们在跑最小生成树只要碰到负边权我们就给把它放进图里.(这样虽然不是树了但可以保证我们得到正确的答案)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span> <span class="comment">//重载运算符以便于能直接sort</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)<span class="comment">//找到的祖宗不相等说明不连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w &lt; <span class="number">0</span>)res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum - <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索-树"><a href="#搜索-树" class="headerlink" title="搜索/树"></a>搜索/树</h2><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="图k-着色问题"><a href="#图k-着色问题" class="headerlink" title="图k-着色问题"></a><a href="https://pintia.cn/problem-sets/1719376100966764544/exam/problems/1719376325957615616?type=7&page=0">图k-着色问题</a></h3><h4 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h4><p>给定一个n顶点m条边的无向图，k(k&lt;=n)种颜色，相邻两个顶点颜色不相同，问总共有多少种涂色方法</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>dfs枚举</p><p>将颜色用数字1~k表示。一开始能想到从第一个顶点开始涂第1种颜色，然后和它相邻的顶点涂第2种颜色。以此类推。题目要求涂色的方法数目，所以从第一个点开始就枚举涂1~k种颜色。然后枚举下一个点，若下一个点和这个点相邻且颜色相同，那就不能继续搜。反之则可以（相邻颜色不同或者直接不相邻都能继续涂色方案）若枚举的点数超过n说明涂色完了，是一种方案，所以方案数+1。其中要注意涂了色之后要还原现场。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> g[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//记录答案数量</span></span><br><span class="line"><span class="type">int</span> color[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> ok;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;n) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        color[u]=i;</span><br><span class="line">        ok=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[u][j]&amp;&amp;color[j]==color[u])&#123;</span><br><span class="line">                ok=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok)<span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">        color[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">        g[b][a]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="F-Distance-Sums-2"><a href="#F-Distance-Sums-2" class="headerlink" title="F - Distance Sums 2"></a><a href="https://atcoder.jp/contests/abc220/tasks/abc220_f">F - Distance Sums 2</a></h3><h4 id="题意-15"><a href="#题意-15" class="headerlink" title="题意"></a>题意</h4><p>给你n个点n-1条边，然后依次求出每个点到其他所有点的距离和</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>每次搜索计算该点的子节点数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL <span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;ll&gt; g[N];</span><br><span class="line">ll dis[N], son_size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u, ll fa, ll d)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)<span class="keyword">continue</span>;</span><br><span class="line">        dis[<span class="number">1</span>] += d + <span class="number">1</span>;<span class="comment">//根节点到其他所有点的距离之和</span></span><br><span class="line">        <span class="built_in">dfs</span>(i, u, d + <span class="number">1</span>);</span><br><span class="line">        son_size[u] += son_size[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll u, ll fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)<span class="keyword">continue</span>;</span><br><span class="line">        dis[i] = dis[u] - (son_size[i] - <span class="number">1</span>) + (n - son_size[i]<span class="number">-1</span>);<span class="comment">//每次从节点移动到其儿子,都可以通过这个节点到其他点的距离之和用该公式推出其儿子节点到其他点的距离之和</span></span><br><span class="line">        <span class="built_in">dfs2</span>(i, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)son_size[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; dis[1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NOI2011-道路修建"><a href="#NOI2011-道路修建" class="headerlink" title="[NOI2011]道路修建"></a>[NOI<a href="https://nanti.jisuanke.com/t/T2373">2011]道路修建</a></h3><h4 id="题意-16"><a href="#题意-16" class="headerlink" title="题意"></a>题意</h4><p>给定一棵树,对于每一条边,对于答案的贡献为边长*abs(所连两点两边的点的个数差)</p><p>和上题类似,硬模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL <span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">vector&lt;PLL &gt; g[N];</span><br><span class="line">ll sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u, ll fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.se == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i.se, u);</span><br><span class="line">        sz[u] += sz[i.se];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll u, ll fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//debug(sz[u]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.se == fa)<span class="keyword">continue</span>;</span><br><span class="line">        sum += i.fi * <span class="built_in">abs</span>(sz[i.se]  - (n-sz[i.se]));</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;i.se&lt;&lt;&#x27; &#x27;&lt;&lt;sz[i.se]&lt;&lt;&#x27; &#x27;&lt;&lt;sz[u]-sz[i.se]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        <span class="built_in">dfs2</span>(i.se, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)sz[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ll u, v, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(&#123;c, v&#125;);</span><br><span class="line">        g[v].<span class="built_in">pb</span>(&#123;c, u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;sz[i]&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="J-Kingdom’s-Power"><a href="#J-Kingdom’s-Power" class="headerlink" title="J - Kingdom’s Power"></a><a href="https://vjudge.net/problem/Gym-102769K">J - Kingdom’s Power</a></h2><p>贪心 先走深度浅的,最后走最深的.可以转化为对于当前父亲结点u所有不是最长的链都会走两次或者走一次+从根结点来一次,只有最长的链只用走一次</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050212.png" alt="image-20211105112131518"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll dep)</span> </span>&#123;</span><br><span class="line">    ll ma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[u]) &#123;</span><br><span class="line">        ll t = <span class="built_in">dfs</span>(i, dep + <span class="number">1</span>);<span class="comment">//叶子结点到当前结点的距离</span></span><br><span class="line">        ans += <span class="built_in">min</span>(dep, t);<span class="comment">//从根结点到当前结点,从叶子结点到当前结点,取一个最小值</span></span><br><span class="line">        ma = <span class="built_in">max</span>(ma, t);<span class="comment">//2.ma遇到分支后将分支的所有链长取最大值,就是该分支下的最长链长</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans -= <span class="built_in">min</span>(ma, dep);<span class="comment">//减掉最长的链重复走的</span></span><br><span class="line">    <span class="keyword">return</span> ma + <span class="number">1</span>;<span class="comment">//1.ma没遇到分支时就相当于只是递归的求叶子结点到当前结点的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">read</span>();</span><br><span class="line">        g[f].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端BFS"><a href="#双端BFS" class="headerlink" title="双端BFS"></a>双端BFS</h2><h3 id="E-Stronger-Takahashi"><a href="#E-Stronger-Takahashi" class="headerlink" title="E - Stronger Takahashi"></a><a href="https://atcoder.jp/contests/abc213/tasks/abc213_e?lang=en">E - Stronger Takahashi</a></h3><h4 id="题意-17"><a href="#题意-17" class="headerlink" title="题意"></a>题意</h4><p>从  走到 ，只能走在 <code>.</code> 上不能走在 <code>#</code> 上，每次可以消掉 2×2的 <code>#</code>，求最少消掉几次才能到终点。</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>走<code>#</code>花费为1,然后可以以0的花费走以这个<code>#</code>为中心的2x2,就相当于花1的花费直接瞬移到这些位置.</p><p>走<code>.</code>是0的花费</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050657.jpg" alt="261636814111_.pic"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    deque&lt;PII &gt; dq;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dq.<span class="built_in">pb</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = dq.<span class="built_in">front</span>();</span><br><span class="line">        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (st[t.fi][t.se])<span class="keyword">continue</span>;</span><br><span class="line">        st[t.fi][t.se] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a = t.fi + dx[i], b = t.se + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-1</span>; k &lt;= <span class="number">1</span>; k++) &#123;</span><br><span class="line">                        <span class="type">int</span> xx = a + j, yy = b + k;</span><br><span class="line">                        <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || xx &gt;= n || yy &lt; <span class="number">0</span> || yy &gt;= m)<span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (dis[t.fi][t.se] + <span class="number">1</span> &lt; dis[xx][yy]) &#123;</span><br><span class="line">                            dis[xx][yy] = dis[t.fi][t.se] + <span class="number">1</span>;</span><br><span class="line">                            dq.<span class="built_in">push_back</span>(&#123;xx, yy&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[t.fi][t.se] &lt; dis[a][b]) &#123;</span><br><span class="line">                    dis[a][b] = dis[t.fi][t.se];</span><br><span class="line">                    dq.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; m; j++)cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    cout &lt;&lt; dis[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h2 id="求最短路的路径数"><a href="#求最短路的路径数" class="headerlink" title="求最短路的路径数"></a>求最短路的路径数</h2><h3 id="D-Number-of-Shortest-paths"><a href="#D-Number-of-Shortest-paths" class="headerlink" title="D - Number of Shortest paths"></a><a href="https://atcoder.jp/contests/abc211/tasks/abc211_d?lang=en">D - Number of Shortest paths</a></h3><h4 id="题意-18"><a href="#题意-18" class="headerlink" title="题意"></a>题意</h4><p>n座城m条路，走每一条路的时间为1，问从City 1 到City n 的最短路有几条</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> minn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII &gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.se, distance = t.fi;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])<span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: g[ver]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] &gt;= distance + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i] == distance + <span class="number">1</span>)minn[i] =(minn[i]+ minn[t.se])%mod;<span class="comment">//记录条数</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dis[i] = distance + <span class="number">1</span>;</span><br><span class="line">                    minn[i]=minn[t.se];</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;minn[i]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dis[i], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        g[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    minn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; minn[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stl乱搞"><a href="#stl乱搞" class="headerlink" title="stl乱搞"></a>stl乱搞</h2><h2 id="优先队列乱搞"><a href="#优先队列乱搞" class="headerlink" title="优先队列乱搞"></a>优先队列乱搞</h2><h3 id="D-Querying-Multiset"><a href="#D-Querying-Multiset" class="headerlink" title="D - Querying Multiset"></a><a href="https://atcoder.jp/contests/abc212/tasks/abc212_d?lang=en">D - Querying Multiset</a></h3><h4 id="题意-19"><a href="#题意-19" class="headerlink" title="题意"></a>题意</h4><p>有很多球和一个空的包，q次操作，每次可以操作三种操作其中之一：</p><p>第一种操作：在球上写下一个数字x并放入包中</p><p>第二种操作：让包中所有球的数字+x</p><p>第三种操作：选择包中数字最小的球取出，并记录该球的数字</p><p>输出第三种操作取出的球的数字。</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>因为要选择最小数字的球取出，考虑优先队列。但在队列中第二种操作其实不方便操作，于是考虑对堆外的球进行反向操作，定义y为之前所有第二种操作的和，对之后的球上的数字减去一个y再放入包中（这样包中所有数字整体减小了y，其相对大小不变），在输出时补上y即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;PII &gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            heap.<span class="built_in">push</span>(x - ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; heap.<span class="built_in">top</span>() + ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Sorting-Queries"><a href="#E-Sorting-Queries" class="headerlink" title="E - Sorting Queries"></a><a href="https://atcoder.jp/contests/abc217/tasks/abc217_e">E - Sorting Queries</a></h3><h4 id="题意-20"><a href="#题意-20" class="headerlink" title="题意"></a>题意</h4><p>三种操作：</p><ol><li>向A数组中加入X</li><li>拿出A数组第一个元素，并输出</li><li>对数组进行排序</li></ol><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>用优先队列来维护有序的数。我们要拿第一个元素，肯定先拿我们排序的那些数，如果优先队列为空，那么我们拿普通队列里的元素。如果需要排序，我们将普通中的元素放进优先队列即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;&gt;&gt;q2;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        op = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)x = <span class="built_in">read</span>(), q1.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q2.<span class="built_in">empty</span>())<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q1.<span class="built_in">front</span>()),q1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q2.<span class="built_in">top</span>());</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>()),q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SET乱搞"><a href="#SET乱搞" class="headerlink" title="SET乱搞"></a>SET乱搞</h2><h3 id="D-Cutting-Woods"><a href="#D-Cutting-Woods" class="headerlink" title="D - Cutting Woods"></a><a href="https://atcoder.jp/contests/abc217/tasks/abc217_d">D - Cutting Woods</a></h3><h4 id="题意-21"><a href="#题意-21" class="headerlink" title="题意"></a>题意</h4><p>有一根长度为L的木头，这根木头上有L - 1个可以劈的点，对这根木头进行q次操作，操作有两种：操作一是往一个可劈点劈一刀，把这个点所在的木头段劈成两段；操作二是输出一个可劈点所在木头段的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c, x;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>)s1.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.<span class="built_in">size</span>()==<span class="number">1</span>)cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> pos1 = n, pos2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">auto</span> t = s1.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">                <span class="keyword">if</span> (t != s1.<span class="built_in">end</span>())pos1 = *t;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;*t&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">                t--;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;*t&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">                <span class="keyword">if</span> (t != s1.<span class="built_in">begin</span>())pos2 = *t;</span><br><span class="line">                cout &lt;&lt; pos1 - pos2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大模拟"><a href="#大模拟" class="headerlink" title="大模拟"></a>大模拟</h2><h2 id="Texas-hold’em-Poker"><a href="#Texas-hold’em-Poker" class="headerlink" title="Texas hold’em Poker"></a><a href="https://nanti.jisuanke.com/t/41408">Texas hold’em Poker</a></h2><p>模拟简化版的德州扑克</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> b[N][<span class="number">15</span>];</span><br><span class="line">string s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stru</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> rank,d1,d2,res;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(stru a,stru b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.rank!=b.rank)<span class="keyword">return</span> a.rank&gt;b.rank;</span><br><span class="line">    <span class="keyword">if</span>(a.d1!=b.d1)<span class="keyword">return</span> a.d1&gt;b.d1;</span><br><span class="line">    <span class="keyword">if</span>(a.d2!=b.d2)<span class="keyword">return</span> a.d2&gt;b.d2;</span><br><span class="line">    <span class="keyword">if</span>(a.res!=b.res)<span class="keyword">return</span> a.res&gt;b.res;</span><br><span class="line">    <span class="keyword">return</span> a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ran=<span class="number">0</span>,d1=<span class="number">0</span>,d2=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[idx][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;b[idx][<span class="number">10</span>]==<span class="number">1</span>&amp;&amp;b[idx][<span class="number">11</span>]==<span class="number">1</span>&amp;&amp;b[idx][<span class="number">12</span>]==<span class="number">1</span>&amp;&amp;b[idx][<span class="number">13</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">        ran=<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+<span class="number">4</span>&lt;=<span class="number">13</span>;i++)&#123;<span class="comment">//顺</span></span><br><span class="line">        <span class="keyword">if</span>(b[idx][i]==b[idx][i+<span class="number">1</span>]&amp;&amp;b[idx][i]==b[idx][i+<span class="number">2</span>]&amp;&amp;b[idx][i]==b[idx][i+<span class="number">3</span>]&amp;&amp;b[idx][i]==b[idx][i+<span class="number">4</span>]&amp;&amp;b[idx][i]==<span class="number">1</span>)&#123;</span><br><span class="line">            ran=<span class="number">7</span>;</span><br><span class="line">            d1=i+<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)&#123;<span class="comment">//葫芦</span></span><br><span class="line">        <span class="keyword">if</span>(b[idx][i]==<span class="number">4</span>) &#123;</span><br><span class="line">            ran = <span class="number">6</span>;</span><br><span class="line">            d1=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">13</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[idx][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    res = j;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="type">int</span> cnt3=<span class="number">0</span>,idx3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[idx][i]==<span class="number">3</span>)cnt3++,idx3=i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[idx][i]==<span class="number">2</span>)v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt3==<span class="number">1</span>&amp;&amp;v.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;<span class="comment">//全满</span></span><br><span class="line">        ran=<span class="number">5</span>;</span><br><span class="line">        d1=idx3;</span><br><span class="line">        d2=v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[idx][i]==<span class="number">1</span>)sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt3==<span class="number">1</span>&amp;&amp;v.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;<span class="comment">//三条</span></span><br><span class="line">        ran=<span class="number">4</span>;</span><br><span class="line">        d1=idx3;</span><br><span class="line">        res=sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;<span class="comment">//两对</span></span><br><span class="line">        ran=<span class="number">3</span>;</span><br><span class="line">        d1=<span class="built_in">max</span>(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">        d2=<span class="built_in">min</span>(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">        res=sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;<span class="comment">//一对</span></span><br><span class="line">        ran=<span class="number">2</span>;</span><br><span class="line">        d1=v[<span class="number">0</span>];</span><br><span class="line">        res=sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ran=<span class="number">1</span>;</span><br><span class="line">    res=sum;<span class="comment">//高牌</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n) &#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; ori;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i].name &gt;&gt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i].<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; s[i].<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i][j + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        b[i][<span class="number">10</span>]++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;A&#x27;</span>)b[i][<span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;J&#x27;</span>)b[i][<span class="number">11</span>]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;Q&#x27;</span>)b[i][<span class="number">12</span>]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;K&#x27;</span>)b[i][<span class="number">13</span>]++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i][s[i][j] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ran = <span class="number">0</span>, d1 = <span class="number">0</span>, d2 = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">judge</span>(i);</span><br><span class="line">            a[i].rank = ran;</span><br><span class="line">            a[i].d1 = d1;</span><br><span class="line">            a[i].d2 = d2;</span><br><span class="line">            a[i].res = res;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;a[i].name&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].rank&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].d1&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].d2&lt;&lt;&#x27; &#x27;&lt;&lt;res&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; a[i].name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-15th-Chinese-Northeast-Collegiate-Programming-Contest-M-Master-of-Shuangpin"><a href="#The-15th-Chinese-Northeast-Collegiate-Programming-Contest-M-Master-of-Shuangpin" class="headerlink" title="The 15th Chinese Northeast Collegiate Programming Contest M. Master of Shuangpin"></a>The 15th Chinese Northeast Collegiate Programming Contest M. Master of Shuangpin</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;string&gt; v[<span class="number">1005</span>];<span class="comment">//存输入</span></span><br><span class="line">string ans[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//存答案</span></span><br><span class="line"><span class="type">bool</span> st[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//已经被操作过的串标记一下 以免重复操作</span></span><br><span class="line">unordered_map&lt;string, string&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    mp[<span class="string">&quot;iu&quot;</span>] = <span class="string">&quot;q&quot;</span>, mp[<span class="string">&quot;en&quot;</span>] = <span class="string">&quot;f&quot;</span>, mp[<span class="string">&quot;ei&quot;</span>] = <span class="string">&quot;w&quot;</span>, mp[<span class="string">&quot;eng&quot;</span>] = <span class="string">&quot;g&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;ang&quot;</span>] = <span class="string">&quot;h&quot;</span>, mp[<span class="string">&quot;uan&quot;</span>] = <span class="string">&quot;r&quot;</span>, mp[<span class="string">&quot;an&quot;</span>] = <span class="string">&quot;j&quot;</span>, mp[<span class="string">&quot;ue&quot;</span>] = <span class="string">&quot;t&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;uai&quot;</span>] = <span class="string">&quot;k&quot;</span>, mp[<span class="string">&quot;ing&quot;</span>] = <span class="string">&quot;k&quot;</span>, mp[<span class="string">&quot;un&quot;</span>] = <span class="string">&quot;y&quot;</span>, mp[<span class="string">&quot;uang&quot;</span>] = <span class="string">&quot;l&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;iang&quot;</span>] = <span class="string">&quot;l&quot;</span>, mp[<span class="string">&quot;sh&quot;</span>] = <span class="string">&quot;u&quot;</span>, mp[<span class="string">&quot;ou&quot;</span>] = <span class="string">&quot;z&quot;</span>, mp[<span class="string">&quot;ch&quot;</span>] = <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;ia&quot;</span>] = <span class="string">&quot;x&quot;</span>, mp[<span class="string">&quot;ua&quot;</span>] = <span class="string">&quot;x&quot;</span>, mp[<span class="string">&quot;uo&quot;</span>] = <span class="string">&quot;o&quot;</span>, mp[<span class="string">&quot;ao&quot;</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;ie&quot;</span>] = <span class="string">&quot;p&quot;</span>, mp[<span class="string">&quot;zh&quot;</span>] = <span class="string">&quot;v&quot;</span>, mp[<span class="string">&quot;ui&quot;</span>] = <span class="string">&quot;v&quot;</span>, mp[<span class="string">&quot;in&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;ong&quot;</span>] = <span class="string">&quot;s&quot;</span>, mp[<span class="string">&quot;iong&quot;</span>] = <span class="string">&quot;s&quot;</span>, mp[<span class="string">&quot;iao&quot;</span>] = <span class="string">&quot;n&quot;</span>, mp[<span class="string">&quot;ai&quot;</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line">    mp[<span class="string">&quot;ian&quot;</span>] = <span class="string">&quot;m&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        s += <span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span> + <span class="number">0</span>);</span><br><span class="line">        mp[s] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123; <span class="comment">//处理输入</span></span><br><span class="line">        <span class="comment">//if(s==&quot;0&quot;)break;</span></span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                v[d].<span class="built_in">pb</span>(tmp);</span><br><span class="line">                tmp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp += s[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        v[d].<span class="built_in">pb</span>(tmp);</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][j].<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="comment">//只有一个字母的情况 直接复制 eg:a-&gt;aa b-&gt;bb...</span></span><br><span class="line">                ans[i][j] = v[i][j];</span><br><span class="line">                ans[i][j] += v[i][j];</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i][j].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;<span class="comment">//两个字母的情况:不用做任何操作,答案直接是它本身</span></span><br><span class="line">                ans[i][j] = v[i][j];</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> t:mp) &#123;<span class="comment">//单独一个 例如ang之类的情况</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t.fi == v[i][j]) &#123;</span><br><span class="line">                        ans[i][j] = t.fi[<span class="number">0</span>];</span><br><span class="line">                        ans[i][j] += t.se;</span><br><span class="line">                        st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++) &#123;<span class="comment">//声母是单个的情况，除了声母以外一定能找到一个长度大于1的韵母</span></span><br><span class="line">            <span class="keyword">if</span> (!st[i][j] &amp;&amp; mp.<span class="built_in">find</span>(v[i][j].<span class="built_in">substr</span>(<span class="number">1</span>)) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans[i][j] = v[i][j][<span class="number">0</span>];</span><br><span class="line">                ans[i][j] += mp[v[i][j].<span class="built_in">substr</span>(<span class="number">1</span>)];</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j] &amp;&amp; mp.<span class="built_in">find</span>(v[i][j].<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)) != mp.<span class="built_in">end</span>()) &#123;<span class="comment">//声母是两个的情况 例如ch sh</span></span><br><span class="line">                ans[i][j] = mp[v[i][j].<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>)];</span><br><span class="line">                <span class="keyword">if</span> (v[i][j].<span class="built_in">size</span>() &lt;= <span class="number">3</span>) &#123; <span class="comment">//只剩下一个韵母 答案直接加上它</span></span><br><span class="line">                    ans[i][j] += v[i][j][<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mp.<span class="built_in">find</span>(v[i][j].<span class="built_in">substr</span>(<span class="number">2</span>)) != mp.<span class="built_in">end</span>()) &#123;<span class="comment">//剩下两个韵母</span></span><br><span class="line">                        ans[i][j] += mp[v[i][j].<span class="built_in">substr</span>(<span class="number">2</span>)];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i][j] ;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;v[i].<span class="built_in">size</span>()<span class="number">-1</span>)cout&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;d<span class="number">-1</span>)<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><h3 id="Matrix-Power-Series"><a href="#Matrix-Power-Series" class="headerlink" title="Matrix Power Series"></a><a href="http://poj.org/problem?id=3233">Matrix Power Series</a></h3><p>给定矩阵A，求的结果（两个矩阵相加就是对应位置分别相加）。输出的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050662.png" alt="image-20211124161736825"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">ll tot,tota;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span> &#123;<span class="comment">//定义矩阵结构体</span></span><br><span class="line">    ll m[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mat</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="built_in">sizeof</span>(m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll n,k,mod;</span><br><span class="line">mat <span class="keyword">operator</span>*(mat a, mat b) &#123;<span class="comment">//定义矩阵乘法</span></span><br><span class="line">    mat ans;</span><br><span class="line">    ll x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; tot; k++) &#123;</span><br><span class="line">                x = (x + a.m[i][k] * b.m[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.m[i][j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">init</span><span class="params">(mat &amp;a)</span> </span>&#123;<span class="comment">//初始化单位矩阵（按要求自定义）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)&#123;</span><br><span class="line">            a.m[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span><br><span class="line">        a.m[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">mat_pow</span><span class="params">(mat a, ll k)</span> </span>&#123;<span class="comment">//矩阵快速幂</span></span><br><span class="line">    mat ans = <span class="built_in">init</span>(ans);</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mat a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    k=<span class="built_in">read</span>();</span><br><span class="line">    mod=<span class="built_in">read</span>();</span><br><span class="line">    tot=<span class="number">2</span>*n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            a.m[i][j]=<span class="built_in">read</span>();</span><br><span class="line">            a.m[i+n][j]=a.m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mat bas;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            bas.m[i][i]=<span class="number">1</span>;</span><br><span class="line">            bas.m[i+n][j+n]=a.m[i][j];</span><br><span class="line">            bas.m[i][j+n]=a.m[i][j];</span><br><span class="line">            bas.m[i+n][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bas= <span class="built_in">mat_pow</span>(bas,k<span class="number">-1</span>);</span><br><span class="line">    mat res=bas*a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;((res.m[i][j])%mod+mod)%mod&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="Matrix-Equation"><a href="#Matrix-Equation" class="headerlink" title="Matrix Equation"></a><a href="https://ac.nowcoder.com/acm/contest/10662/A">Matrix Equation</a></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050257.png" alt="image-20211113225909286"></p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050880.png" alt="截屏2021-11-10 23.08.34"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> origin_a[N][N];</span><br><span class="line"><span class="type">int</span> b[N][N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=(res*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            a[i][j]=origin_a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n + <span class="number">1</span>; i++) <span class="built_in">swap</span>(a[r][i], a[t][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)<span class="comment">//将下面所有行的第c列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">                    a[i][j] ^= a[r][j];<span class="comment">//该行第c列肯定是1，所以下面行异或该行第c列肯定可以消成0（两个1异或）</span></span><br><span class="line"></span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> n-r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] &amp; a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;origin_a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            a[j][j]=(origin_a[j][j]-b[j][i]+<span class="number">2</span>)%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">gauss</span>();</span><br><span class="line">        <span class="comment">//debug(d)</span></span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=(ans* <span class="built_in">qpow</span>(<span class="number">2</span>,d))%mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Acwing-207-球形空间产生器"><a href="#Acwing-207-球形空间产生器" class="headerlink" title="Acwing 207.球形空间产生器"></a><a href="https://www.acwing.com/problem/content/209/">Acwing 207.球形空间产生器</a></h3><p>给一个整数n和n+1行 表示一个n维球面上的n+1个n维坐标,求球心的坐标.</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/20211116235931.jpg" alt="281637078228_.pic"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> origin_a[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">double</span> a[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )<span class="comment">//枚举每一列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))<span class="comment">//找到绝对值最大的那一行</span></span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n + <span class="number">1</span>; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);<span class="comment">//把绝对值最大的一行换到最上面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];<span class="comment">//把该行第一个数变成1-&gt;倒着更新,不然第一个数先被更新成1除后面的数就无效了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];<span class="comment">//把下边所有行的第c列消成0</span></span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )<span class="comment">//倒着把其他系数全部消成0（解所在位置的系数是1）</span></span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)cin&gt;&gt;origin_a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            a[i][j]=<span class="number">2.0</span>*(origin_a[i+<span class="number">1</span>][j]-origin_a[<span class="number">0</span>][j]);</span><br><span class="line">            sum+=origin_a[i+<span class="number">1</span>][j]*origin_a[i+<span class="number">1</span>][j]-origin_a[<span class="number">0</span>][j]*origin_a[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i][n]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Acwing-208-开关问题"><a href="#Acwing-208-开关问题" class="headerlink" title="Acwing 208.开关问题"></a><a href="https://www.acwing.com/problem/content/210/">Acwing 208.开关问题</a></h3><h4 id="题意-22"><a href="#题意-22" class="headerlink" title="题意"></a>题意</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/20211117141706.png" alt="image-20211117141706411"></p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>解集矩阵:第个开关初态和终态一样第行的解集矩阵就是0,不一样就是1</p><p>为1表示第个开关会对第个开关产生影响</p><p>最后解出自由元个数,说明这个开关可以是任意的状态,所以方案数为</p><h3 id="2021-ICPC-Asia-Jinan-Regional-Contest-J-Determinant"><a href="#2021-ICPC-Asia-Jinan-Regional-Contest-J-Determinant" class="headerlink" title="2021 ICPC Asia Jinan Regional Contest J Determinant"></a><a href="https://pintia.cn/problem-sets/1459829212832296960/problems/1459829264400629769">2021 ICPC Asia Jinan Regional Contest J Determinant</a></h3><h4 id="题意-23"><a href="#题意-23" class="headerlink" title="题意"></a>题意</h4><p>给你一个行列式以及行列式的值的绝对值(长度可能是)求这个行列式的值是正还是负</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>先让大数模一个大素数(),然后求行列式取模的值,判断两个数相不相等,如果相等就是正数,不相等就是负数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll A[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_pow</span>(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gauss</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n; k++) <span class="built_in">swap</span>(A[i][k], A[j][k]);</span><br><span class="line">                <span class="keyword">if</span> (i != j) ans = -ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!A[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = i + <span class="number">1</span>, iv = <span class="built_in">inv</span>(A[i][i]); j &lt;= n; j++) &#123;</span><br><span class="line">            ll t = A[j][i] * iv % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">                A[j][k] = (A[j][k] - t * A[i][k] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans * A[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    ll ans = s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;len; i++) &#123;</span><br><span class="line">        ans = ((ans * <span class="number">10</span>)%mod + (s[i] - <span class="string">&#x27;0&#x27;</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="built_in">gauss</span>(n);</span><br><span class="line"><span class="comment">//    debug(res)</span></span><br><span class="line"><span class="comment">//    debug(ans)</span></span><br><span class="line">    <span class="keyword">if</span> (res == ans)cout &lt;&lt; <span class="string">&#x27;+&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分-三分"><a href="#二分-三分" class="headerlink" title="二分/三分"></a>二分/三分</h2><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><h3 id="P1883-函数"><a href="#P1883-函数" class="headerlink" title="P1883 函数"></a><a href="https://www.luogu.com.cn/problem/P1883">P1883 函数</a></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050010.png" alt="image-20211117195632379"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>],c[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,a[i]*x*x+b[i]*x+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">        b[i]=<span class="built_in">read</span>();</span><br><span class="line">        c[i]=<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>,r = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;=eps)&#123;<span class="comment">//精度问题</span></span><br><span class="line">        <span class="type">double</span> m1 = l + (r-l)/<span class="number">3.0</span>,m2 = r - (r-l)/<span class="number">3.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))</span><br><span class="line">            r = m2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m1;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,<span class="built_in">f</span>(l));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2020ICPC南京-F-Fireworks"><a href="#2020ICPC南京-F-Fireworks" class="headerlink" title="2020ICPC南京 F.Fireworks"></a><a href="https://ac.nowcoder.com/acm/contest/10272/F">2020ICPC南京 F.Fireworks</a></h3><h4 id="题意-24"><a href="#题意-24" class="headerlink" title="题意"></a>题意</h4><p>给定n，m，p，制作一个烟花需要花费n分钟，点燃的时候只有p/1e4的概率可以制作成真烟花，在做完一个烟花后，你可以花费m分钟一次性点燃之前所有烟花，如果至少有一个烟花成功释放，那么结束，否则继续，问如果采用最优策略，结束的最小期望时间。</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>设p为制作成功的概率 设为制作失败的概率 设最优解情况下是制作个之后点燃, 如果释放成功那么结束，如果释放失败那么下一次还是制作k个， 期望时间为 现在要找到最小的,容易推测出是单峰函数， 因此三分即可.</p><ul><li>注意调精度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">double</span> n,m,p;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll k)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res*=a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n*(<span class="type">double</span>)x+m)/(<span class="number">1.0</span>- <span class="built_in">pow</span>(<span class="number">1.0</span>-p,(<span class="type">double</span>)x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    p/=<span class="number">10000.0</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;f(1)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="type">int</span> m1=l+(r-l)/<span class="number">3</span>,m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))&#123;</span><br><span class="line">            r=m2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=LLINF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">f</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="P1843-奶牛晒衣服"><a href="#P1843-奶牛晒衣服" class="headerlink" title="P1843 奶牛晒衣服"></a><a href="https://www.luogu.com.cn/problem/P1843">P1843 奶牛晒衣服</a></h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050933.png" alt="image-20211117195828035"></p><ul><li>注意这里烘干机的最小使用单位是1s,题目没说</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll cha = <span class="number">0</span>, cnt = x;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; x * a) &#123;</span><br><span class="line">            cha = w[i] - x * a;</span><br><span class="line">            cnt -= (cha + b - <span class="number">1</span>) / b;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt&gt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        ma = <span class="built_in">max</span>(ma, w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ma = (ma + a - <span class="number">1</span>) / a;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = ma, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Occupy-the-Cities"><a href="#G-Occupy-the-Cities" class="headerlink" title="G - Occupy the Cities"></a><a href="https://codeforces.com/gym/103409/problem/G">G - Occupy the Cities</a></h3><h4 id="题意-25"><a href="#题意-25" class="headerlink" title="题意"></a>题意</h4><p>给一个01字符串，1代表被占领。每一轮所有的1可以向把相邻的其中一个变成1，问至少多少轮后可以使所有位置都是1。</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>因为轮数最少是0最多是串长减1，所以考虑二分轮数。check函数有一些细节：在中间的1，可以先向右扩展一个1（eg：00<strong>1</strong>10）或者先向左边扩展一个1（eg：01<strong>1</strong>00）然后两边一起扩展。假设二分的答案为x，如果对于一个最左边的1，这个1左边的0的个数都大于x了，那肯定是return false。但如果正好等于x的话，那就只能考虑先把左边扩展一个1，然后两边一起扩展的情况。如果大于x，那就可以先向右边扩展一个1，再向两边一起扩展。简单来说就是两种情况：1.左边扩x-1，右边扩x 2.左边扩x，右边扩x-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll N = <span class="number">5e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sz = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now + x + <span class="number">1</span> &lt; a[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (now + x &gt;= a[i]) &#123;</span><br><span class="line">            now = a[i] + x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            now = <span class="built_in">max</span>(a[i], a[i] + x - <span class="number">1</span>);<span class="comment">//取max是防止当x为0时，now反而还减小的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= a[i + <span class="number">1</span>]) &#123;<span class="comment">//如果能扩的比右边那个1的位置还大，那就把now置为正好把a[i]~a[i+1]整段扩完</span></span><br><span class="line">            now = a[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a><a href="https://www.acwing.com/problem/content/description/4083/">第k个数</a></h3><h4 id="题意-26"><a href="#题意-26" class="headerlink" title="题意"></a>题意</h4><p>给出一个矩阵，每一个位置上的数，把这些数按照非严格单调递增的顺序，问第k大的数是多少。()</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><p>是1e10的，考虑二分。每次二分一个数x，check小于等于x的数有多少个，如果个数大于等于x返回true（因为可能有超过1个数是等于x的，那其实也是符合要求的），然后发现第i行小于等于x的数就是,所以可以直接，算出来时间复杂度就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll a = x / i;</span><br><span class="line">        res += <span class="built_in">min</span>(a,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug(res);</span></span><br><span class="line">    <span class="keyword">if</span> (res &gt;= k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ll l = <span class="number">1</span>, r = n * m, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + r  &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//(mid);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))r= mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="comment">//printf(&quot;Case #%d: &quot;, cas);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1182-数列分段-Section-II"><a href="#P1182-数列分段-Section-II" class="headerlink" title="P1182 数列分段 Section II"></a><a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a></h3><h4 id="题意-27"><a href="#题意-27" class="headerlink" title="题意"></a>题意</h4><p>对于给定的一个长度为N的正整数数列 ，现要将其分成段，并要求每段连续，且每段和的最大值最小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + a[i] &lt;= x)sum += a[i];<span class="comment">//划分的每一段不能超过x</span></span><br><span class="line">        <span class="keyword">else</span> sum = a[i], cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;<span class="comment">//如果划分的每一段都不超过mid并且分的段数还小于m说明可以继续分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    ll l = <span class="number">-1</span>, r = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        l = <span class="built_in">max</span>(l, a[i]);<span class="comment">//注意二分的范围</span></span><br><span class="line">        r += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; mid &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))r = mid;<span class="comment">//要继续分所以减小mid</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;<span class="comment">//分得段太多,说明答案还可以继续增大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABC216-E-Amusement-Park"><a href="#ABC216-E-Amusement-Park" class="headerlink" title="ABC216 E Amusement Park"></a><a href="https://atcoder.jp/contests/abc216/tasks/abc216_e">ABC216 E Amusement Park</a></h3><h4 id="题意-28"><a href="#题意-28" class="headerlink" title="题意:"></a>题意:</h4><p>给N个点,K次访问,每个点有一个值,每个点可以访问无限次,每次访问就可以获得其值,但每访问一次这个点的值就会减1.最大化K次访问后值的总和.</p><h4 id="做法1-思维-模拟"><a href="#做法1-思维-模拟" class="headerlink" title="做法1:(思维+模拟)"></a>做法1:(思维+模拟)</h4><p>我们都可以想到要优先取最大的值,所以第一步是将数组从大到小排序,但我们不能一直取最大的那个值,因为它是随着取得次数减小的.所以我们能想到把最大的数取到和第二大的数一样,然后再取第二大的数,将其取到和第三个大的数一样.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg.</span><br><span class="line">10 9 5 4 3 -&gt; 9 9 5 4 3 -&gt; 5 5 5 4 3 -&gt; 4 4 4 4 3 -&gt; 3 3 3 3 3</span><br></pre></td></tr></table></figure><p>我们可以找到规律:第i大的数 可以被取i次</p><p>此时我们再结合等差数列的公式就可以算出答案.</p><p>细节部分会在代码中注释出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ull,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">PLL a[N];<span class="comment">//a[i].first存值, a[i].second存从大到小排序后当前数和后一个数的差值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync._with_stdio(false);</span></span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i].fi = <span class="built_in">read</span>();</span><br><span class="line">        ans += a[i].fi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) &#123;<span class="comment">//如果k比所有数字加起来都大,那直接计算所有数字1~a[i]的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += (a[i].fi + <span class="number">1</span>) * a[i].fi / <span class="number">2</span>;<span class="comment">//等差数列求和公式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="built_in">reverse</span>(a, a + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            a[i].se = (a[i].fi - a[i + <span class="number">1</span>].fi);</span><br><span class="line">        &#125;</span><br><span class="line">        a[n - <span class="number">1</span>].se = a[n - <span class="number">1</span>].fi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].se * (i + <span class="number">1</span>) &lt; k) &#123;<span class="comment">//第i大的数有i个</span></span><br><span class="line">                k -= a[i].se * (i + <span class="number">1</span>);<span class="comment">//全部用完</span></span><br><span class="line">                sum += (a[i].se * a[i].fi - (a[i].se * (a[i].se - <span class="number">1</span>)) / <span class="number">2</span>) * (i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; sum &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ll t = k / (i + <span class="number">1</span>);</span><br><span class="line">                ll left = k % (i + <span class="number">1</span>);<span class="comment">//这i个数同时等差数列求和到最后不一定都能用完</span></span><br><span class="line">               <span class="comment">// cout&lt;&lt;a[i].fi&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">                sum += (a[i].fi * t - t * (t - <span class="number">1</span>) / <span class="number">2</span>) * (i + <span class="number">1</span>);</span><br><span class="line">                sum += left * (a[i].fi - t);</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="做法2-二分"><a href="#做法2-二分" class="headerlink" title="做法2:(二分)"></a>做法2:(二分)</h4><p>先找出所有数的最大值,直接二分答案.check函数里判断<strong>当前比mid大的数</strong>和<strong>mid的差值</strong>的<strong>和</strong>是否大于k,如果大于说明mid值取小了,如果小于说明mid值取大了.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll n, m, k;</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; </span><br><span class="line">    i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; mid)ans += a[i] - mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll maxx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)cin &gt;&gt; a[i], maxx = <span class="built_in">max</span>(maxx, a[i]);</span><br><span class="line">    ll l = <span class="number">0</span>, r = maxx;</span><br><span class="line">    ll mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="built_in">reverse</span>(a, a + n);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; l) &#123;</span><br><span class="line">            ans += (a[i] + l) * (a[i] - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            cnt += a[i] - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= (cnt - k) * l;<span class="comment">//把多算的减掉</span></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 10</span></span><br><span class="line"><span class="comment">10 9 5 4 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="ABC192-D-Base-n"><a href="#ABC192-D-Base-n" class="headerlink" title="ABC192-D Base n"></a><a href="https://atcoder.jp/contests/abc192/tasks/abc192_d">ABC192-D Base n</a></h3><h4 id="题意-29"><a href="#题意-29" class="headerlink" title="题意"></a>题意</h4><p>给定一个字符串，由‘0’~‘9’组成，设是中最大的数字，求有多少个不同的整数，整数有以下要求：</p><ul><li>是一个n进制数</li><li>这个数的n进制表示是</li><li>n进制对应的十进制数</li></ul><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(__int128 mid)</span> </span>&#123;</span><br><span class="line">    __int128 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (__int128 i = s.<span class="built_in">length</span>() - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j *= mid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; m)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ans +=  (s[i] - <span class="string">&#x27;0&#x27;</span>) * j;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; m)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt;= m)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; s &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: s) &#123;</span><br><span class="line">        d = <span class="built_in">max</span>(d, (i - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span> &lt;= m) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll l = d + <span class="number">1</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            ll mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(l))cout &lt;&lt; l - d;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="https-atcoder-jp-contests-abc215-tasks-abc215-f-二分-双指针-贪心"><a href="#https-atcoder-jp-contests-abc215-tasks-abc215-f-二分-双指针-贪心" class="headerlink" title="https://atcoder.jp/contests/abc215/tasks/abc215_f (二分+双指针+贪心)"></a><a href="https://atcoder.jp/contests/abc215/tasks/abc215_f">https://atcoder.jp/contests/abc215/tasks/abc215_f</a> (二分+双指针+贪心)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">PLL a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span> </span>&#123;</span><br><span class="line">    ll miny = INF, maxy = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; i &amp;&amp; a[i].fi - a[j].fi &gt;= mid) &#123;<span class="comment">//a[i].fe因为排序了所以差值肯定是递增的</span></span><br><span class="line">            miny = <span class="built_in">min</span>(miny, a[j].se);</span><br><span class="line">            maxy = <span class="built_in">max</span>(maxy, a[j].se);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxy != <span class="number">-1</span> &amp;&amp; miny != INF &amp;&amp; (<span class="built_in">abs</span>(a[i].se - miny) &gt;= mid || <span class="built_in">abs</span>(a[i].se - maxy) &gt;= mid))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].fi &gt;&gt; a[i].se;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// cout &lt;&lt; mid &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="后缀自动机-后缀数组"><a href="#后缀自动机-后缀数组" class="headerlink" title="后缀自动机/后缀数组"></a>后缀自动机/后缀数组</h2><h3 id="String-Problem"><a href="#String-Problem" class="headerlink" title="String Problem"></a><a href="https://ac.nowcoder.com/acm/contest/24346/M">String Problem</a></h3><p>求给定字符串的所有前缀中最长的字典序最大的串</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050948.png" alt="image-20211124213208730"></p><h4 id="后缀自动机做法："><a href="#后缀自动机做法：" class="headerlink" title="后缀自动机做法："></a>后缀自动机做法：</h4><p>用一个pos记录后缀自动机中的节点对应原串中节点的位置，然后直接从’z’到’a’贪心的在后缀自动机上dfs，第一次搜到的肯定是字典序最大的，记录其映射在原串上的位置以及深度即可得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> len, fa;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125; node[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> pos[N];<span class="comment">//记录后缀自动机中的节点对应原串中节点的位置</span></span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于节点u的子串集合 最长的是node[u].len ,最短的是node[node[u].fa].len+1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//fa：fail数组 ch：trie树 len:这个节点集合中字符串最长长度</span></span><br><span class="line">    <span class="type">int</span> p = last, np = last = ++tot;<span class="comment">//np：初步建立的后缀自动机</span></span><br><span class="line">    pos[np] = id;</span><br><span class="line">    f[tot] = <span class="number">1</span>;<span class="comment">//记录每个子串出现的次数</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span> (!p) node[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> q = node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>) node[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++tot;<span class="comment">//nq：当某节点没有合适的点做Fail的父亲时，需要的添加公共节点</span></span><br><span class="line">            pos[nq] = pos[q];<span class="comment">//!!!!注意这里也要标记</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            node[q].fa = node[np].fa = nq;</span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> dept)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//直接硬搜</span></span><br><span class="line">        <span class="keyword">if</span> (node[u].ch[i] &amp;&amp; !vis[node[u].ch[i]]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(node[u].ch[i], dept + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans[pos[u]])ans[pos[u]] = pos[u] - dept + <span class="number">1</span>;<span class="comment">//搜到底了，因为是从&#x27;z&#x27;到&#x27;a&#x27;搜，第一次搜到的一定是字典序最大的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) <span class="built_in">extend</span>(str[i] - <span class="string">&#x27;a&#x27;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans[i+<span class="number">1</span>], i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后缀数组做法："><a href="#后缀数组做法：" class="headerlink" title="后缀数组做法："></a>后缀数组做法：</h4><p>从后往前枚举Sa数组（字典序排名从大到小），对于当前，在之后的答案（并且小于上一个排名处理的有边界）对应一定是该排名的后缀，如果前一个sa数组的位置在当前的后面，就不用管，一直找到在当前前面为止，如果就说明其实如果继续往前取还能取到更长的并且字典序排名不小于的后缀，所以继续往前找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> sa[N], x[N], y[N], c[N], rk[N], height[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[x[i] = s[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i--) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i++) y[++num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k)</span><br><span class="line">                y[++num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i--) sa[c[x[y[i]]]--] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k) k--;</span><br><span class="line">        <span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k++;</span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="built_in">get_sa</span>();</span><br><span class="line">    <span class="built_in">get_height</span>();</span><br><span class="line">    <span class="type">int</span> r=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st=sa[i];</span><br><span class="line">        <span class="type">int</span> pos=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sa[pos]&gt;=sa[i])height[i]=<span class="built_in">min</span>(height[i],height[pos]),pos--;</span><br><span class="line">        <span class="keyword">if</span>(st+height[i]&gt;r)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=st+height[i];j&lt;=r;j++)ans[j]=sa[i];</span><br><span class="line">        r=st+height[i]<span class="number">-1</span>;</span><br><span class="line">        i=pos+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exkmp"><a href="#exkmp" class="headerlink" title="exkmp"></a>exkmp</h2><h3 id="D-Period"><a href="#D-Period" class="headerlink" title="D - Period"></a><a href="https://codeforces.com/gym/103428/problem/D">D - Period</a></h3><h3 id="题意-30"><a href="#题意-30" class="headerlink" title="题意"></a>题意</h3><p>给一个1e6的字符串，1e6个询问：把第x个位置的字符换成‘#’，字符串有多少个不同的周期？</p><p>如字符串长度为4 就有循环节长度为1，2，3种周期。</p><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>要求这个串循环节为的周期，其实就是看有多少前缀与后缀相等。</p><p>对原串本身求exkmp，得到其每个后缀和原串能匹配的最长前缀的长度，如果这个长度等于该后缀的长度，那就说明这是一个循环。找到所有这样的循环把对应的前缀的位置上打上标记，说明到这里能有一个循环，然后做前缀和，就能快速查询到串中任意前缀能有多少个循环。把x位置替换成#，这时候的周期数就是（注意x=1时要特判，因为如果把第一个位置换成#之后不可能有周期与其匹配。）为什么是要是因为#对串的影响是让到这个#的周期全部失效，所以要找最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">char</span> p[N];</span><br><span class="line"><span class="type">int</span> nxt[N];<span class="comment">//p[i]...p[m - 1]与T的最长相同前缀长度</span></span><br><span class="line"><span class="type">int</span> extend[N];</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//s的长</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//p的长</span></span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= pos || i + nxt[i - a] &gt;= pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= pos)</span><br><span class="line">                pos = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; m &amp;&amp; p[pos] == p[pos - i])</span><br><span class="line">                pos++;</span><br><span class="line"></span><br><span class="line">            nxt[i] = pos - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxt[i] = nxt[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 extend[] */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetExtend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetNext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= pos || i + nxt[i - a] &gt;= pos) <span class="comment">// i &gt;= p 的作用：举个典型例子，s 和 p 无一字符相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= pos)</span><br><span class="line">                pos = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; n &amp;&amp; pos - i &lt; m &amp;&amp; s[pos] == p[pos - i])</span><br><span class="line">                pos++;</span><br><span class="line"></span><br><span class="line">            extend[i] = pos - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = nxt[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">strcpy</span>(p,s);</span><br><span class="line">    m=n;</span><br><span class="line">    <span class="built_in">GetExtend</span>();</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++)cout&lt;&lt;extend[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(extend[i]==n-i)tag[n-i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++)cout&lt;&lt;tag[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pre[i]=pre[i<span class="number">-1</span>]+tag[i];</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++)cout&lt;&lt;pre[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;min(x-1,n-x)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">        cout&lt;&lt;pre[<span class="built_in">min</span>(x<span class="number">-1</span>,n-x)]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和/差分"></a>前缀和/差分</h2><h2 id="离散化-差分"><a href="#离散化-差分" class="headerlink" title="离散化+差分"></a>离散化+差分</h2><h3 id="Acwing1987-粉刷栅栏"><a href="#Acwing1987-粉刷栅栏" class="headerlink" title="Acwing1987.粉刷栅栏"></a><a href="#">Acwing1987.粉刷栅栏</a></h3><h4 id="题意-31"><a href="#题意-31" class="headerlink" title="题意"></a>题意</h4><p>输入n个指令，每个指令代表从当前点向左或向右染色x个区间（从0点开始），问最后有多少区间被染色超过两次。</p><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201121656956.png" alt="image-20220112165157656"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2 R</span><br><span class="line">6 L</span><br><span class="line">1 R</span><br><span class="line">8 L</span><br><span class="line">1 R</span><br><span class="line">2 R</span><br></pre></td></tr></table></figure><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201180050431.png" alt="image-20220112165808846"></p><p>先要进行转换，因为差分是对点进行操作，我们就把0看作代表区间，1代表区间。</p><p>然后用map离散化，然后根据差分数组求原数组，注意这里因为数据范围太大不能把原数组每个位置的值求出来，只能得到区间端点的值，然后就用一个类似于双指针的方法求，具体看代码。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp, sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cha</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    mp[l] += v;</span><br><span class="line">    mp[r + <span class="number">1</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//0代表（0，1）区间，1代表（1，2）区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> direction;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cha</span>(last, last + x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;last&lt;&lt;&#x27; &#x27;&lt;&lt;last+x&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            last = last + x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cha</span>(last - x, last - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;last-x+1&lt;&lt;&#x27; &#x27;&lt;&lt;last&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">            last = last - x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;direction&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: mp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            sum[i.fi] += mp[i.fi];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i.fi] = sum[i.fi - <span class="number">1</span>] + mp[i.fi];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = mp.<span class="built_in">begin</span>()-&gt;fi, r = mp.<span class="built_in">begin</span>()-&gt;fi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: mp) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= <span class="number">1</span> &amp;&amp; ans + i.se &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            l = i.fi;<span class="comment">//找到满足条件的区间的左端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans &gt; <span class="number">1</span> &amp;&amp; ans + i.se &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            r = i.fi;<span class="comment">//找到满足条件的区间的右端点</span></span><br><span class="line">            cnt += r - l;<span class="comment">//值</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += i.se;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reinhart&#39;s algorithm template</title>
      <link href="/2021/01/15/Reinhart&#39;s%20algorithm%20template/"/>
      <url>/2021/01/15/Reinhart&#39;s%20algorithm%20template/</url>
      
        <content type="html"><![CDATA[<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="朴素-O-N-2"><a href="#朴素-O-N-2" class="headerlink" title="朴素 $O(N^2)$"></a>朴素 $O(N^2)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//邻接矩阵存稠密图</span></span><br><span class="line"><span class="type">int</span> dis[N];<span class="comment">//该点到起点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//每个点的最短路是否已经确定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//将t设置为-1 因为Dijkstra算法适用于不存在负权边的图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dis[t] &gt; dis[j]))t = j;<span class="comment">//该步骤即寻找还未确定最短路的点中路径最短的点</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//第t个点的最短路径已经确定</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j], dis[t] + g[t][j]); <span class="comment">//用t去更新t能达到的点到起点的最短距离</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆优化-O-NlogN"><a href="#堆优化-O-NlogN" class="headerlink" title="堆优化 $O(NlogN)$"></a>堆优化 $O(NlogN)$</h3><h4 id="链星版"><a href="#链星版" class="headerlink" title="链星版"></a>链星版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">150010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx=<span class="number">0</span>,w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    e[idx]=b;</span><br><span class="line">    ne[idx]=h[a];</span><br><span class="line">    h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver=t.second,distance=t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])<span class="keyword">continue</span>;</span><br><span class="line">        st[ver]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];~i;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;distance+w[i]) &#123;</span><br><span class="line">                dis[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vector数组版"><a href="#vector数组版" class="headerlink" title="vector数组版"></a>vector数组版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;PII &gt; g[N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;);</span><br><span class="line">    dis[T]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.se, distance = t.fi;</span><br><span class="line">        <span class="keyword">if</span> (st[ver])<span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[ver].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> j = g[ver][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j.fi] &gt; distance + j.se) &#123;</span><br><span class="line">                dis[j.fi] = distance + j.se;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j.fi], j.fi&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//确定分界点</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//因为是先移动再交换</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Egypt_Prime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j+=i)st[j]= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;prime[j]&lt;=n/i;j++)&#123;</span><br><span class="line">            st[prime[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//因为prime是从小到大枚举，所以如果i%prime[j]==0说明prime[j]是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数加"><a href="#大数加" class="headerlink" title="大数加"></a>大数加</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展gcd"><a href="#扩展gcd" class="headerlink" title="扩展gcd"></a>扩展gcd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll k,ll p)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=(res*a)%p;</span><br><span class="line">        k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        a=(a*a)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h2><p><strong>根据费马小定理$b^{p-1}\equiv1\mod{p}\to b*b^{p-2}\equiv 1 \mod{p}$可得$b$的逆元为$b^{p-2}$</strong></p><p>$(p是质数)$</p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span></span><br><span class="line">&#123;</span><br><span class="line">    ll m[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;<span class="comment">//存储结构体</span></span><br><span class="line">Mat a,e; <span class="comment">//a是输入的矩阵，e是输出的矩阵</span></span><br><span class="line"><span class="function">Mat <span class="title">Mul</span><span class="params">(Mat x,Mat y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            c.m[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">                c.m[i][j] = c.m[i][j]%mod + x.m[i][k]*y.m[k][j]%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">pow</span><span class="params">(Mat x,ll y)</span><span class="comment">//矩阵快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat ans = e;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans = <span class="built_in">Mul</span>(ans,x);</span><br><span class="line">        x = <span class="built_in">Mul</span>(x,x);</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ll a;</span><br><span class="line">ll res = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * (i - <span class="number">1</span>) / i;<span class="comment">//等价于(1-1/i)</span></span><br><span class="line">                <span class="keyword">while</span> (a % i == <span class="number">0</span>)a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>)res = res * (a - <span class="number">1</span>) / a;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> euler[N];<span class="comment">//存欧拉函数值</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">get_euler</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            euler[i]=i<span class="number">-1</span>;<span class="comment">//质数n的前n-1个数字都与他互质</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;=n/i ; ++j) &#123;</span><br><span class="line">            st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                euler[i*primes[j]]=euler[i]*primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[i*primes[j]]=euler[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) res+=euler[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展中国剩余定理-模数不互质"><a href="#扩展中国剩余定理-模数不互质" class="headerlink" title="扩展中国剩余定理(模数不互质)"></a>扩展中国剩余定理(模数不互质)</h2><h5 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h5><p><strong>1.检查题目的a是否是正整数，若不是则需要预处理a（模数m一定是正整数）</strong>    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=<span class="built_in">mod</span>(a[i],m[i]); <span class="comment">//输入可能为负数</span></span><br></pre></td></tr></table></figure><p><strong>2.检查$\prod_{i=0}^{n-1}{b[i]}$是否会爆long long</strong></p><ul><li>int  $[ -2147483648,2147483647]$</li><li>unsigned  int $[ 0,4294967295]$</li><li>long $[-2147483648,2147483647]$</li><li>unsigned long $ [0,4294967295]$</li><li>long long $[-9223372036854775808,9223372036854775807]$</li><li>unsigned long long $[0,18446744073709551615]$</li><li>__int64 $[-9223372036854775808,9223372036854775807]$</li><li>unsigned __int64 $[0,18446744073709551615]$</li><li>float（32位）精确到小数点后6~7位<ul><li>double（64位）精确到小数点后15~16位</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="keyword">inline</span> <span class="title">mod</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a % b) + b) % b;<span class="comment">//返回正余数的小技巧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll m[N];<span class="comment">//模数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exCNRemainder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ll k1, k2;</span><br><span class="line">        ll d = <span class="built_in">exgcd</span>(m[i], -m[i + <span class="number">1</span>], k1, k2);</span><br><span class="line">        <span class="keyword">if</span> ((a[i + <span class="number">1</span>] - a[i]) % d)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无解</span></span><br><span class="line">        k1 = <span class="built_in">mod</span>(k1 * (a[i + <span class="number">1</span>] - a[i]) / d, <span class="built_in">abs</span>(m[i + <span class="number">1</span>] / d));</span><br><span class="line">        a[i+<span class="number">1</span>] = k1 * m[i] + a[i];</span><br><span class="line">        m[i+<span class="number">1</span>] = <span class="built_in">abs</span>(m[i] / d * m[i + <span class="number">1</span>]);<span class="comment">//m1,m2的最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n ; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;m[i]&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exCNRemainder</span>())cout&lt;&lt;a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://www.acwing.com/solution/content/3539/</span></span><br></pre></td></tr></table></figure><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> nxt[M];</span><br><span class="line"><span class="type">char</span> s[N];<span class="comment">//主串</span></span><br><span class="line"><span class="type">char</span> p[M];<span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//求nxt数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )<span class="comment">//找以i结尾的P的相等的前缀与后缀最长长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//kmp匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = nxt[j];<span class="comment">//p还没退到起点并且不能匹配</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == m)<span class="comment">//匹配成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - m);<span class="comment">//输出每次匹配成功的起始位置的下标</span></span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p + <span class="number">1</span> &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>求一个字符串的最小循环节的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cir = n - nxt[n];</span><br></pre></td></tr></table></figure><p>如果<code>n</code>可以被<code>n - nxt[n]</code>整除，则表明字符串S可以完全由循环节循环组成，循环周期<code>T=n/cir</code>。</p><p>如果不能，说明还需要再添加几个字母才能补全。需要补的个数是循环个数<code>cir-n%cir=cir-(n-cir)%cir=cir-nxt[n]%cir</code></p><h2 id="EXKMP"><a href="#EXKMP" class="headerlink" title="EXKMP"></a>EXKMP</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201172258059.webp" alt="1664523306-5b8b351da943a_fix732"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://segmentfault.com/a/1190000008663857</span></span><br><span class="line"><span class="comment">定义s，p，设s的长度为n，p的长度为m，求p与s的每一个后缀的最长公共前缀，也就是说，设extend数组,extend[i]表示p与s[i,n-1]的最长公共前缀，要求出所有extend[i](0&lt;=i&lt;n)。</span></span><br><span class="line"><span class="comment">注意到，如果有一个位置extend[i]=m,则表示T在S中出现，而且是在位置i出现，这就是标准的KMP问题，所以说拓展kmp是对KMP算法的扩展，所以一般将它称为扩展KMP算法。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">注意！！！：此模版的nxt[i]是i-m-1的最长相同前缀，之前的kmp模版的nxt[i]是1-i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0开始</span></span><br><span class="line"><span class="comment">/* 求解 T 中 next[]，注释参考 GetExtend() */</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">char</span> p[N];</span><br><span class="line"><span class="type">int</span> nxt[N];<span class="comment">//p[i]...p[m - 1]与T的最长相同前缀长度</span></span><br><span class="line"><span class="type">int</span> extend[N];</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//s的长</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//p的长</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= pos || i + nxt[i - a] &gt;= pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= pos)</span><br><span class="line">                pos = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; m &amp;&amp; p[pos] == p[pos - i])</span><br><span class="line">                pos++;</span><br><span class="line"></span><br><span class="line">            nxt[i] = pos - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxt[i] = nxt[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 extend[] */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetExtend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetNext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= pos || i + nxt[i - a] &gt;= pos) <span class="comment">// i &gt;= p 的作用：举个典型例子，s 和 p 无一字符相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= pos)</span><br><span class="line">                pos = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pos &lt; n &amp;&amp; pos - i &lt; m &amp;&amp; s[pos] == p[pos - i])</span><br><span class="line">                pos++;</span><br><span class="line"></span><br><span class="line">            extend[i] = pos - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = nxt[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><ul><li>找一个循环字符串的字典序最小的表示方法</li></ul><p>对于两个循环的字符串如果能表示同一个字符串输出<code>Yes</code>否则输出<code>No</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_min</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n &amp;&amp; s[i + k] == s[j + k])k++;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i + k] &gt; s[j + k])i += k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j += k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == j)j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx = <span class="built_in">min</span>(i, j);<span class="comment">//i和j又一个越界了才会退出上面的循环 所以这里取没有越界的那个肯定是最小的;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; idx&lt;&lt; &#x27;\n&#x27;;//返回最小表示的起始点</span></span><br><span class="line">    <span class="keyword">return</span> idx ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    n = a.<span class="built_in">length</span>();</span><br><span class="line">    a += a, b += b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sta = <span class="built_in">get_min</span>(a), stb = <span class="built_in">get_min</span>(b);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;a.substr(sta,n/2)&lt;&lt;&#x27; &#x27;&lt;&lt;b.substr(stb,n/2)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">substr</span>(sta, n) == b.<span class="built_in">substr</span>(stb, n)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">substr</span>(sta,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> a[N];<span class="comment">//原串</span></span><br><span class="line"><span class="type">char</span> s[N * <span class="number">2</span>];<span class="comment">//处理过的串</span></span><br><span class="line"><span class="type">int</span> p[N * <span class="number">2</span>];<span class="comment">//p[i]是以i为中心的最长回文串半径</span></span><br><span class="line"><span class="comment">//因为p[i]是相较于处理过的串而言的，所以p[i]-1即为以i为中心的最长回文串的长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    s[idx++] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    s[idx++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s[idx++] = a[i], s[idx++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[idx++] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    n = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mr = <span class="number">0</span>;<span class="comment">//最长回文的最右边界</span></span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mr)p[i] = <span class="built_in">min</span>(p[i - (i - mid) * <span class="number">2</span>], mr - i);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s[i - p[i]] == s[i + p[i]]) &#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mr) &#123;</span><br><span class="line">            mr = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26];//下标是0的点既是根节点又是空节点</span><br><span class="line">int cnt[N];//以当前这个点结尾的单词有多少个</span><br><span class="line">int idx;//当前用到了哪个下标</span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;//字母映射成数字</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++ idx;//如果不存在就把它创建出来</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query()</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLL pair<span class="string">&lt;ll,PLL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">int</span> ne[N * S];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;<span class="comment">//trie树插入模版</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][t])tr[p][t] = ++idx;</span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//p位置上的字符串多了一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;<span class="comment">//构建ac自动机（bfs）</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//因为第一层也是全部连到根节点的，所以把第一层先全部入队</span></span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i])q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//宽搜</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//遍历t的所有儿子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = tr[t][i];</span><br><span class="line">            <span class="comment">// if(p)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     int j = ne[t];</span></span><br><span class="line">            <span class="comment">//     while(j &amp;&amp; !tr[j][i]) j = ne[j];</span></span><br><span class="line">            <span class="comment">//     if(tr[j][i]) j = tr[j][i];</span></span><br><span class="line">            <span class="comment">//     ne[p] = j;</span></span><br><span class="line">            <span class="comment">//     q[++tt] = p;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 优化思路 在没有匹配时 把while循环多次跳 优化为 直接跳到ne指针最终跳到的位置</span></span><br><span class="line">            <span class="comment">// 如果不存在儿子tr[t][i]的话就让当前节点的这个子节点指向当前节点指针的子节点</span></span><br><span class="line">            <span class="keyword">if</span> (!p) tr[t][i] = tr[ne[t]][i];</span><br><span class="line">                <span class="comment">// 如果存在儿子节点 让这个节点的指针指向(((他父亲节点)的失败指针所指向的那个节点)的下一个节点)</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ne[p] = tr[ne[t]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">insert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while(j &amp;&amp; !tr[j][t]) j = ne[j];</span></span><br><span class="line"><span class="comment">        if(tr[j][t]) j=tr[j][t];</span></span><br><span class="line"><span class="comment">        int p = j;</span></span><br><span class="line"><span class="comment">         // she 和 he 的 e结点都有cnt[e]=1</span></span><br><span class="line"><span class="comment">            遍历到she的后缀he的时候 her的相同前缀he肯定是逐层遍历到了的 len(he)&lt;len(she) 逐层遍历</span></span><br><span class="line"><span class="comment">            把所有ne 指针全部加一遍  比如当前p到了she的e  把cnt[p]+进res后</span></span><br><span class="line"><span class="comment">            把p通过ne[p]跳到he的e 再加上此时指向he中e的p的cnt[p]</span></span><br><span class="line"><span class="comment">        while(p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            res += cnt[p];</span></span><br><span class="line"><span class="comment">            cnt[p] = 0;</span></span><br><span class="line"><span class="comment">            p = ne[p];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        j = tr[j][t];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p = j;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            res += cnt[p];</span><br><span class="line">            cnt[p] = <span class="number">0</span>;<span class="comment">//she he 把cnt[e]的用过了之后 res=2 此时再进来一个her 就不能再+he的cnt了,所以cnt[e]用过之后要置0</span></span><br><span class="line">            p = ne[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> sa[N], x[N], y[N], c[N], rk[N], height[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后缀数组sa[i]就表示排名为i的后缀的起始位置的下标</span></span><br><span class="line"><span class="comment">而它的映射数组rak[i]就表示起始位置的下标为i的后缀的排名</span></span><br><span class="line"><span class="comment">Height[i]表示LCP(i,i-1)</span></span><br><span class="line"><span class="comment">LCP(i,j)表示suff(sa[i])与suff(sa[j])的最长公共前缀</span></span><br><span class="line"><span class="comment">LCP(i,j)=LCP(j,i);</span></span><br><span class="line"><span class="comment">LCP(i,i)=len(sa[i])=n-sa[i]+1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ababca</span></span><br><span class="line"><span class="comment">后缀按照字典序排序如下：</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">ababca</span></span><br><span class="line"><span class="comment">abca</span></span><br><span class="line"><span class="comment">babca</span></span><br><span class="line"><span class="comment">bca</span></span><br><span class="line"><span class="comment">ca</span></span><br><span class="line"><span class="comment">Height数组</span></span><br><span class="line"><span class="comment">0 1 2 0 1 0</span></span><br><span class="line"><span class="comment">Sa数组</span></span><br><span class="line"><span class="comment">6 1 3 2 4 5</span></span><br><span class="line"><span class="comment">Rak数组</span></span><br><span class="line"><span class="comment">2 4 3 5 6 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[i] = s[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) sa[c[x[i]] -- ] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i ++ ) y[ ++ num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; k)</span><br><span class="line">                y[ ++ num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) c[x[i]] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i ++ ) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) sa[c[x[y[i]]] -- ] = y[i], y[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">            x[sa[i]] = (y[sa[i]] == y[sa[i - <span class="number">1</span>]] &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k]) ? num : ++ num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">        m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (k) k -- ;</span><br><span class="line">        <span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k]) k ++ ;</span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="built_in">get_sa</span>();</span><br><span class="line">    <span class="built_in">get_height</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, height[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>求排名i和排名j的字符串的lcs</p><p>$lcs(i,j)=min(height[i],height[i+1],…,height[j])$</p></li></ul><h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><ul><li>Node的大小要开字符串长度的两倍</li><li>存fail树的大小要开字符串长度的三倍</li><li>多组初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idx=ans=<span class="number">0</span>;</span><br><span class="line">        tot=<span class="number">1</span>,last=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span> node);</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);<span class="comment">//！</span></span><br></pre></td></tr></table></figure><ul><li><p>求每个子串出现的次数</p></li><li><p>对于所有 S 的<strong>出现次数不为 1</strong> 的子串，设其 value值为该子串出现的次数*该子串的长度。请计算,value 的最大值是多少。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len, fa;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">LL f[N], ans;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">//对于节点u的子串集合 最长的是node[u].len ,最短的是node[node[u].fa].len+1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fa：fail数组 ch：trie树 len:这个节点集合中字符串最长长度</span></span><br><span class="line">    <span class="type">int</span> p = last, np = last = ++ tot;<span class="comment">//np：初步建立的后缀自动机</span></span><br><span class="line">    f[tot] = <span class="number">1</span>;<span class="comment">//记录每个子串出现的次数</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span> (!p) node[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>) node[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++ tot;<span class="comment">//nq：当某节点没有合适的点做Fail的父亲时，需要的添加公共节点</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            node[q].fa = node[np].fa = nq;</span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">        f[u] += f[e[i]];<span class="comment">//根据fail树的性质可以直接递归求出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[u] &gt; <span class="number">1</span>) ans = <span class="built_in">max</span>(ans, f[u] * node[u].len);<span class="comment">//出现次数大于1的记录一下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) <span class="built_in">extend</span>(str[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i++) <span class="built_in">add</span>(node[i].fa, i);<span class="comment">//构建fail树</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>给一个文本串s和多个模式串t ，我们要检查字符串t是否作为s的一个子串出现。也可以求模式串t在文本串中出现的最大前缀长度</p></li><li><p>给一个主串s和m个子串t,求每一个t在s中出现的最大前缀长度 s和t都是由ESWN这几个字符构成.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len, fa;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">4</span>];</span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;E&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;S&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;W&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;N&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line">string t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fa：fail数组 ch：trie树 len:这个节点集合中字符串最长长度</span></span><br><span class="line">    <span class="type">int</span> p = last, np = last = ++ tot;<span class="comment">//np：初步建立的后缀自动机</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span> (!p) node[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>) node[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++ tot;<span class="comment">//nq：当某节点没有合适的点做Fail的父亲时，需要的添加公共节点</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            node[q].fa = node[np].fa = nq;</span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">change</span>(t[i]);</span><br><span class="line">        <span class="keyword">if</span>(!node[p].ch[u])<span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p=node[p].ch[u];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">extend</span>(<span class="built_in">change</span>(s[i]));</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">query</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给一个数字串, 每加入一个字符,求当前所有子串个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;inline&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC target(&quot;avx&quot;,&quot;sse2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fgcse-lm&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fipa-sra&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-pre&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ftree-vrp&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fpeephole2&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-ffast-math&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;-fsched-spec&quot;)</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(&quot;unroll-loops&quot;)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLL pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll LLINF =<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len, fa;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;ch;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fa：fail数组 ch：trie树 len:这个节点集合中字符串最长长度</span></span><br><span class="line">    <span class="type">int</span> p = last, np = last = ++ tot;<span class="comment">//np：初步建立的后缀自动机</span></span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa) node[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span> (!p) node[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>) node[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nq = ++ tot;<span class="comment">//nq：当某节点没有合适的点做Fail的父亲时，需要的添加公共节点</span></span><br><span class="line">            node[nq] = node[q], node[nq].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            node[q].fa = node[np].fa = nq;</span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa) node[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug(last)</span></span><br><span class="line">    <span class="comment">//debug(tot)</span></span><br><span class="line">    ans+=node[last].len-node[node[last].fa].len;<span class="comment">//last是加的这个c的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">extend</span>(x);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="comment">//    freopen(&quot;../output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//T = read();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, cas);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="type">int</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRun time: %.2lf ms&quot;</span>, (<span class="type">double</span>) (end_time - begin_time) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    ll p = <span class="number">1</span>, data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)p = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        data = data * <span class="number">10</span> + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p * data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="救急大板子"><a href="#救急大板子" class="headerlink" title="救急大板子"></a>救急大板子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  pi    acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  eps   1e-9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  fi    first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  se    second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  rtl   rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  rtr   rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  bug                printf(<span class="string">&quot;******\n&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  mem(a, b)          memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  name2str(x)        #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  fuck(x)            cout&lt;&lt;#x<span class="string">&quot; = &quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfi(a)             scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffi(a, b)         scanf(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfffi(a, b, c)     scanf(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffffi(a, b, c, d) scanf(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfL(a)             scanf(<span class="string">&quot;%lld&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffL(a, b)         scanf(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfffL(a, b, c)     scanf(<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;a, &amp;b, &amp;c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffffL(a, b, c, d) scanf(<span class="string">&quot;%lld %lld %lld %lld&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfs(a)             scanf(<span class="string">&quot;%s&quot;</span>, a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffs(a, b)         scanf(<span class="string">&quot;%s %s&quot;</span>, a, b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sfffs(a, b, c)     scanf(<span class="string">&quot;%s %s %s&quot;</span>, a, b, c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  sffffs(a, b, c, d) scanf(<span class="string">&quot;%s %s %s %s&quot;</span>, a, b,c, d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  FIN                freopen(<span class="string">&quot;../in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  gcd(a, b)          __gcd(a,b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  lowbit(x)          x&amp;-x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IO                 iOS::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> ULL seed = <span class="number">13331</span>;</span><br><span class="line"><span class="type">const</span> LL INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">8e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">2012</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Suffix_Automaton</span> &#123;</span><br><span class="line">    <span class="type">int</span> last, tot, nxt[maxn &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], fail[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">//last是未加入此字符前最长的前缀（整个串）所属的节点的编号</span></span><br><span class="line">    <span class="type">int</span> len[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">// 最长子串的长度 (该节点子串数量 = len[x] - len[fa[x]])</span></span><br><span class="line">    <span class="type">int</span> sz[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">// 被后缀链接的个数，方便求节点字符串的个数</span></span><br><span class="line">    LL num[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">// 该状态子串的数量</span></span><br><span class="line">    LL maxx[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">// 长度为x的子串出现次数最多的子串的数目</span></span><br><span class="line">    LL sum[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">// 该节点后面所形成的自字符串的总数</span></span><br><span class="line">    LL subnum, sublen;<span class="comment">// subnum表示不同字符串数目,sublen表示不同字符串总长度</span></span><br><span class="line">    <span class="type">int</span> X[maxn &lt;&lt; <span class="number">1</span>], Y[maxn &lt;&lt; <span class="number">1</span>]; <span class="comment">// Y表示排名为x的节点，X表示该长度前面还有多少个</span></span><br><span class="line">    <span class="type">int</span> minn[maxn &lt;&lt; <span class="number">1</span>], mx[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">//minn[i]表示多个串在后缀自动机i节点最长公共子串，mx[i]表示单个串的最长公共子串</span></span><br><span class="line">    <span class="type">int</span> L[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = last = <span class="number">1</span>;</span><br><span class="line">        fail[<span class="number">1</span>] = len[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) nxt[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = ++tot, v = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++) nxt[u][i] = <span class="number">0</span>;</span><br><span class="line">        fail[u] = <span class="number">0</span>;</span><br><span class="line">        L[u] = len[u] = len[v] + <span class="number">1</span>;</span><br><span class="line">        num[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; v &amp;&amp; !nxt[v][c]; v = fail[v]) nxt[v][c] = u;</span><br><span class="line">        <span class="keyword">if</span> (!v) fail[u] = <span class="number">1</span>, sz[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len[nxt[v][c]] == len[v] + <span class="number">1</span>) fail[u] = nxt[v][c], sz[nxt[v][c]]++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> now = ++tot, cur = nxt[v][c];</span><br><span class="line">            len[now] = len[v] + <span class="number">1</span>;</span><br><span class="line">            L[now] = L[cur];</span><br><span class="line">            <span class="built_in">memcpy</span>(nxt[now], nxt[cur], <span class="built_in">sizeof</span>(nxt[cur]));</span><br><span class="line">            fail[now] = fail[cur];</span><br><span class="line">            fail[cur] = fail[u] = now;</span><br><span class="line">            <span class="keyword">for</span> (; v &amp;&amp; nxt[v][c] == cur; v = fail[v]) nxt[v][c] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        last = u;</span><br><span class="line">        <span class="comment">//return len[last] - len[fail[last]];//多添加一个子串所产生不同子串的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_num</span><span class="params">()</span> </span>&#123;<span class="comment">// 每个节点子串出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) X[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) X[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) X[i] += X[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) Y[X[len[i]]--] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i &gt;= <span class="number">1</span>; i--) num[fail[Y[i]]] += num[Y[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_maxx</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="comment">// 长度为x的子串出现次数最多的子串的数目</span></span><br><span class="line">        <span class="built_in">get_num</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) maxx[len[i]] = <span class="built_in">max</span>(maxx[len[i]], num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">()</span> </span>&#123;<span class="comment">// 该节点后面所形成的自字符串的总数</span></span><br><span class="line">        <span class="built_in">get_num</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            sum[Y[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">25</span>; j++)</span><br><span class="line">                sum[Y[i]] += sum[nxt[Y[i]][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_subnum</span><span class="params">()</span> </span>&#123;<span class="comment">//本质不同的子串的个数</span></span><br><span class="line">        subnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) subnum += len[i] - len[fail[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_sublen</span><span class="params">()</span> </span>&#123;<span class="comment">//本质不同的子串的总长度</span></span><br><span class="line">        sublen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) sublen += <span class="number">1LL</span> * (len[i] + len[fail[i]] + <span class="number">1</span>) * (len[i] - len[fail[i]]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_sa</span><span class="params">()</span> </span>&#123; <span class="comment">// Y表示排名为x的节点，X表示该长度前面还有多少个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tot; i++) X[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) X[len[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) X[i] += X[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) Y[X[len[i]]--] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;<span class="comment">//多个串的最长公共子串</span></span><br><span class="line">        <span class="built_in">mem</span>(mx, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s), p = <span class="number">1</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (nxt[p][c]) p = nxt[p][c], maxlen++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; p &amp;&amp; !nxt[p][c]; p = fail[p]);</span><br><span class="line">                <span class="keyword">if</span> (!p) p = <span class="number">1</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> maxlen = len[p] + <span class="number">1</span>, p = nxt[p][c];</span><br><span class="line">            &#125;</span><br><span class="line">            mx[p] = <span class="built_in">max</span>(mx[p], maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i; i--)</span><br><span class="line">            mx[fail[i]] = <span class="built_in">max</span>(mx[fail[i]], <span class="built_in">min</span>(len[fail[i]], mx[i]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i; i--)</span><br><span class="line">            <span class="keyword">if</span> (minn[i] == <span class="number">-1</span> || minn[i] &gt; maxx[i]) minn[i] = mx[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_kth</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;<span class="comment">//求出字典序第K的子串</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>, cnt;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nxt[pos][i] &amp;&amp; k) &#123;</span><br><span class="line">                    cnt = nxt[pos][i];</span><br><span class="line">                    <span class="keyword">if</span> (sum[cnt] &lt; k) k -= sum[cnt];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        k--;</span><br><span class="line">                        pos = cnt;</span><br><span class="line">                        s += (<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; sam;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, cas = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sfi</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">sfs</span>(s);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        sam.<span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, cas++);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">            <span class="type">int</span> p, maxlen;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">1</span>, maxlen = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">                <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sam.nxt[p][c]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = sam.nxt[p][c];</span><br><span class="line">                    sam.<span class="built_in">extend</span>((s[i] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    i++, maxlen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxlen) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxlen, sam.L[p] - maxlen);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 %d\n&quot;</span>, s[i]), sam.<span class="built_in">extend</span>((s[i] - <span class="string">&#x27;a&#x27;</span>)), i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;</span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);</span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="comment">//队列存a的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="comment">//求窗口最小值</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ;<span class="comment">// 当前队头不在窗口内部，将其删掉（当前窗口[i-k+1,i]）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;<span class="comment">//若当前队尾比该数还大说明是没用的，所以把它出队</span></span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//求窗口最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><h3 id="多次询问"><a href="#多次询问" class="headerlink" title="多次询问"></a>多次询问</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="询问稍少-a-b稍大"><a href="#询问稍少-a-b稍大" class="headerlink" title="询问稍少 a,b稍大"></a>询问稍少 a,b稍大</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;<span class="comment">//求逆元</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)fact[a] * infact[b] % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="询问很少-a-b很大-lucas定理"><a href="#询问很少-a-b很大-lucas定理" class="headerlink" title="询问很少 a,b很大(lucas定理)"></a>询问很少 a,b很大(lucas定理)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i ++, j -- )</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL)res * j % p;</span><br><span class="line">        res = (LL)res * <span class="built_in">qmi</span>(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lucas</span>(a, b, p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="答案很大但不能求模"><a href="#答案很大但不能求模" class="headerlink" title="答案很大但不能求模"></a>答案很大但不能求模</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性筛模版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求n的阶乘里质因子p的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度模版</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_primes</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )<span class="comment">//枚举每一个质数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = primes[i];</span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(a - b, p) - <span class="built_in">get</span>(b, p);<span class="comment">//当前质数的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用高精度乘法把质因子乘起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )<span class="comment">//枚举所有质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )<span class="comment">//枚举所有质数的次数</span></span><br><span class="line">            res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = n * <span class="number">2</span>, b = n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &gt; a - b; i -- ) res = (LL)res * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i ++ ) res = (LL)res * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">    res = (LL)res * <span class="built_in">qmi</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="放球问题"><a href="#放球问题" class="headerlink" title="放球问题"></a>放球问题</h3><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201172258072.png" alt="image-20211203091207912"></p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N][N];<span class="comment">//增广矩阵</span></span><br><span class="line"><span class="type">int</span> x[N];<span class="comment">//解集</span></span><br><span class="line"><span class="type">bool</span> freeX[N];<span class="comment">//标记是否为自由变元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b?a:<span class="built_in">GCD</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/<span class="built_in">GCD</span>(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss</span><span class="params">(<span class="type">int</span> equ,<span class="type">int</span> var)</span></span>&#123;<span class="comment">//返回自由变元个数</span></span><br><span class="line">    <span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=var;i++)&#123;</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">        freeX[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*转换为阶梯阵*/</span></span><br><span class="line">    <span class="type">int</span> col=<span class="number">0</span>;<span class="comment">//当前处理的列</span></span><br><span class="line">    <span class="type">int</span> row;<span class="comment">//当前处理的行</span></span><br><span class="line">    <span class="keyword">for</span>(row=<span class="number">0</span>;row&lt;equ&amp;&amp;col&lt;var;row++,col++)&#123;<span class="comment">//枚举当前处理的行</span></span><br><span class="line">        <span class="type">int</span> maxRow=row;<span class="comment">//当前列绝对值最大的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;equ;i++)&#123;<span class="comment">//寻找当前列绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][col])&gt;<span class="built_in">abs</span>(a[maxRow][col]))</span><br><span class="line">                maxRow=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxRow!=row)&#123;<span class="comment">//与第row行交换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=row;j&lt;var+<span class="number">1</span>;j++)</span><br><span class="line">                <span class="built_in">swap</span>(a[row][j],a[maxRow][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[row][col]==<span class="number">0</span>)&#123;<span class="comment">//col列第row行以下全是0，处理当前行的下一列</span></span><br><span class="line">            row--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row+<span class="number">1</span>;i&lt;equ;i++)&#123;<span class="comment">//枚举要删去的行</span></span><br><span class="line">            <span class="keyword">if</span>(a[i][col]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> lcm=<span class="built_in">LCM</span>(<span class="built_in">abs</span>(a[i][col]),<span class="built_in">abs</span>(a[row][col]));</span><br><span class="line">                <span class="type">int</span> ta=lcm/<span class="built_in">abs</span>(a[i][col]);</span><br><span class="line">                <span class="type">int</span> tb=lcm/<span class="built_in">abs</span>(a[row][col]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][col]*a[row][col]&lt;<span class="number">0</span>)<span class="comment">//异号情况相加</span></span><br><span class="line">                    tb=-tb;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=col;j&lt;var+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                    a[i][j]=a[i][j]*ta-a[row][j]*tb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*求解*/</span></span><br><span class="line">    <span class="comment">//无解：化简的增广阵中存在(0,0,...,a)这样的行，且a!=0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row;i&lt;equ;i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i][col]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//无穷解: 在var*(var+1)的增广阵中出现(0,0,...,0)这样的行</span></span><br><span class="line">    <span class="type">int</span> temp=var-row;<span class="comment">//自由变元有var-row个</span></span><br><span class="line">    <span class="keyword">if</span>(row&lt;var)<span class="comment">//返回自由变元数</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//唯一解: 在var*(var+1)的增广阵中形成严格的上三角阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=var<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//计算解集</span></span><br><span class="line">        <span class="type">int</span> temp=a[i][var];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;var;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]!=<span class="number">0</span>)</span><br><span class="line">                temp-=a[i][j]*x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp%a[i][i]!=<span class="number">0</span>)<span class="comment">//有浮点数解，无整数解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        x[i]=temp/a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> equ,var;<span class="comment">//equ个方程，var个变元</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;equ,&amp;var)!=EOF) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;equ;i++)<span class="comment">//输入增广矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;var+<span class="number">1</span>;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> freeNum=<span class="built_in">Gauss</span>(equ,var);<span class="comment">//自由元个数</span></span><br><span class="line">        <span class="keyword">if</span>(freeNum==<span class="number">-1</span>)<span class="comment">//无解</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无解\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(freeNum==<span class="number">-2</span>)<span class="comment">//有浮点数解无整数解</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无整数解\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(freeNum&gt;<span class="number">0</span>)&#123;<span class="comment">//有无穷多解</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;有无穷多解，自由变元个数为%d\n&quot;</span>,freeNum);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;var;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(freeX[i])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;x%d是自由变元\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;x%d=%d\n&quot;</span>,i+<span class="number">1</span>,x[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//有唯一解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;var;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;x%d=%d\n&quot;</span>,i+<span class="number">1</span>,x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">  <span class="comment">//消成上三角矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )<span class="comment">//枚举每一列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))<span class="comment">//找到绝对值最大的那一行</span></span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n + <span class="number">1</span>; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);<span class="comment">//把绝对值最大的一行换到最上面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];<span class="comment">//把该行第一个数变成1-&gt;倒着更新,不然第一个数先被更新成1除后面的数就无效了</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];<span class="comment">//把下边所有行的第c列消成0</span></span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)<span class="comment">//出现了0=非0的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> n-r;<span class="comment">//多组解,返回自由元个数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//消成对角线矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )<span class="comment">//倒着把其他系数全部消成0（解所在位置的系数是1）</span></span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高斯消元解异或方程组"><a href="#高斯消元解异或方程组" class="headerlink" title="高斯消元解异或方程组"></a>高斯消元解异或方程组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!a[t][c]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n + <span class="number">1</span>; i++) <span class="built_in">swap</span>(a[r][i], a[t][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)<span class="comment">//将下面所有行的第c列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">                    a[i][j] ^= a[r][j];<span class="comment">//该行第c列肯定是1，所以下面行异或该行第c列肯定可以消成0（两个1异或）</span></span><br><span class="line"></span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> n-r;<span class="comment">//多组解,返回自由元个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] ^= a[i][j] &amp; a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; a[i][n] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt;<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用高斯消元把行列式化成上三角行列式再求解-O-N-3"><a href="#用高斯消元把行列式化成上三角行列式再求解-O-N-3" class="headerlink" title="用高斯消元把行列式化成上三角行列式再求解$O(N^3)$"></a>用高斯消元把行列式化成上三角行列式再求解$O(N^3)$</h3><h4 id="取模-没有负数解"><a href="#取模-没有负数解" class="headerlink" title="取模(没有负数解)"></a>取模(没有负数解)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll A[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_pow</span>(a, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gauss</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j][i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n; k++) <span class="built_in">swap</span>(A[i][k], A[j][k]);</span><br><span class="line">                <span class="keyword">if</span>(i != j) ans = -ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!A[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll j = i + <span class="number">1</span>, iv = <span class="built_in">inv</span>(A[i][i]); j &lt;= n; j++) &#123;</span><br><span class="line">                ll t = A[j][i] * iv % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">                    A[j][k] = (A[j][k] - t * A[i][k] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans * A[i][i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="double-有负数解"><a href="#double-有负数解" class="headerlink" title="double(有负数解)"></a>double(有负数解)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> p=i;</span><br><span class="line">        <span class="keyword">while</span>(!f[p][i] <span class="keyword">and</span> p&lt;=n)p++;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=n+<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p!=i)<span class="built_in">swap</span>(f[i],f[p]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> tmp=f[j][i]/f[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">            f[j][k]-=f[i][k]*tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    ans*=f[i][i];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(ans+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分模版"><a href="#二分模版" class="headerlink" title="二分模版"></a>二分模版</h2><h3 id="答案在左区间中"><a href="#答案在左区间中" class="headerlink" title="答案在左区间中"></a>答案在左区间中</h3><ul><li>当我们将区间$[l, r]$划分成$[l, mid]$和$[mid + 1, r]$时，其更新操作是$r = mid$或者$l = mid + 1$;，计算mid时不需要加1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">       <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="答案在右区间中"><a href="#答案在右区间中" class="headerlink" title="答案在右区间中"></a>答案在右区间中</h3><ul><li>当我们将区间$[l, r]$划分成$[l, mid - 1]$和$[mid, r]$时，其更新操作是$r = mid - 1$或者$l = mid$;，此时为了防止死循环，计算mid时需要加1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">       <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201172258069.png" alt="image-20210507215948279"></p><p>红色区间</p><h2 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h2><p><a href="https://blog.csdn.net/deletewo/article/details/104102359">https://blog.csdn.net/deletewo/article/details/104102359</a></p><p><strong>适用场景</strong></p><p>三分算法适用于求解凸性函数的极值问题，二次函数就是一个典型的单峰函数。</p><p>二分利用的是函数的单调性，三分算法利用的是函数的单峰性。</p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/20211108215723.png" alt="20200128205206158" style="zoom:50%;" /><p>在区间$[l,r]$，令$m1 = l + (r-l)/3, m2 = r - (r-l)/3$，分别位于1/3、2/3处，接着计算这两个点的函数值，</p><p>如果$f(m1)&gt;f(m2)$,求解区间有$[l,r]$变为$[l,m2]$。（就是将最接近极值点那个m点保留，然后 重新划分区间）</p><p><strong>此外三分算法也强调严格的单调性，出现函数值相等的区间就不适用了。</strong></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> l = <span class="number">0</span>,r = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=<span class="number">1e-9</span>)&#123;<span class="comment">//精度问题</span></span><br><span class="line">    <span class="type">double</span> m1 = l + (r-l)/<span class="number">3.0</span>,m2 = r - (r-l)/<span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))<span class="comment">//凸函数，凹函数把符号反过来就行</span></span><br><span class="line">        l = m1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = m2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(r-l&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="type">int</span> m1=l+(r-l)/<span class="number">3</span>,m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))&#123;</span><br><span class="line">        l = m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = m2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;<span class="comment">//暴力枚举精度区间</span></span><br><span class="line">    ans=<span class="built_in">min</span>(ans,<span class="built_in">f</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><p>a+b=(a&amp;b)+(a|b)</p><h2 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller- Rabin"></a>Miller- Rabin</h2><p>一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果 被测数小于4 759 123 141，那么只需要测试三个底数2,  7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11,  13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7,  61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255  981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取 k个底数进行测试算法的失误率大概为4^(-k)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题汇总</title>
      <link href="/2020/11/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/11/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><h4 id="题目：https-www-acwing-com-problem-content-2"><a href="#题目：https-www-acwing-com-problem-content-2" class="headerlink" title="题目：https://www.acwing.com/problem/content/2/"></a>题目：<a href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></h4><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>$$<br>dp[i][j]意思是只放前i个物品在总体积是j的情况下的物品的贡献<br>$$</p><ul><li>易得状态方程为：</li></ul><p>$$<br>dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]+w[i]])<br>$$</p><p>$$<br>dp[i][j]=dp[i-1][j]意思是不选第i个物品（dp[i][j]直接原封不动保留上一个i的状态）<br>$$</p><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,v[<span class="number">1005</span>],w[<span class="number">1005</span>],dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j =<span class="number">0</span>; j &lt;=m ; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不放</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) <span class="comment">//要当前背包的总体积大于v[i]才能把i物品放进背包</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;=n ; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt;=m ; ++j) &#123;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;dp[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=m ; ++i) &#123;</span><br><span class="line">        res=<span class="built_in">max</span>(res,dp[n][i]); <span class="comment">//dp[n]意思是将n个物品都权衡利弊后选择n个物品中的部分放入背包（不超过背包最大容量）,</span></span><br><span class="line">    &#125; <span class="comment">//但不知道这些物品的总体积是多少，所以遍历所有可能的体积输出价值最大值即为答案。</span></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试数据：</li></ul><p><strong>4 5</strong><br><strong>1 2</strong><br><strong>2 4</strong><br><strong>3 4</strong><br><strong>4 5</strong></p><ul><li>dp数组内容：</li></ul><p><strong>0 2 2 2 2 2</strong><br><strong>0 2 4 6 6 6</strong><br><strong>0 2 4 6 6 8</strong><br><strong>0 2 4 6 6 8</strong></p><ul><li>最后输出：8</li></ul><h4 id="优化后的代码："><a href="#优化后的代码：" class="headerlink" title="优化后的代码："></a>优化后的代码：</h4><p>==只用了一维==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,v[<span class="number">1005</span>],w[<span class="number">1005</span>],dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j =m; j &gt;=v[i] ; --j) &#123; <span class="comment">//j从大到小循环是为了让dp[j-v[i]]的值是上一层i的值</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<span class="comment">//(dp[j-v[i]]后于dp[j]更新)</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>dp数组内容：</li></ul><p><strong>2 2 2 2 2</strong><br><strong>6 6 6 4</strong><br><strong>8 6 6</strong><br><strong>8 6</strong><br><strong>8</strong></p><p>==注:若要求达到最大价值时的最大体积(恰好)需将初始化dp[N]={0}改为dp[0]=0，剩余dp为-INF;    ans从直接输出dp[m]变为max(dp[0…m]).==</p><p>​    </p><h4 id="状态方程的详细求解过程："><a href="#状态方程的详细求解过程：" class="headerlink" title="状态方程的详细求解过程："></a>状态方程的详细求解过程：</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181346007.jpg" alt="acwing算法笔记本-2"></p><h4 id="二维优化成一维的推导："><a href="#二维优化成一维的推导：" class="headerlink" title="二维优化成一维的推导："></a>二维优化成一维的推导：</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181346017.jpeg" alt="IMG_988F8EF4F15E-1"></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h4 id="题目：https-www-acwing-com-problem-content-3"><a href="#题目：https-www-acwing-com-problem-content-3" class="headerlink" title="题目：https://www.acwing.com/problem/content/3/"></a>题目：<a href="https://www.acwing.com/problem/content/3/">https://www.acwing.com/problem/content/3/</a></h4><p>$dp[i][j]$同样也是表示从前i个物品中选，总体积不超过j的方案集合，唯一的区别就是完全背包问题中每个物品都可以取无限个</p><p>所以可得到：<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i],dp[i-1][j-2<em>v[i]]+2</em>w[i],…)​<br>$$<br>按道理来说需要三层循环，但是可以被优化成二层循环：<br>$$<br>dp[i][j]=max(dp[i-1][j],dp[i][j-v[i]]+w[i]）​<br>$$</p><h4 id="具体证明："><a href="#具体证明：" class="headerlink" title="具体证明："></a>具体证明：</h4><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181346600.jpg"></p><h4 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m,v[<span class="number">1005</span>],w[<span class="number">1005</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维优化成一维："><a href="#二维优化成一维：" class="headerlink" title="二维优化成一维："></a>二维优化成一维：</h4><p>$$<br>dp[i][j]=max(dp[i-1][j],dp[i][j-v[i]]+w[i]）​\to dp[j]=max(dp[j],dp[j-v[i]]+w[i])<br>$$</p><p>与0-1背包不同的是，0-1背包的$dp[j-v[i]]$对应的是i上一层也就是i-1层的值，而这里的$dp[i][j-v[i]]$要求对应本层i的值，也就是让$dp[j-v[i]]$先更新再更新$dp[j]$，所以把j从大到小循环改为从小到大循环即可。</p><h4 id="优化后的代码：-1"><a href="#优化后的代码：-1" class="headerlink" title="优化后的代码："></a>优化后的代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n,m,dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m,v[<span class="number">1005</span>],w[<span class="number">1005</span>];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h4 id="题目-数据范围小-：https-www-acwing-com-problem-content-4"><a href="#题目-数据范围小-：https-www-acwing-com-problem-content-4" class="headerlink" title="题目(数据范围小)：https://www.acwing.com/problem/content/4/"></a>题目(数据范围小)：<a href="https://www.acwing.com/problem/content/4/">https://www.acwing.com/problem/content/4/</a></h4><h4 id="朴素做法-三维-："><a href="#朴素做法-三维-：" class="headerlink" title="朴素做法(三维)："></a>朴素做法(三维)：</h4><p>多一维遍历第i个物品选$0～s[i]$个的所有情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">105</span>],w[<span class="number">105</span>],s[<span class="number">105</span>],dp[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//memset(dp,0,105);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=v[i] ; --j) &#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;=s[i] ; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=k*v[i])dp[j]=<span class="built_in">max</span>(dp[j],dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt;=m ; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目-数据范围大-：https-www-acwing-com-problem-content-5"><a href="#题目-数据范围大-：https-www-acwing-com-problem-content-5" class="headerlink" title="题目(数据范围大)：https://www.acwing.com/problem/content/5/"></a>题目(数据范围大)：<a href="https://www.acwing.com/problem/content/5/">https://www.acwing.com/problem/content/5/</a></h4><p>思考到多重背包问题可以将每个物品拆开然后重新存入数组里，但如果直接拆开根据数据范围$s<em>N</em>V=2000<em>1000</em>2000=2*10^9$</p><p>还是会超过时间限制，所以考虑到将物品通过二进制的方法拆解：假如某物品有7件用1，2，4就可以表示全部可能。所以得出s件物品只需要$\lceil log(s) \rceil$的时间，所以就是$11<em>1000</em>2000\approx2*10^7$，可以在规定时间内通过。但在具体实现中还会有问题，假如某物品有10件，不能直接用1，2，4，8表示，因为1，2，4，8可以表示1～15，而11～15不是我们所需要的。所以采取一个策略：用s减去1，2，4…当s&lt;0的时候停止，并将最后剩余的那个数存进数组。假如10，$10-1-2-4=3$，所以就将1，2，4，3存入数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">struc</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> v[<span class="number">2005</span>], w[<span class="number">2005</span>], s[<span class="number">2005</span>], dp[<span class="number">2005</span>];</span><br><span class="line">vector&lt;struc&gt; vec;  <span class="comment">//用结构体矢量存拆开的物品的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//memset(dp,0,105);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k *= <span class="number">2</span>) &#123;</span><br><span class="line">            s[i] -= k;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(&#123;k * v[i], k * w[i]&#125;);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;k&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;s[i]&quot;&lt;&lt;s[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="number">0</span>)vec.<span class="built_in">push_back</span>(&#123;s[i] * v[i], s[i] * w[i]&#125;);  <span class="comment">//将剩下的那个数存进矢量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= vec[i].v; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - vec[i].v] + vec[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h4 id="题目：https-www-acwing-com-problem-content-9"><a href="#题目：https-www-acwing-com-problem-content-9" class="headerlink" title="题目：https://www.acwing.com/problem/content/9/"></a>题目：<a href="https://www.acwing.com/problem/content/9/">https://www.acwing.com/problem/content/9/</a></h4><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：<img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202201181346823.jpeg" alt="701A36AD-E016-4371-A8B8-E8A9C82BC085_1_105_c"></h4><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,dp[<span class="number">105</span>],s[<span class="number">105</span>],v[<span class="number">105</span>][<span class="number">105</span>],w[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=s[i] ; ++j) &#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=<span class="number">0</span> ; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;=s[i] ; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][k]&lt;=j)dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i][k]]+w[i][k]); <span class="comment">//遍历第i组物品中的所有可能</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
