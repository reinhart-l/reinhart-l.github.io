<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="C++编译的过程–&gt;.c文件 1.预处理(Preprocessing),  展开所有的宏定义，消除“#define”； 处理所有的预编译指令，比如#if、#ifdef等； 处理#include预编译指令，将包含文件插入到该预编译的位置； 删除所有的注释“&#x2F;**&#x2F;”、”&#x2F;&#x2F;“等； 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒； 保留所有的#program编译指令，原">
<meta property="og:type" content="article">
<meta property="og:title" content="c++知识点">
<meta property="og:url" content="http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Across the Cosmos">
<meta property="og:description" content="C++编译的过程–&gt;.c文件 1.预处理(Preprocessing),  展开所有的宏定义，消除“#define”； 处理所有的预编译指令，比如#if、#ifdef等； 处理#include预编译指令，将包含文件插入到该预编译的位置； 删除所有的注释“&#x2F;**&#x2F;”、”&#x2F;&#x2F;“等； 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒； 保留所有的#program编译指令，原">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203311100564.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203301643105.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203310922129.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204010031292.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205081241794.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533402.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533645.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533376.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061809858.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061815592.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071534208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071538504.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644470.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644743.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071626248.png">
<meta property="article:published_time" content="2023-11-08T06:47:28.000Z">
<meta property="article:modified_time" content="2023-11-08T07:29:34.226Z">
<meta property="article:author" content="Reinhart">
<meta property="article:tag" content="个人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203311100564.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>c++知识点</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Across the Cosmos" type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/11/08/%E6%B8%B8%E6%88%8F%E7%A0%94%E5%8F%91%E5%9C%BA%E6%99%AF%E9%A2%98/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&text=c++知识点"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&is_video=false&description=c++知识点"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=c++知识点&body=Check out this article: http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&name=c++知识点&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&t=c++知识点"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C++编译的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">2.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">const 的指针与引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89-define-%E5%92%8C-const-%E5%B8%B8%E9%87%8F"><span class="toc-number">2.0.4.</span> <span class="toc-text">宏定义 #define 和 const 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%EF%BC%8Cdefine%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%8Ctypedef%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">2.0.5.</span> <span class="toc-text">typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">构造函数的执行顺序？析构函数的执行顺序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB-%E5%9F%BA%E7%B1%BB-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">3.0.1.</span> <span class="toc-text">虚基类 基类 派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.0.2.</span> <span class="toc-text">在一个类中创建另一个类的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B-%E5%B9%B6%E4%B8%94%E6%9C%89%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.0.3.</span> <span class="toc-text">在一个类中创建另一个类的实例 并且有基类的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">构造函数的扩展过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">5.</span> <span class="toc-text">什么情况下会调用拷贝构造函数(三种情况)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">C++移动构造函数（移动语义的具体实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">7.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">7.0.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">inline 内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">9.0.1.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">9.0.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9-inline-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.0.3.</span> <span class="toc-text">编译器对 inline 函数的处理步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.0.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">10.1.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">10.1.2.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">10.1.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E3%80%81%E8%A6%86%E7%9B%96%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">C++中函数重载、隐藏、覆盖和重写的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88Function-Overload%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">1.函数重载（Function Overload）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E7%94%A8%E6%B3%95"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.2用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%EF%BC%88Function-Hiding%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">2.函数隐藏（Function Hiding）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%94%A8%E6%B3%95%E7%94%A8%E4%BE%8B"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2用法用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.2.3.</span> <span class="toc-text">2.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%EF%BC%88Function-Override%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">3.函数覆盖与函数重写（Function Override）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E4%B8%8E%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2虚函数重写与协变返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">11.4.</span> <span class="toc-text">4.总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">11.5.</span> <span class="toc-text">动态联编与静态联编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">12.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">12.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">12.2.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E7%BC%96%E8%AF%91%E6%9C%9F-%E6%97%A9%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="toc-number">12.2.1.</span> <span class="toc-text">静态多态（编译期&#x2F;早绑定）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88%EF%BC%88%E6%B3%9B%E5%9E%8B%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">12.2.1.1.</span> <span class="toc-text">void * 指针（泛型指针）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E8%BF%90%E8%A1%8C%E6%9C%9F-%E6%99%9A%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="toc-number">12.2.2.</span> <span class="toc-text">动态多态（运行期&#x2F;晚绑定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88virtual%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-number">12.2.3.</span> <span class="toc-text">虚函数（virtual）可以是内联函数（inline）吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">虚函数内联使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.3.2.</span> <span class="toc-text">动态多态使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.4.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">12.2.5.</span> <span class="toc-text">析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.6.</span> <span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.7.</span> <span class="toc-text">虚函数、纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">12.2.8.</span> <span class="toc-text">虚函数指针、虚函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">12.2.9.</span> <span class="toc-text">虚继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.10.</span> <span class="toc-text">虚继承、虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.11.</span> <span class="toc-text">模板类、成员模板、虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E3%80%81%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">12.2.12.</span> <span class="toc-text">抽象类、接口类、聚合类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">12.3.</span> <span class="toc-text">计算下面几个类的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">关于虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%9A%E6%80%81%E8%A1%8C%E4%B8%BA%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BADerive-3-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.2.</span> <span class="toc-text">为什么构造函数不能是虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9F-1"><span class="toc-number">12.5.</span> <span class="toc-text">构造函数的扩展过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">13.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assert"><span class="toc-number">14.</span> <span class="toc-text">assert()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-number">15.</span> <span class="toc-text">extern “C”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">15.0.1.</span> <span class="toc-text">C++中的链接属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">extern的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">16.1.</span> <span class="toc-text">非常量全局变量的外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">16.2.</span> <span class="toc-text">常量全局变量的外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D-%E5%92%8Cextern-%E2%80%9CC-%E2%80%9D%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">16.3.</span> <span class="toc-text">extern “C” 和extern “C++”函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">17.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E5%92%8C-typedef-struct"><span class="toc-number">18.</span> <span class="toc-text">struct 和 typedef struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD"><span class="toc-number">18.0.1.</span> <span class="toc-text">C 中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD-1"><span class="toc-number">18.0.2.</span> <span class="toc-text">C++ 中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-struct-%E5%92%8C-class"><span class="toc-number">18.1.</span> <span class="toc-text">C++ 中 struct 和 class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">18.1.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-%E8%81%94%E5%90%88"><span class="toc-number">18.2.</span> <span class="toc-text">union 联合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit%EF%BC%88%E6%98%BE%E5%BC%8F%EF%BC%89%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">19.</span> <span class="toc-text">explicit（显式）关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">20.</span> <span class="toc-text">C++ 的四种强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E2%BD%A4%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">21.</span> <span class="toc-text">C++ 中的指针参数传递和引⽤参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">22.</span> <span class="toc-text">简单说⼀下函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">:: 范围解析运算符（不能被重载）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">23.0.1.</span> <span class="toc-text">分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">24.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">24.0.1.</span> <span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-amp"><span class="toc-number">24.0.2.</span> <span class="toc-text">左值引用&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-amp-amp"><span class="toc-number">24.0.3.</span> <span class="toc-text">右值引用&amp;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">24.0.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">24.0.5.</span> <span class="toc-text">引用折叠</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-number">25.</span> <span class="toc-text">内存分配和管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E3%80%81calloc%E3%80%81realloc%E3%80%81alloca"><span class="toc-number">25.0.1.</span> <span class="toc-text">malloc、calloc、realloc、alloca</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E3%80%81free"><span class="toc-number">25.0.2.</span> <span class="toc-text">malloc、free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E3%80%81delete"><span class="toc-number">25.0.3.</span> <span class="toc-text">new、delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D-new"><span class="toc-number">25.0.4.</span> <span class="toc-text">定位 new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E4%B8%8Emalloc%E5%88%9B%E5%BB%BA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.0.5.</span> <span class="toc-text">new与malloc创建位置的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-this-%E5%90%88%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">delete this 合法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">27.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD"><span class="toc-number">27.0.1.</span> <span class="toc-text">C++ 标准库（STL）中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11"><span class="toc-number">27.0.2.</span> <span class="toc-text">C++ 11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81auto-ptr%EF%BC%88C-98-%E7%9A%84%E2%BD%85%E6%A1%88%EF%BC%8CC11-%E5%B7%B2%E6%8A%9B%E5%BC%83%EF%BC%89%E9%87%87%E2%BD%A4%E6%89%80%E6%9C%89%E6%9D%83%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">27.0.3.</span> <span class="toc-text">1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81unique-ptr%EF%BC%88%E6%9B%BF%E6%8D%A2-auto-ptr-%EF%BC%89"><span class="toc-number">27.0.4.</span> <span class="toc-text">2、unique_ptr（替换 auto_ptr ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81shared-ptr%EF%BC%88%E5%85%B1%E4%BA%AB%E5%9E%8B%EF%BC%8C%E5%BC%BA%E5%BC%95%E2%BD%A4%EF%BC%89"><span class="toc-number">27.0.5.</span> <span class="toc-text">3、shared_ptr（共享型，强引⽤）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81weak-ptr%EF%BC%88%E5%BC%B1%E5%BC%95%E2%BD%A4%EF%BC%89"><span class="toc-number">27.0.6.</span> <span class="toc-text">4、weak_ptr（弱引⽤）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#share-ptr%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">27.0.7.</span> <span class="toc-text">share_ptr的线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%86%99share-ptr"><span class="toc-number">27.0.8.</span> <span class="toc-text">手写share_ptr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">28.</span> <span class="toc-text">内存泄漏的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">28.1.</span> <span class="toc-text">内存泄漏检测工具的实现原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E4%B8%AD%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">c++中函数被调用的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-number">30.</span> <span class="toc-text">C++ 中内存分配情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">30.0.0.1.</span> <span class="toc-text">全局&#x2F;静态存储区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-number">30.0.0.2.</span> <span class="toc-text">代码区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.0.0.3.</span> <span class="toc-text">栈和堆的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">31.</span> <span class="toc-text">成员初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">32.</span> <span class="toc-text">c++11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">C++ 模板是什么，底层怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%86%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%A8-main-%E5%87%BD%E6%95%B0%E6%89%A7%E2%BE%8F%E5%89%8D%E5%85%88%E8%BF%90%E2%BE%8F"><span class="toc-number">34.</span> <span class="toc-text">请你来写个函数在 main 函数执⾏前先运⾏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E2%BC%80%E4%B8%8B-fork-%E5%87%BD%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">请你来说⼀下 fork 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8B-printf-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">简单说⼀下 printf 实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%BC%BF%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-strcat%EF%BC%8Cstrcpy%EF%BC%8Cstrncpy%EF%BC%8Cmemset%EF%BC%8Cmemcpy%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.</span> <span class="toc-text">⼿写字符串函数 strcat，strcpy，strncpy，memset，memcpy实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memcmp%E5%87%BD%E6%95%B0"><span class="toc-number">37.1.</span> <span class="toc-text">memcmp函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E6%88%96C-%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%9F%9F%EF%BC%88bit-field%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">C或C++中的位域（bit field）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">38.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">38.2.</span> <span class="toc-text">位域的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">39.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">40.</span> <span class="toc-text">运算符优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%BB%93%E5%90%88%E5%92%8C%E5%8F%B3%E7%BB%93%E5%90%88"><span class="toc-number">40.1.</span> <span class="toc-text">左结合和右结合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD-%E4%B8%80%E4%B8%AA-%E5%8F%B7-%E5%92%8C-%E4%B8%A4%E4%B8%AA-%E5%8F%B7-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">41.</span> <span class="toc-text">C++中#(一个#号)和##(两个#号)的用法和作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%98%85%E8%AF%BB%E7%A8%8B%E5%BA%8F%E9%A2%98"><span class="toc-number">42.</span> <span class="toc-text">各种阅读程序题</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        c++知识点
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Reinhart</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-11-08T06:47:28.000Z" itemprop="datePublished">2023-11-08</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="C-编译的过程"><a href="#C-编译的过程" class="headerlink" title="C++编译的过程"></a>C++编译的过程</h2><p>–&gt;.c文件</p>
<p>1.预处理(Preprocessing),</p>
<ul>
<li>展开所有的宏定义，消除“#define”；</li>
<li>处理所有的预编译指令，比如#if、#ifdef等；</li>
<li>处理#include预编译指令，将包含文件插入到该预编译的位置；</li>
<li>删除所有的注释“/**/”、”//“等；</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒；</li>
<li>保留所有的#program编译指令，原因是编译器要使用它们；</li>
</ul>
<p>–&gt; .i文件</p>
<p>2.编译(Compilation),</p>
<ul>
<li>编译过程就是把经过预编译生成的文件进行一系列语法分析、词法分析、语义分析优化后生成相应的汇编代码文件。</li>
</ul>
<p>–&gt; .s文件</p>
<p>3.汇编(Assemble)</p>
<ul>
<li>生成可重定位的二进制文件</li>
</ul>
<p>–&gt;.o文件</p>
<p>4.链接(Linking)。</p>
<ul>
<li>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。</li>
</ul>
<p>例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。</p>
<p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p>
<ul>
<li>链接阶段是把源程序转换成的目标代码（obj文件）与你程序里面调用的库函数对应的代码连接起来形成对应的可执行文件（exe文件）</li>
</ul>
<p>链接分为两种：</p>
<ul>
<li><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li>
<li><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li>
</ul>
<p>二者的优缺点：</p>
<ul>
<li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li>
<li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<h4 id="const-的指针与引用"><a href="#const-的指针与引用" class="headerlink" title="const 的指针与引用"></a>const 的指针与引用</h4><ul>
<li>指针<ul>
<li>指向常量的指针（pointer to const）</li>
<li>自身是常量的指针（常量指针，const pointer）</li>
</ul>
</li>
<li>引用<ul>
<li>指向常量的引用（reference to const）</li>
<li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li>
</ul>
</li>
</ul>
<blockquote>
<p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 <code>p2</code>、<code>p3</code></p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>const 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;                <span class="comment">// 常对象成员，可以使用初始化列表或者类内初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数</span></span><br><span class="line">    <span class="type">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="type">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="type">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>&#123;<span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line">  Var++;<span class="comment">//错误</span></span><br><span class="line">&#125;           </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>*p;</span><br><span class="line">    p= &amp;a;</span><br><span class="line">    (*p)++;<span class="comment">//错误,定义一个常量指针后，指针指向的值就不能被改变，即不能通过指针变量直接更改指针指向的值</span></span><br><span class="line">    p=&amp;b;<span class="comment">//正确，指向可以改变</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p2=&amp;a;</span><br><span class="line">    p2=b;<span class="comment">//错误,定义一个指针常量后，指针的指向就不能被改变</span></span><br><span class="line">    (*p2)++;<span class="comment">//正确,指向的值仍可修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203311100564.jpg" alt="1561648695629_.pic"></p>
<h4 id="宏定义-define-和-const-常量"><a href="#宏定义-define-和-const-常量" class="headerlink" title="宏定义 #define 和 const 常量"></a>宏定义 #define 和 const 常量</h4><table>
<thead>
<tr>
<th>宏定义 #define</th>
<th>const 常量</th>
</tr>
</thead>
<tbody><tr>
<td>宏定义，相当于字符替换</td>
<td>常量声明</td>
</tr>
<tr>
<td>预处理器处理</td>
<td>编译器处理</td>
</tr>
<tr>
<td>无类型安全检查</td>
<td>有类型安全检查</td>
</tr>
<tr>
<td>不分配内存</td>
<td>要分配内存</td>
</tr>
<tr>
<td>存储在代码段</td>
<td>存储在数据段</td>
</tr>
<tr>
<td>可通过 <code>#undef</code> 取消</td>
<td>不可取消</td>
</tr>
</tbody></table>
<ul>
<li><p>宏可能产生<strong>边界效应</strong></p>
<p>#define MIN(a, b) a &gt; b ? b : a</p>
<p>这句宏定义就会带来意想不到的问题，比如我在这样使用时：</p>
<p>num = b + MIN(num1, num2);</p>
<p>num的值一直是num1、num2两个中的最小值，也就是说讲b的值直接作为0处理了</p>
<p>正确应该为：</p>
<p>#define MIN(a, b) (a &gt; b ? b : a)</p>
</li>
</ul>
<h4 id="typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名"><a href="#typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名" class="headerlink" title="typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名"></a>typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名</h4><h2 id="构造函数的执行顺序？析构函数的执行顺序？"><a href="#构造函数的执行顺序？析构函数的执行顺序？" class="headerlink" title="构造函数的执行顺序？析构函数的执行顺序？"></a>构造函数的执行顺序？析构函数的执行顺序？</h2><h4 id="虚基类-基类-派生类"><a href="#虚基类-基类-派生类" class="headerlink" title="虚基类 基类 派生类"></a>虚基类 基类 派生类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shit</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Shit! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Shit</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Shit! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Person! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Person! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Student! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Student! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Student,<span class="keyword">public</span> Shit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>()&#123;cout&lt;&lt;<span class="string">&quot;constructor - Teacher! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Teacher</span>()&#123;cout&lt;&lt;<span class="string">&quot;deconstructor - Teacher! &quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Shit!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将<code>class Teacher : public Student,public Shit</code>变为<code>class Teacher : public Shit,public Student</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Shit!</span><br><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将<code>class Teacher : public Shit,public Student</code>变为<code>class Teacher :public Student, public Virtual Shit</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">constructor - Shit!</span><br><span class="line">constructor - Person!</span><br><span class="line">constructor - Student!</span><br><span class="line">constructor - Teacher!</span><br><span class="line">deconstructor - Teacher!</span><br><span class="line">deconstructor - Student!</span><br><span class="line">deconstructor - Person!</span><br><span class="line">deconstructor - Shit!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果不变，说明优先构造虚基类</p>
<h4 id="在一个类中创建另一个类的实例"><a href="#在一个类中创建另一个类的实例" class="headerlink" title="在一个类中创建另一个类的实例"></a>在一个类中创建另一个类的实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor A</span><br><span class="line">constructor B</span><br><span class="line">destructor B</span><br><span class="line">destructor A</span><br></pre></td></tr></table></figure>



<h4 id="在一个类中创建另一个类的实例-并且有基类的情况"><a href="#在一个类中创建另一个类的实例-并且有基类的情况" class="headerlink" title="在一个类中创建另一个类的实例 并且有基类的情况"></a>在一个类中创建另一个类的实例 并且有基类的情况</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FB</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FB</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor FB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FB</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor FB\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor A\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :FB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;constructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destructor B\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor FB</span><br><span class="line">constructor A</span><br><span class="line">constructor B</span><br><span class="line">destructor B</span><br><span class="line">destructor A</span><br><span class="line">destructor FB</span><br></pre></td></tr></table></figure>



<h2 id="构造函数的扩展过程？"><a href="#构造函数的扩展过程？" class="headerlink" title="构造函数的扩展过程？"></a>构造函数的扩展过程？</h2><p>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</p>
<p><strong>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</strong></p>
<p>如果 class 有虚表，那么它必须被设定初值；</p>
<p>所有上一层的基类构造函数必须被调用；</p>
<p>所有虚基类的构造函数必须被调用。</p>
<h2 id="什么情况下会调用拷贝构造函数-三种情况"><a href="#什么情况下会调用拷贝构造函数-三种情况" class="headerlink" title="什么情况下会调用拷贝构造函数(三种情况)"></a>什么情况下会调用拷贝构造函数(三种情况)</h2><p>类的对象需要拷贝时，拷贝构造函数将会被调用，以下的情况都会调用拷贝构造函数： </p>
<ul>
<li>一个对象以<strong>值传递</strong>的方式<strong>传入函数体</strong>，需要拷贝构造函数创建一个临时对象压入到栈空间中。 </li>
<li>一个对象以<strong>值传递</strong>的方式<strong>从函数返回</strong>，需要执行拷贝构造函数创建一个临时对象作为返回值。 </li>
<li>一个对象需要通过另外一个对象进行初始化。</li>
</ul>
<h2 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h2><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 ==main 函数运行前就分配了空间==，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，==仅在定义该函数的文件内才能使用==。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使==所有的对象只保存一个该变量==，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得==不需要生成对象就可以访问该函数==，但是在 ==static 函数内不能访问非静态成员==。</li>
</ol>
<ul>
<li>const和static不能同时修饰一个成员函数，因为C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</li>
<li>static</li>
</ul>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ol>
<li><code>this</code> 指针是一个隐含于每一个==非静态成员函数==中的特殊指针。它==指向调用该成员函数的那个对象==。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象进行修改（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code>指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>==在<strong>类声明中</strong>定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数==。</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如下风格的函数 Foo 不能成为内联函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;   <span class="comment">// inline 仅与函数声明放在一起  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>而如下风格的函数 Foo 则成为内联函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>   <span class="comment">// inline 与函数定义体放在一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h4><ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>代码膨胀</strong>。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li><strong>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</strong></li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li><code>public</code> 成员：可以被任意实体访问</li>
<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/169.html">友元函数</a></h4><ul>
<li>在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。</li>
</ul>
<p><strong>1、为什么要引入友元函数：</strong>在实现类之间数据共享时，减少系统开销，提高效率</p>
<p>c++利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置成public，最大限度的保护数据成员的安全。</p>
<p>具体来说：为了使其他类的成员函数直接访问该类的私有变量</p>
<p>即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数（<strong>友元函数不是类的成员函数，是普通函数</strong>）</p>
<ul>
<li><p>优点：能够提高效率，表达简单、清晰</p>
</li>
<li><p>缺点：友元函数破环了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。</p>
</li>
</ul>
<p><strong>2、什么时候使用友元函数：</strong></p>
<p>   1)运算符重载的某些场合需要使用友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设重载了*</span><br><span class="line">A a1,a2,a3;</span><br><span class="line">a1=a2*a3;<span class="comment">//等价于a1=operator*(a2,a3) 相当于operator在外部访问了a2和a3的私有变量</span></span><br></pre></td></tr></table></figure>

<p>  对于结构体来说，如果要把重载运算符写在结构体内也需要使用friend，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果把friend删掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//friend bool operator &lt;(const node&amp; a,const node&amp; b)&#123;</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>会报如下错误:<code>Overloaded &#39;operator&lt;&#39; must be a binary operator (has 3 parameters)</code> ，意思是这个重载运算符的函数有三个参数，而重载运算符只能一目或二目。</p>
<p>不加friend时，这个函数相当于成员函数，当一个结构体的成员函数被调用时，和类一样，也会自动向这个成员函数传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针(this)，所以会说传入了三个参数。但加了friend后，该函数就变成了一个普通函数，但是拥有访问结构体/类的私有参数的权利。但结构体中的参数默认是公有的，所以也可以直接将重载定义在结构体外面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但如果参数是私有的，就不行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.price&gt;b.price;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//&#x27;price&#x27; is a private member of &#x27;node&#x27;</span></span><br></pre></td></tr></table></figure>



<p>2)两个类要共享数据的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span>  <span class="title class_">boy</span>;   <span class="comment">//声明类boy是类girl的友元</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">girl</span>(<span class="type">char</span> *n,<span class="type">int</span> age):<span class="built_in">name</span>(n),<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boy</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;  </span><br><span class="line">    <span class="type">int</span> age;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">boy</span>(<span class="type">char</span> *n,<span class="type">int</span> age):<span class="built_in">name</span>(n),<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(girl &amp;)</span></span>;   </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span>       <span class="comment">//  该函数必须在girl类定义的后面定义，否则girl类中的私有变量还是未知的    </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;boy&#x27;s name is:&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;girl&#x27;s name is:&quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,age:&quot;</span>&lt;&lt;x.age&lt;&lt;endl; </span><br><span class="line">    <span class="comment">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span></span><br><span class="line">    <span class="comment">//正常情况下，只允许在girl的成员函数中访问girl的私有变量</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">boy <span class="title">b</span><span class="params">(<span class="string">&quot;aaa&quot;</span>,<span class="number">8</span>)</span></span>;  </span><br><span class="line">    <span class="function">girl <span class="title">g</span><span class="params">(<span class="string">&quot;bbb&quot;</span>,<span class="number">99</span>)</span></span>;  </span><br><span class="line">    b.<span class="built_in">disp</span>(g); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><ul>
<li>一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 </p>
<h2 id="C-中函数重载、隐藏、覆盖和重写的区别"><a href="#C-中函数重载、隐藏、覆盖和重写的区别" class="headerlink" title="C++中函数重载、隐藏、覆盖和重写的区别"></a>C++中函数重载、隐藏、覆盖和重写的区别</h2><h3 id="1-函数重载（Function-Overload）"><a href="#1-函数重载（Function-Overload）" class="headerlink" title="1.函数重载（Function Overload）"></a>1.函数重载（Function Overload）</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><p>C++规定在==同一作用域中==，同名函数的形式参数（指参数的个数、类型或者顺序）不同时，构成函数重载。</p>
<h4 id="1-2用法"><a href="#1-2用法" class="headerlink" title="1.2用法"></a>1.2用法</h4><p>比如，要从两个变量中返回其中较大的一个值，可以编写如下两个构成重载的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">max</span>(<span class="params">int a,int b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?<span class="attr">a</span>:b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double <span class="title function_">max</span>(<span class="params">double a,double b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?<span class="attr">a</span>:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<h4 id="1-3注意事项"><a href="#1-3注意事项" class="headerlink" title="1.3注意事项"></a>1.3注意事项</h4><p>（1）函数返回值类型与构成函数重载无任何关系；  </p>
<p>（2）<strong>类的静态成员函数与普通成员函数可以形成重载；</strong></p>
<p>（3）函数重载发生在同一作用域，如类成员函数之间的重载、全局函数之间的重载。</p>
<h3 id="2-函数隐藏（Function-Hiding）"><a href="#2-函数隐藏（Function-Hiding）" class="headerlink" title="2.函数隐藏（Function Hiding）"></a>2.函数隐藏（Function Hiding）</h3><h4 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h4><p>函数隐藏指不同作用域中定义的同名函数构成函数隐藏（==不要求函数返回值和函数参数类型相同==）。比如派生类成员函数屏蔽与其同名的基类成员函数、类成员函数屏蔽全局外部函数。请注意，==如果在派生类中存在与基类虚函数同返回值、同名且同形参的函数，则构成函数重写==。</p>
<h4 id="2-2用法用例"><a href="#2-2用法用例" class="headerlink" title="2.2用法用例"></a>2.2用法用例</h4><p>请仔细研读以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span>(<span class="params">char* s</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;global function with name:&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member function of A&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">useFunc</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//func(&quot;lvlv&quot;);//A::func()将外部函数func(char*)隐藏</span></span><br><span class="line">        <span class="title function_">func</span>();</span><br><span class="line">        ::<span class="title function_">func</span>(<span class="string">&quot;lvlv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="keyword">void</span> <span class="title function_">print</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A&#x27;s print&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:public A&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">useFunc</span>(<span class="params"></span>)&#123;          <span class="comment">//隐藏A::void useFunc()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&#x27;s useFunc&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int <span class="title function_">useFunc</span>(<span class="params">int i</span>)&#123;      <span class="comment">//隐藏A::void useFunc()</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In B&#x27;s useFunc(),i=&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual int <span class="title function_">print</span>(<span class="params">char* a</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&#x27;s print:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面编译不通过,因为对父类虚函数重写时，需要函数返回值类型，函数名称和参数类型全部相同才行</span></span><br><span class="line">    <span class="comment">// virtual int print()&#123;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;B&#x27;s print:&quot;&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="title function_">useFunc</span>();</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="title function_">useFunc</span>();<span class="comment">//A::useFunc()被B::useFunc()隐藏</span></span><br><span class="line">    b.<span class="property">A</span>::<span class="title function_">useFunc</span>();</span><br><span class="line">    b.<span class="title function_">useFunc</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//b.print();//编译出错，A::print()被B::print(char* a)隐藏</span></span><br><span class="line">    b.<span class="property">A</span>::<span class="title function_">print</span>();</span><br><span class="line">    b.<span class="title function_">print</span>(<span class="string">&quot;jf&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">程序执行结果： </span><br><span class="line">member function of A</span><br><span class="line">global function with name:lvlv</span><br><span class="line"></span><br><span class="line">B<span class="number">&#x27;</span>s useFunc</span><br><span class="line">  </span><br><span class="line">member function of A</span><br><span class="line">global function with name:lvlv</span><br><span class="line">  </span><br><span class="line">In B<span class="number">&#x27;</span><span class="function">s <span class="title">useFunc</span><span class="params">()</span>,i</span>=<span class="number">2</span></span><br><span class="line">  </span><br><span class="line">A<span class="number">&#x27;</span>s print</span><br><span class="line">  </span><br><span class="line">B<span class="number">&#x27;</span>s print:jf</span><br></pre></td></tr></table></figure>



<h4 id="2-3注意事项"><a href="#2-3注意事项" class="headerlink" title="2.3注意事项"></a>2.3注意事项</h4><p>对比函数隐藏与函数重载的定义可知：  </p>
<p>（1）派生类成员函数与基类成员函数同名但参数不同。此时基类成员函数将被隐藏（注意别与重载混淆，重载发生在同一个类中）；  </p>
<p>（2）函数重载发生在同一作用域，函数隐藏发生在不同作用域。</p>
<h3 id="3-函数覆盖与函数重写（Function-Override）"><a href="#3-函数覆盖与函数重写（Function-Override）" class="headerlink" title="3.函数覆盖与函数重写（Function Override）"></a>3.函数覆盖与函数重写（Function Override）</h3><p>网上和很多书籍多都会涉及函数覆盖的概念，众说纷纭，加大了许多初学者的学习难度，甚至产生误导。事实上，函数覆盖就是函数重写。</p>
<h4 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h4><p>派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写。</p>
<p>关于返回值类型存在一种特殊情况，即协变返回类型（covariant return type）。</p>
<h4 id="3-2虚函数重写与协变返回类型"><a href="#3-2虚函数重写与协变返回类型" class="headerlink" title="3.2虚函数重写与协变返回类型"></a>3.2虚函数重写与协变返回类型</h4><p>如果虚函数函数返回指针或者引用时（不包括value语义），子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型（这就是所谓的协变返回类型）[4]^{[4]}。看示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:public A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    virtual A&amp; <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:public <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">     <span class="comment">//返回值协变，构成虚函数重写</span></span><br><span class="line">     B&amp; <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">new</span> B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3注意事项"><a href="#3-3注意事项" class="headerlink" title="3.3注意事项"></a>3.3注意事项</h4><p><strong>（1）函数覆盖就是虚函数重写，而不是函数被”覆盖”。</strong>  从上面的代码可以看出，函数是不可能被“覆盖”的。有些人可能会错误地认为函数覆盖会导致函数被”覆盖”而”消失”，将不能被访问，事实上只要通过作用域运算符::就可以访问到被覆盖的函数。因此，不存在被”覆盖“的函数。</p>
<p><strong>（2）函数覆盖是函数隐藏的特殊情况。</strong>  对比函数覆盖和函数隐藏的定义，不难发现函数覆盖其实是函数隐藏的特例。</p>
<p>如果派生类中定义了一个与基类虚函数同名但参数列表不同的非virtual函数，则此函数是一个普通成员函数（非虚函数），并形成对基类中同名虚函数的隐藏，而非虚函数覆盖（重写）。</p>
<p>《C++高级进阶教程》中认为函数的隐藏与覆盖是两个不同的概念。隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象，而覆盖则是为了实现动态联编，是一个动态概念。但隐藏和覆盖也有联系：形成覆盖的两个函数之间一定形成隐藏。例如，可以对虚函数采用“实调用”，即尽管被调用的是虚函数，但是被调用函数的地址还是在编译阶段静态确定的，那么派生类中的虚函数仍然形成对基类中虚函数的同名隐藏。</p>
<p>参考如下代码，考察虚函数的实调用和虚调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    virtual <span class="keyword">void</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:public <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;In Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Base</span> b;</span><br><span class="line">    b.<span class="title function_">show</span>();</span><br><span class="line">    <span class="title class_">Derived</span> d;</span><br><span class="line">    d.<span class="title function_">show</span>();          <span class="comment">//对函数show()的实调用</span></span><br><span class="line">    d.<span class="property">Base</span>::<span class="title function_">show</span>();    <span class="comment">//对函数show()的实调用</span></span><br><span class="line">    <span class="title class_">Base</span> *pb=<span class="variable constant_">NULL</span>;     </span><br><span class="line">    pb=&amp;d;             </span><br><span class="line">    pb-&gt;<span class="title function_">show</span>();        <span class="comment">//对函数show()的虚调用</span></span><br><span class="line">    pb-&gt;<span class="title class_">Base</span>::<span class="title function_">show</span>();  <span class="comment">//对函数show()的实调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>程序运行结果：  In Base  In Derived  In Base  In Derived  In Base</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>在讨论相关概念的区别时，抓住定义才能区别开来。C++中函数重载隐藏和覆盖的区别，并不难，难就难在没弄清定义，被网上各种说法弄的云里雾里而又没有自己的理解。</p>
<p>在这里，牢记以下几点，就可区分函数重载、函数隐藏、函数覆盖和函数重写的区别： </p>
<p>（1）函数重载发生在相同作用域；  </p>
<p>（2）函数隐藏发生在不同作用域；  </p>
<p>（3）函数覆盖就是函数重写。准确地叫作虚函数覆盖和虚函数重写，也是函数隐藏的特例。</p>
<p>关于三者的对比，李健老师在《编写高质量代码：改善C++程序的150个建议》给出了较为详细的总结，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">三者</th>
<th align="left">作用域</th>
<th align="left">有无virtual</th>
<th align="left">函数名</th>
<th align="left">形参列表</th>
<th align="left">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重载</td>
<td align="left">相同</td>
<td align="left">可有可无</td>
<td align="left">相同</td>
<td align="left">不同</td>
<td align="left">可同可不同</td>
</tr>
<tr>
<td align="left">隐藏</td>
<td align="left">不同</td>
<td align="left">可有可无</td>
<td align="left">相同</td>
<td align="left">可同可不同</td>
<td align="left">可同可不同</td>
</tr>
<tr>
<td align="left">重写</td>
<td align="left">不同</td>
<td align="left">有</td>
<td align="left">相同</td>
<td align="left">相同</td>
<td align="left">相同（协变）</td>
</tr>
</tbody></table>
<h3 id="动态联编与静态联编"><a href="#动态联编与静态联编" class="headerlink" title="动态联编与静态联编"></a>动态联编与静态联编</h3><p>在 C++ 中，联编是指一个计算机程序的不同部分彼此关联的过程。按照联编所进行的阶段不同，可以分为静态联编和动态联编；</p>
<p>静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。</p>
<p>动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p>
<p>C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p>
<p>实现动态联编三个条件：</p>
<p>必须把动态联编的行为定义为类的虚函数；</p>
<p>类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来；</p>
<p>必须先使用基类指针指向子类型的对象，然后直接或间接使用基类指针调用虚函数；</p>
<h2 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为<strong>消息以多种形式显示的能力</strong>。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<h4 id="静态多态（编译期-早绑定）"><a href="#静态多态（编译期-早绑定）" class="headerlink" title="静态多态（编译期/早绑定）"></a>静态多态（编译期/早绑定）</h4><p>函数重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void do(int a);</span><br><span class="line">    void do(int a, int b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="void-指针（泛型指针）"><a href="#void-指针（泛型指针）" class="headerlink" title="void * 指针（泛型指针）"></a>void * 指针（泛型指针）</h5><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/163676489?utm_source=wechat_session&amp;utm_id=0">https://zhuanlan.zhihu.com/p/163676489?utm_source=wechat_session&amp;utm_id=0</a></p>
<p>void即为不确定类型——类型不确定从而所占内存不确定，所以诸如<code>void par = 10;</code>之类的声明是万万不可的，即<strong>void类型不能声明实例对象</strong>。在C语言中，void的作用主要有以下两大类：</p>
<ol>
<li>对函数返回类型的限定，利用void对象的大小不确定来限制函数不能有任何返回值——这就是我们常写的void作返回值的函数。</li>
<li>对函数参数类型的限定，当函数不允许接受参数是，必须用void来限定函数的参数——当然现在没什么会这么写了:<code>int func(void);</code>。</li>
</ol>
<p>但<code>void*</code>则不同，编译器会允许你做类似于<code>int someInt = 10; void* par = &amp;someInt;</code>之类的操作，因为无论指向什么类型的指针，指针本身所占空间是一定的。我们可以认为<code>void*</code>就是一个通用指针，可以指向任意类型的指针。我们都知道，指针有两个属性：指向变量/对象的地址和长度，<strong>但是指针指存储被指向变量的地址，长度则取决于指针的类型</strong>，编译器根据指针的类型从指针指向的地址向后寻址，不同的类型则寻址范围不同，如<code>int*</code>从指定地址向后寻找4字节作为变量的存储单元。而我们将一个<code>void</code>类型的指针指向一个int类型的实例，<strong>实际上是抹去了这一实例的类型信息</strong>，因此在使用时我们要在心里清楚被抹去的类型信息。</p>
<h4 id="动态多态（运行期-晚绑定）"><a href="#动态多态（运行期-晚绑定）" class="headerlink" title="动态多态（运行期/晚绑定）"></a>动态多态（运行期/晚绑定）</h4><ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
<li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数。</li>
</ul>
<h4 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are “inline virtual” member functions ever actually “inlined”?</a></p>
</blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<h5 id="虚函数内联使用"><a href="#虚函数内联使用" class="headerlink" title="虚函数内联使用"></a>虚函数内联使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">	Base b;</span><br><span class="line">	b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">	Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">	ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="动态多态使用"><a href="#动态多态使用" class="headerlink" title="动态多态使用"></a>动态多态使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>                     <span class="comment">// 形状类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> : <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> <span class="built_in">Rect</span>(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;<span class="built_in">calcArea</span>();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Shape();                    // 构造函数不能是虚函数</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    virtual ~Shape();           // 虚析构函数</span><br><span class="line">&#125;;</span><br><span class="line">class Circle : public Shape     // 圆形类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double calcArea();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Shape * shape1 = new Circle(4.0);</span><br><span class="line">    shape1-&gt;calcArea();    </span><br><span class="line">    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span><br><span class="line">    shape1 = NULL;</span><br><span class="line">    return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="析构函数一般写成虚函数的原因"><a href="#析构函数一般写成虚函数的原因" class="headerlink" title="析构函数一般写成虚函数的原因"></a>析构函数一般写成虚函数的原因</h4><p>直观的讲：是为了降低内存泄漏的可能性。举例来说就是，一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调用基类的析构函数  （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执行基类的析构，派生类的自身内容将无法被析构，造成内存泄漏。</p>
<p>如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执行派生类的析构函数，再执行基类的析构函数，成功释放内存。</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual int A() = 0;</span><br></pre></td></tr></table></figure>



<h4 id="虚函数、纯虚函数"><a href="#虚函数、纯虚函数" class="headerlink" title="虚函数、纯虚函数"></a>虚函数、纯虚函数</h4><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2280.html">虚继承</a>。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h4 id="虚函数指针、虚函数表"><a href="#虚函数指针、虚函数表" class="headerlink" title="虚函数指针、虚函数表"></a>虚函数指针、虚函数表</h4><ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份。在程序只读数据段（<code>.rodata section</code>，见：<a target="_blank" rel="noopener" href="https://github.com/huihut/interview#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
</blockquote>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/galaxyrt/article/details/118118831">https://blog.csdn.net/galaxyrt/article/details/118118831</a></p>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，8字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table  pointer），该指针指向了一个虚基类表（virtual  table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h4 id="虚继承、虚函数"><a href="#虚继承、虚函数" class="headerlink" title="虚继承、虚函数"></a>虚继承、虚函数</h4><ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h4><ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h4 id="抽象类、接口类、聚合类"><a href="#抽象类、接口类、聚合类" class="headerlink" title="抽象类、接口类、聚合类"></a>抽象类、接口类、聚合类</h4><ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h3 id="计算下面几个类的大小"><a href="#计算下面几个类的大小" class="headerlink" title="计算下面几个类的大小"></a>计算下面几个类的大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;; <span class="built_in">sizeof</span>(A) = <span class="number">1</span>; <span class="comment">//空类在实例化时得到一个独一无二的地址，所以为 1. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>(<span class="number">32b</span>it)/<span class="number">8</span>(<span class="number">64b</span>it) <span class="comment">//当 C++ 类中有虚函数的时候，会有一个指向虚函数表的指针（vptr）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A&#123;<span class="type">static</span> <span class="type">int</span> a; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="type">int</span> a; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;; <span class="built_in">sizeof</span>(A) = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FA</span>&#123;<span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :FA&#123;<span class="type">int</span> b; &#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">4</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> FA&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :FA&#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">1</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> FA&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :<span class="keyword">virtual</span> FA&#123;&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(FA)=<span class="number">1</span></span><br><span class="line"><span class="built_in">sizeof</span>(A)=<span class="number">8</span> <span class="comment">//虚继承的子类都有一个虚基类指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="关于虚函数"><a href="#关于虚函数" class="headerlink" title="关于虚函数"></a>关于虚函数</h3><ul>
<li>为什么调用普通函数比调用虚函数的效率高？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为普通函数是静态联编的，而调用虚函数是动态联编的。</span><br><span class="line"></span><br><span class="line">联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。</span><br><span class="line"></span><br><span class="line">静态联编 ：在编译的时候就确定了函数的地址，然后call就调用了。</span><br><span class="line">动态联编 ： 首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数，然后call调用。</span><br><span class="line"></span><br><span class="line">明显动态联编要比静态联编做的操作多，肯定就费时间。</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要用虚函数表（存函数指针的数组）？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现多态，父类对象的指针指向父类对象调用的是父类的虚函数，指向子类调用的是子类的虚函数。</span><br><span class="line">同一个类的多个对象的虚函数表是同一个，所以这样就可以节省空间，一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表。</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要把基类的析构函数定义为虚函数？</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象, 而不能删除子类对象, 形成了删除一半形象, 会造成内存泄漏.如下代码：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;;  </span><br><span class="line">    ~<span class="built_in">Base</span>()   </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete Base&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;;  </span><br><span class="line">    ~<span class="built_in">Derived</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;delete Derived&quot;</span> &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//操作1  </span></span><br><span class="line">    Base* p1 = <span class="keyword">new</span> Derived;  </span><br><span class="line">    <span class="keyword">delete</span> p1;  </span><br><span class="line">    <span class="comment">//因为这里子类的析构函数重写了父类的析构函数，虽然子类和父类的析构函数名不一样，  </span></span><br><span class="line">    <span class="comment">//但是编译器对析构函数做了特殊的处理，在内部子类和父类的析构函数名是一样的。  </span></span><br><span class="line">    <span class="comment">//所以如果不把父类的析构函数定义成虚函数，就不构成多态，由于父类的析构函数隐藏了子类  </span></span><br><span class="line">    <span class="comment">//的析构函数，所以只能调到父类的析构函数。  </span></span><br><span class="line">    <span class="comment">//但是若把父类的析构函数定义成虚函数，那么调用时就会直接调用子类的析构函数，  </span></span><br><span class="line">    <span class="comment">//由于子类析构先要去析构父类，在析构子类，这样就把子类和继承的父类都析构了  </span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<ul>
<li>子类是否要重写父类的虚函数？</li>
</ul>
<p>子类继承父类时， 父类的纯虚函数必须重写，否则子类也是一个虚类不可实例化。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<h4 id="虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive-3-2"><a href="#虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive-3-2" class="headerlink" title="虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2"></a>虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base:%d\n&quot;</span>, a + n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Derive:%d\n&quot;</span>, b + n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derive[<span class="number">10</span>];</span><br><span class="line">    ptr[<span class="number">7</span>].<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h4><ol>
<li>从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间(运行时)的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</li>
<li>从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li>
</ol>
<h3 id="构造函数的扩展过程？-1"><a href="#构造函数的扩展过程？-1" class="headerlink" title="构造函数的扩展过程？"></a>构造函数的扩展过程？</h3><p>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</p>
<p>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</p>
<p>如果 class 有虚表，那么它必须被设定初值；</p>
<p>所有上一层的基类构造函数必须被调用；</p>
<p>所有虚基类的构造函数必须被调用。</p>
<h3 id="如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"><a href="#如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？" class="headerlink" title="如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？"></a>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</h3><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
<ul>
<li>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：<code>A a;</code></li>
<li>动态建立：使用 <code>new</code> 关键字在堆空间上创建对象，底层首先调用 <code>operator new()</code> 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li>
</ul>
<p>限制对象只能建立在堆上：</p>
<ul>
<li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 <code>new</code> 来建立对象。但是由于 <code>new</code> 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 <code>new</code> 创建对象了。因此，这种方法不可行。</p>
</li>
<li><p>解决方法 1：</p>
<ul>
<li><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法存在的问题：</p>
</li>
<li><p>用 <code>new</code> 创建的对象，通常会使用 <code>delete</code> 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 <code>destory()</code> 函数，用来释放 <code>new</code> 创建的对象。</p>
</li>
<li><p>无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 <code>virtual</code>，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</li>
</ul>
</li>
<li><p>解决方法 2：</p>
<ul>
<li><p>构造函数设置为 <code>protected</code>，并提供一个 <code>public</code> 的静态函数来完成构造，而不是在类的外部使用 <code>new</code> 构造；将析构函数设置为 <code>protected</code>。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
<ul>
<li>C++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>限制对象只能建立在栈上：</p>
<ul>
<li><p>解决方法：将 <code>operator new()</code> 设置为私有。原因：当对象建立在堆上时，是采用 <code>new</code>的方式进行建立，其底层会调用 <code>operator new()</code> 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
</li>
<li><p>C++</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    void *operator new(size_t t) &#123;&#125;    // 注意函数的第一个参数和返回值都是固定的</span><br><span class="line">    void operator delete(void *ptr) &#123;&#125; // 重载了 new 就需要重载 delete</span><br><span class="line">public:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<p>const和volatile 也一样，所谓的const，只是编译器保证在C的“源代码”里面，没有对该变量进行修改的地方，而实际运行的时候则不是编译器所能管的了。<br> 　同样，volatile的所谓“可能被修改”，是指“在运行期间”可能被修改。也就是告诉编译器，这个变量不是“只”会被这些C的“源代码”所操纵，其它地方也有操纵它们的地方。所以，C编译器就不能随便对它进行优化了。<br> 　const    –&gt;该变量为常量,不能在此程序中更改<br> 　volotile –&gt;该变量为一个共享变量,也就是说会有除了本程序之外的其他途径对其值进行更改,如多线程,或是硬件，其他的运行程序.<br> 　const volatile表示该变量既不能被修改，又不能被优化到寄存器，即又是可能会被其他编译器不知道的方式修改的。比如一个<code>实时时钟</code>，我们不希望被程序做修改，所以要声明为const，但其他的线程、中断等（可能来自于库）又要修改此时钟的值，编译器不能把它作为const常量优化到寄存器，所以又要声明为volatile。再举个例子，<code>只读的状态寄存器</code>，它是volatile，因为它可能被意想不到地改变。它是const，因为程序不应该试图去修改它。</p>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>



<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern “C” 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="C-中的链接属性"><a href="#C-中的链接属性" class="headerlink" title="C++中的链接属性"></a>C++中的链接属性</h4><p>　　 链接属性一定程度范围决定着符号的作用域，C++中链接属性有三种：none(无)、external（外部）和 internal(内部）。</p>
<ul>
<li>external，外部链接属性。非常量全局变量和自由函数（除成员函数以外的函数）均默认为外部链接的，它们具有全局可见性，在全局范围不允许重名，详情可见例子。</li>
<li>internal，内部链接属性。具有该属性的类型有，const对象，constexpr对象，命令空间内的静态对象(static objects in namespace scope)</li>
<li>none，在类中、函数体和代码块中声明的变量默认是具有none链接属性。它和internal一样只在当前作用域可见。</li>
</ul>
<h2 id="extern的用法"><a href="#extern的用法" class="headerlink" title="extern的用法"></a>extern的用法</h2><p>　　extern有3种用法，分别如下：</p>
<h3 id="非常量全局变量的外部链接"><a href="#非常量全局变量的外部链接" class="headerlink" title="非常量全局变量的外部链接"></a>非常量全局变量的外部链接</h3><p>　　 最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。</p>
<p><a href="javascript:void(0);"><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203301643105.gif" alt="复制代码"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//fileA.cpp</span><br><span class="line">int i = 1;         //声明并定义全局变量i</span><br><span class="line"></span><br><span class="line">//fileB.cpp</span><br><span class="line">extern int i;    //声明i，链接全局变量</span><br><span class="line"></span><br><span class="line">//fileC.cpp</span><br><span class="line">extern int i = 2;        //错误，多重定义</span><br><span class="line">int i;                    //错误，这是一个定义，导致多重定义</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    extern int i;        //正确</span><br><span class="line">    int i = 5;            //正确，新的局部变量i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常量全局变量的外部链接"><a href="#常量全局变量的外部链接" class="headerlink" title="常量全局变量的外部链接"></a>常量全局变量的外部链接</h3><p>　　常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//fileA.cpp</span><br><span class="line">extern const int i = 1;        //定义</span><br><span class="line"></span><br><span class="line">//fileB.cpp                    //声明</span><br><span class="line">extern const int i;</span><br></pre></td></tr></table></figure>

<h3 id="extern-“C”-和extern-“C-”函数声明"><a href="#extern-“C”-和extern-“C-”函数声明" class="headerlink" title="extern “C” 和extern “C++”函数声明"></a>extern “C” 和extern “C++”函数声明</h3><p>　　 在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern  “C”，就指明使用C语言的链接规范。原因是，C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。C和C++对函数的处理方式是不同的.extern  “C”是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern “C”来说明。</p>
<p>　　例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明printf函数使用C链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指定的头文件内所有的东西都使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明函数ShowChar和GetChar使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">ShowChar</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">GetChar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义函数 ShowChar 和 GetChar 使用 C 链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">char</span> <span class="title">ShowChar</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">char</span> <span class="title">GetChar</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局变量 errno 为C链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又比如，在程序中常见的代码段</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/**** some declaration or so *****/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说，</span></span><br><span class="line"><span class="comment">//上面的代码的含义是:如果这是一段cpp的代码，那么加入extern &quot;C&quot;&#123;和&#125;处理其中的代码。</span></span><br></pre></td></tr></table></figure>



<ul>
<li>使用extern和包含头文件来引用函数有什么区别呢？</li>
</ul>
<p>　　与include相比，extern引用另一个文件的范围小，include可以引用另一个文件的全部内容。extern的引用方式比包含头文件要更简洁。extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>不要把变量定义放入.h文件，这样容易导致重复定义错误</li>
<li>尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。</li>
<li>可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。</li>
</ul>
<h2 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h2><h4 id="C-中"><a href="#C-中" class="headerlink" title="C 中"></a>C 中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> S;</span><br></pre></td></tr></table></figure>

<p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() &#123;&#125;</code>。</p>
<h4 id="C-中-1"><a href="#C-中-1" class="headerlink" title="C++ 中"></a>C++ 中</h4><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student &#123;...&#125;;</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，&quot;struct&quot; 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<p>用typedef可以声明各种类型名,但不能用来<strong>定义变量</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 &quot;Student&quot; 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Student</span>(); </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> me;      <span class="comment">// 或者 &quot;S me&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h3><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>最本质的一个区别就是默认的访问控制<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h3 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h3><p>联合（union）是一种==节省空间的特殊的类==，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li><p>共用体变量所占的内存长度是所有成员中最长的成员的长度</p>
</li>
<li><p>默认访问控制符为 public</p>
</li>
<li><p>可以含有构造函数、析构函数</p>
</li>
<li><p>不能含有引用类型的成员</p>
</li>
<li><p>不能继承自其他类，不能作为基类</p>
</li>
<li><p>==不能含有虚函数==</p>
</li>
<li><p>匿名 union 在定义所在作用域可直接访问 union 成员</p>
</li>
<li><p>匿名 union 不能包含 protected 成员或 private 成员</p>
</li>
<li><p>全局匿名联合必须是静态（static）的</p>
</li>
</ul>
<p>union 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">UnionTest</span> &#123;</span><br><span class="line">    <span class="built_in">UnionTest</span>() : <span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h2><ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ul>
<p>explicit 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	A a2 = <span class="number">1</span>;		<span class="comment">// OK：复制初始化</span></span><br><span class="line">	A a3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	A a4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">	A a5 = (A)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换 </span></span><br><span class="line">	<span class="built_in">doA</span>(<span class="number">1</span>);			<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (a1);		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">a6</span><span class="params">(a1)</span></span>;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="type">bool</span> a7 = a1;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="type">bool</span> a8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">	B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">	B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	<span class="built_in">doB</span>(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="type">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">	<span class="type">bool</span> b8 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-的四种强制转换"><a href="#C-的四种强制转换" class="headerlink" title="C++ 的四种强制转换"></a><strong>C++</strong> 的四种强制转换</h2><p>C++ 的四种强制转换包括：<strong>static_cast, dynamic_cast, const_cast, reinterpret_cast</strong></p>
<ul>
<li><strong>static_cast</strong>：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换</li>
</ul>
<p>（派⽣类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；</p>
<ul>
<li><strong>dynamic_cast：</strong>专⻔⽤于派⽣类之间的转换，type-id 必须是<strong>类指针</strong>，类引⽤或 void*，对于下⾏转换是安全</li>
</ul>
<p>的，当<strong>类型不⼀致时，转换过来的是空指针</strong>，⽽static_cast，当类型不⼀致时，转换过来的是错误意义的指针，可能造成⾮法访问等问题。</p>
<ul>
<li><p><strong>const_cast：</strong>专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。</p>
</li>
<li><p><strong>reinterpret_cast：</strong>不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换。</p>
</li>
</ul>
<h2 id="C-中的指针参数传递和引⽤参数传递"><a href="#C-中的指针参数传递和引⽤参数传递" class="headerlink" title="C++ 中的指针参数传递和引⽤参数传递"></a><strong>C++</strong> 中的指针参数传递和引⽤参数传递</h2><p><strong>指针参数传递本质上是值传递</strong>，它所传递的是⼀个地址值。值传递过程中，被调函数的形式参数作为被调函数的局</p>
<p>部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，不会影响主调函数的实参变量的值</p>
<p>（形参指针变了，实参指针不会变）。</p>
<p>引⽤参数传递过程中，<strong>被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数</strong></p>
<p><strong>放进来的实参变量的地址</strong>。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问</p>
<p>主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数</p>
<p>中的实参变量。</p>
<p><strong>引⽤传递和指针传递是不同的</strong>，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理</p>
<p>都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针</p>
<p>地址，它将应⽤不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使⽤指向指针的指针或者指针引⽤。</p>
<ul>
<li>指针和引用的区别<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html">https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html</a></li>
<li></li>
</ul>
<h2 id="简单说⼀下函数指针"><a href="#简单说⼀下函数指针" class="headerlink" title="简单说⼀下函数指针"></a>简单说⼀下函数指针</h2><p>从定义和⽤途两⽅⾯来说⼀下⾃⼰的理解：</p>
<p>⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函</p>
<p>数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。</p>
<p>在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，</p>
<p>可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。</p>
<p>其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fun</span><span class="params">(<span class="type">char</span> * p)</span> </span>&#123;…&#125; <span class="comment">// 函数fun</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * (*pf)(<span class="type">char</span> * p); <span class="comment">// 函数指针pf</span></span><br><span class="line"></span><br><span class="line">pf = fun; <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pf</span>(p); <span class="comment">// 通过函数指针pf调⽤函数fun</span></span><br></pre></td></tr></table></figure>



<h2 id="范围解析运算符（不能被重载）"><a href="#范围解析运算符（不能被重载）" class="headerlink" title=":: 范围解析运算符（不能被重载）"></a>:: 范围解析运算符（不能被重载）</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">11</span>;         <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count;   <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">31</span>;     <span class="comment">// 初始化局部的 count 为 31</span></span><br><span class="line">	count = <span class="number">32</span>;         <span class="comment">// 设置局部的 count 的值为 32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::count = <span class="number">12</span>;       <span class="comment">// 测试 1：设置全局的 count 的值为 12</span></span><br><span class="line"></span><br><span class="line">	A::count = <span class="number">22</span>;      <span class="comment">// 测试 2：设置类 A 的 count 为 22</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fun</span>();		        <span class="comment">// 测试 3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><ul>
<li><p>左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值。</p>
</li>
<li><p>可以简单认为： 左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)</p>
</li>
</ul>
<h4 id="左值引用-amp"><a href="#左值引用-amp" class="headerlink" title="左值引用&amp;"></a>左值引用&amp;</h4><p>常规引用，一般表示对象的身份。</p>
<h4 id="右值引用-amp-amp"><a href="#右值引用-amp-amp" class="headerlink" title="右值引用&amp;&amp;"></a>右值引用&amp;&amp;</h4><p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用的好处是能够利用右值引用实现<strong>移动语义</strong>的库代码</p>
<p><strong>拷贝构造函数</strong>和<strong>移动构造函数</strong>：例如<code>A a(10+20)</code>时，因为<code>10+20</code>是一个右值，<strong>拷贝构造函数</strong>会创建临时对象temp，然后将temp值赋给a，（此时temp和a是两个不同的地址），对象a使用刚刚temp被释放的内存</p>
<p>而<strong>移动构造函数</strong>也会创建临时变量temp，但所创建就是临时变量的地址就是之后用于a的地址，不会有额外的复制工作。</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>移动构造函数和移动赋值运算符的参数不能是const引用，因为修改了源对象</p>
</li>
<li><p>想让左值也调用移动构造/赋值运算符，用<code>move(x)</code>，例如<code>a=move(b)</code>,b是一个左值，但此时调用的移动赋值运算符</p>
</li>
<li><p><code>int &amp;&amp;r=5+6</code></p>
</li>
</ul>
<p>​        5+6是不能被取地址的，但<code>r</code>是可以被取地址的</p>
<h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<h2 id="内存分配和管理"><a href="#内存分配和管理" class="headerlink" title="内存分配和管理"></a>内存分配和管理</h2><h4 id="malloc、calloc、realloc、alloca"><a href="#malloc、calloc、realloc、alloca" class="headerlink" title="malloc、calloc、realloc、alloca"></a>malloc、calloc、realloc、alloca</h4><ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性,  而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代  alloca。</li>
</ol>
<h4 id="malloc、free"><a href="#malloc、free" class="headerlink" title="malloc、free"></a>malloc、free</h4><p>用于分配、释放内存</p>
<p>malloc、free 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = (char*) malloc(100);</span><br><span class="line">assert(str != nullptr);</span><br></pre></td></tr></table></figure>

<p>释放内存后指针置空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p); </span><br><span class="line">p = nullptr;</span><br></pre></td></tr></table></figure>



<h4 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h4><ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>new、delete 使用</p>
<p>申请内存，确认是否申请成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    T* t = new T();     // 先内存分配 ，再构造函数</span><br><span class="line">    delete t;           // 先析构函数，再内存释放</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定位-new"><a href="#定位-new" class="headerlink" title="定位 new"></a>定位 new</h4><p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address) type (initializers)</span><br><span class="line">new (place_address) type [size]</span><br><span class="line">new (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h4 id="new与malloc创建位置的区别"><a href="#new与malloc创建位置的区别" class="headerlink" title="new与malloc创建位置的区别"></a>new与malloc创建位置的区别</h4><p> new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
<p> 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
<blockquote>
<p>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p>
</blockquote>
<h2 id="delete-this-合法吗？"><a href="#delete-this-合法吗？" class="headerlink" title="delete this 合法吗？"></a>delete this 合法吗？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?</a></p>
</blockquote>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h4 id="C-标准库（STL）中"><a href="#C-标准库（STL）中" class="headerlink" title="C++ 标准库（STL）中"></a>C++ 标准库（STL）中</h4><p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h4><ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<h4 id="1、auto-ptr（C-98-的⽅案，C11-已抛弃）采⽤所有权模式。"><a href="#1、auto-ptr（C-98-的⽅案，C11-已抛弃）采⽤所有权模式。" class="headerlink" title="1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。"></a><strong>1</strong>、<strong>auto_ptr</strong>（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;std::string&gt; p2;</span><br><span class="line"></span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr 不会报错.</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜</p>
<p>在的内存崩溃问题！</p>
<h4 id="2、unique-ptr（替换-auto-ptr-）"><a href="#2、unique-ptr（替换-auto-ptr-）" class="headerlink" title="2、unique_ptr（替换 auto_ptr ）"></a><strong>2</strong>、<strong>unique_ptr</strong>（替换 auto_ptr ）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资</p>
<p>源泄露特别有⽤。</p>
<p>采⽤所有权模式，还是上⾯那个例⼦</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="keyword">auto</span>))</span></span>;<span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；<span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错</span></span><br></pre></td></tr></table></figure>

<p>编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。</p>
<p>因此，unique_ptr ⽐ auto_ptr 更安全。</p>
<h4 id="3、shared-ptr（共享型，强引⽤）"><a href="#3、shared-ptr（共享型，强引⽤）" class="headerlink" title="3、shared_ptr（共享型，强引⽤）"></a><strong>3</strong>、<strong>shared_ptr</strong>（共享型，强引⽤）</h4><p>shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共</p>
<p>享。</p>
<p>可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊auto_ptr,</p>
<p>unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0</p>
<p>时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了</p>
<p>可以共享所有权的智能指针。</p>
<h4 id="4、weak-ptr（弱引⽤）"><a href="#4、weak-ptr（弱引⽤）" class="headerlink" title="4、weak_ptr（弱引⽤）"></a><strong>4</strong>、<strong>weak_ptr</strong>（弱引⽤）</h4><p>weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr。weak_ptr 只是提供了对管理对象的⼀个访问⼿段。weak_ptr 设计的⽬的是为配合 shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。<strong>weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题</strong>，如果说两个 shared_ptr 相互引⽤，那么这两个指针的引⽤计数永远不可能下降为0，也就是资源永远不会释放。当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为weak_ptr就可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="share-ptr的线程安全性"><a href="#share-ptr的线程安全性" class="headerlink" title="share_ptr的线程安全性"></a>share_ptr的线程安全性</h4><ul>
<li><p>shared_ptr的析构函数需要在使其他分享同一对象的所有权的shared_ptr实例的use_count()汇报数字减1，而C++标准规定对use_count()结果的变更不可以成为data race，于是<strong>析构函数不可以以一种产生data  race的方式去修改use_count()<strong>（及其底层对应的计数）。use_count在这里面汇报的是“</strong>强引用个数</strong>”，即不包含weak_ptr只计数shared_ptr的引用计数，故而析构函数对这个引用计数的修改必须是线程安全的，否则产生data race即违反了C++标准。而上一话题中提到的跨线程分享ownership的一组shared_ptr的并发析构，也就是安全的了，因为标准保证了析构函数对“强引用计数”无data race，故而它会被安全地逐个减1，并最终在导致减到0的那个线程上析构被分享的对象。</p>
</li>
<li><p>结论：对同一个对象分享所有权的shared_ptr在多个线程上的析构不需要外部加锁保护，C++标准以及标准的实现保证这一动作的线程安全性。</p>
</li>
</ul>
<h4 id="手写share-ptr"><a href="#手写share-ptr" class="headerlink" title="手写share_ptr"></a>手写share_ptr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> *m_count_;</span><br><span class="line">    T *m_ptr_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>() : <span class="built_in">m_ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">m_count_</span>(<span class="keyword">new</span> <span class="type">size_t</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPtr</span>(T *ptr) : <span class="built_in">m_ptr_</span>(ptr), <span class="built_in">m_count_</span>(<span class="keyword">new</span> <span class="type">size_t</span>) &#123; m_count_ = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">        --(*m_count_);</span><br><span class="line">        <span class="keyword">if</span> (*m_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr_;</span><br><span class="line">            <span class="keyword">delete</span> m_count_;</span><br><span class="line">            m_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">            m_count_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷⻉构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;ptr) &#123;</span><br><span class="line">        m_count_ = ptr.m_count_;</span><br><span class="line">        m_ptr_ = ptr.m_ptr_;</span><br><span class="line">        ++(*m_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷⻉赋值运算</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr &amp;ptr) &#123; <span class="built_in">SharedPtr</span>(std::<span class="built_in">move</span>(ptr)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(SharedPtr &amp;&amp;ptr) : <span class="built_in">m_ptr_</span>(ptr.m_ptr_), <span class="built_in">m_count_</span>(ptr.m_count_) &#123;</span><br><span class="line">        ++(*m_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动赋值运算</span></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(SharedPtr &amp;&amp;ptr) &#123; <span class="built_in">SharedPtr</span>(std::<span class="built_in">move</span>(ptr)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解引⽤</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头运算</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载bool操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ptr_ == <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *m_count_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *m_count_ == <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(SharedPtr &amp;ptr)</span> </span>&#123; std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>size_t的取值range是目标平台下最大可能的数组尺寸</strong>,一些平台下size_t的范围小于int的正数范围,又或者大于unsigned int.</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24773728">为什么要用size_t</a></p>
<h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><p>内存泄漏简单的说就是申请了一块内存空间，使用完毕后没有释放掉。 它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄漏了。 </p>
<ul>
<li>在类的构造函数和析构函数中没有匹配的调用new和delete函数</li>
</ul>
<p>两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存</p>
<ul>
<li><p>没有正确地清除嵌套的对象指针</p>
</li>
<li><p>在释放对象数组时在delete中没有使用方括号</p>
</li>
</ul>
<p>方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值病调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄漏。</p>
<p>释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。</p>
<ul>
<li>指向对象的指针数组不等同于对象数组</li>
</ul>
<p>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</p>
<p>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了</p>
<ul>
<li>缺少拷贝构造函数（浅拷贝和深拷贝的问题）</li>
</ul>
<p>两次释放相同的内存是一种错误的做法，同时可能会造成堆的崩溃。</p>
<p>按值传递会调用（拷贝）构造函数，<strong>引用传递</strong>不会调用。</p>
<p>在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。</p>
<p>所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符</p>
<ul>
<li>缺少重载赋值运算符</li>
</ul>
<p>这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202203310922129.png" alt="image-20220331092241737"></p>
<ul>
<li>关于nonmodifying运算符重载的常见迷思</li>
</ul>
<p>a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针</p>
<p>b. 返回内部静态对象的引用。</p>
<p>c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收</p>
<p>解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int</p>
<ul>
<li>没有将基类的析构函数定义为虚函数</li>
</ul>
<p>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p>
<blockquote>
<p>野指针：没有被初始化的指针</p>
<p>造成野指针的原因：</p>
<p>指针变量没有被初始化（如果值不定，可以初始化为NULL）</p>
<p>指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</p>
<p>悬空指针：是指针最初指向的内存已经被释放了的一种指针。</p>
<p>指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202204010031292.png" alt="img"></p>
<h3 id="内存泄漏检测工具的实现原理："><a href="#内存泄漏检测工具的实现原理：" class="headerlink" title="内存泄漏检测工具的实现原理："></a><strong>内存泄漏检测工具的实现原理：</strong></h3><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205081241794.png" alt="image.png"></p>
<p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p>
<ul>
<li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li>
<li>Callgrind：检查程序中函数调用过程中出现的问题。</li>
<li>Cachegrind：检查程序中缓存使用出现的问题。</li>
<li>Helgrind：检查多线程程序中出现的竞争问题。</li>
<li>Massif：检查程序中堆栈使用中出现的问题。</li>
<li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li>
</ul>
<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p>
<ul>
<li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>
<li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>
</ul>
<p>检测原理：</p>
<ul>
<li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li>
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li>
</ul>
<h2 id="c-中函数被调用的过程"><a href="#c-中函数被调用的过程" class="headerlink" title="c++中函数被调用的过程"></a>c++中函数被调用的过程</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22444939/answer/22200552">https://www.zhihu.com/question/22444939/answer/22200552</a></p>
<p><strong>堆栈平衡</strong>（栈帧调整）：具体包括<br>保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）<br>将当前栈帧切换到新栈帧。（将ESP值装入EBP，更新栈帧底部）<br>给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）</p>
<h2 id="C-中内存分配情况"><a href="#C-中内存分配情况" class="headerlink" title="C++ 中内存分配情况"></a><strong>C++</strong> 中内存分配情况</h2><p><strong>栈</strong></p>
<p>由<strong>编译器自动分配和释放</strong>，一般保存的是<strong>局部变量和函数参数</strong>等。</p>
<p>连续的内存空间，在函数调用的时候，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。</p>
<p>大多数编译器中，<strong>参数是从右向左入栈</strong>（原因在于采用这种顺序，是为了让程序员在使用C/C++的“函数参数长度可变”这个特性时更方便。如果是从左向右压栈，第一个参数（即描述可变参数表的各变量类型的那个参数）将被放在栈底，由于可变参的函数第一步就需要解析可变参数表的各参数类型，即第一步就需要得到上述参数，因此，将它放在栈底是很不方便的。）本次函数调用结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运行，不会产生碎片。</p>
<p>栈是高地址向低地址扩展，栈低高地址，空间较小。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tht2009/article/details/7019635?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-7019635-blog-78483471.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-7019635-blog-78483471.pc_relevant_default&utm_relevant_index=1">变长参数</a></p>
<p><strong>堆</strong></p>
<p>由<strong>程序员</strong>管理，需要<strong>手动</strong> new malloc delete free 进行分配和回收，如果不进行回收的话，会造成内存泄漏的问题。</p>
<p>不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生内存碎片的原因。</p>
<p>堆是低地址向高地址扩展，空间交大，较为灵活。</p>
<h5 id="全局-静态存储区"><a href="#全局-静态存储区" class="headerlink" title="全局/静态存储区"></a>全局/静态存储区</h5><p>分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p>
<p>常量存储区：存储常量，⼀般不允许修改。</p>
<h5 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h5><p>存放程序的⼆进制代码。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/5060894.html">c++自由存储区是否等价于堆</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linux_ever/article/details/50533149">malloc和new的区别</a></p>
<h5 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h5><ul>
<li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li>
<li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li>
<li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li>
<li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li>
<li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li>
</ul>
<h2 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h2><p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h2 id="c-11新特性"><a href="#c-11新特性" class="headerlink" title="c++11新特性"></a>c++11新特性</h2><h2 id="C-模板是什么，底层怎么实现的？"><a href="#C-模板是什么，底层怎么实现的？" class="headerlink" title="C++ 模板是什么，底层怎么实现的？"></a><strong>C++</strong> 模板是什么，底层怎么实现的？</h2><ul>
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产⽣不同的函数；编译器</li>
</ul>
<p>会对函数模板进⾏两次编译：在声明的地⽅对模板代码本身进⾏编译，在调⽤的地⽅对参数替换后的代码进⾏编</p>
<p>译。</p>
<ul>
<li>这是因为函数模板要被实例化后才能成为真正的函数，在使⽤函数模板的源⽂件中包含函数模板的头⽂件，如果该</li>
</ul>
<p>头⽂件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。</p>
<h2 id="请你来写个函数在-main-函数执⾏前先运⾏"><a href="#请你来写个函数在-main-函数执⾏前先运⾏" class="headerlink" title="请你来写个函数在 main 函数执⾏前先运⾏"></a>请你来写个函数在 <strong>main</strong> 函数执⾏前先运⾏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第⼀种：gcc扩展，标记这个函数应当在main函数之前执⾏。同样有⼀个__attribute((destructor))，标记函数应当在程序结束之前（main结束之后，或者调⽤了exit后）执⾏;</span></span><br><span class="line">__attribute((constructor))<span class="function"><span class="type">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before main 1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第⼆种：全局 static 变ᰁ的初始化在程序初始阶段，先于 main 函数的执⾏</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before main 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="built_in">test1</span>();</span><br><span class="line"><span class="comment">// 第三种：知乎⼤⽜ Milo Yip 的回答利⽤ lambda 表达式</span></span><br><span class="line"><span class="type">int</span> a = []() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before main 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="请你来说⼀下-fork-函数"><a href="#请你来说⼀下-fork-函数" class="headerlink" title="请你来说⼀下 fork 函数"></a>请你来说⼀下 <strong>fork</strong> 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Fork：创建⼀个和当前进程映像⼀样的进程可以通过 fork() 系统调⽤：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>成功调⽤ fork() 会创建⼀个新的进程，它⼏乎与调⽤ fork() 的进程⼀模⼀样，这两个进程都会继续运⾏。在⼦进程</li>
</ul>
<p>中，成功的 fork( ) 调⽤会返回0。在⽗进程中 fork() 返回⼦进程的 pid。</p>
<ul>
<li><p>如果出现错误，fork() 返回⼀个负值。</p>
</li>
<li><p>最常⻅的 fork() ⽤法是创建⼀个新的进程，然后使⽤ exec() 载⼊⼆进制映像，替换当前进程的映像。这种情况下，</p>
</li>
</ul>
<p>派⽣（fork）了新的进程，⽽这个⼦进程会执⾏⼀个新的⼆进制可执⾏⽂件的映像。这种“派⽣加执⾏”的⽅式是很</p>
<p>常⻅的。</p>
<p>在早期的 Unix 系统中，创建进程⽐较原始。当调⽤ fork 时，内核会把所有的内部数据结构复制⼀份，复制进程的</p>
<p>⻚表项，然后把⽗进程的地址空间中的内容逐⻚的复制到⼦进程的地址空间中。但从内核⻆度来说，逐⻚的复制⽅</p>
<p>式是⼗分耗时的。现代的 Unix 系统采取了更多的优化，例如 Linux，采⽤了写时复制的⽅法，⽽不是对⽗进程空</p>
<p>间进程整体复制。</p>
<h2 id="简单说⼀下-printf-实现原理？"><a href="#简单说⼀下-printf-实现原理？" class="headerlink" title="简单说⼀下 printf 实现原理？"></a>简单说⼀下 <strong>printf</strong> 实现原理？</h2><ul>
<li><p>在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压⼊堆栈的⽅式来给函数传参数的（堆栈是⼀种先进后出的数据结构）。</p>
</li>
<li><p>最先压⼊的参数最后出来，在计算机的内存中，数据有 2 块，⼀块是堆，⼀块是栈（函数参数及局部变变量在这</p>
</li>
</ul>
<p>⾥），⽽栈是从内存的⾼地址向低地址⽣⻓的，控制⽣⻓的就是堆栈指针了，最先压⼊的参数是在最上⾯，就是说</p>
<p>在所有参数的最后⾯，最后压⼊的参数在最下⾯，结构上看起来是第⼀个，所以最后压⼊的参数总是能够被函数找到。</p>
<ul>
<li>因为它就在堆栈指针的上⽅。printf的第⼀个被找到的参数就是那个字符指针，就是被双引号括起来的那⼀部分，</li>
</ul>
<p>函数通过判断字符串⾥控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移了。</p>
<ul>
<li>注意</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;<span class="comment">//这里是给a[0]加了89因为是p++</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><code>3,3</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,x++);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x++,x);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,x,x++,x);  </span><br><span class="line">x=<span class="number">1</span>;   <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,x,++x,x++,x);  </span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 1  </span><br><span class="line">1 2  </span><br><span class="line">2 1 2  </span><br><span class="line">3 3 1 3  </span><br></pre></td></tr></table></figure>

<p>  在计算时，遇到x++会记录此时的x的值作为最后的输出结果。遇到x和++x的时候则不会将此时的计算结果作为最终的输出，只会修改x的值，在最终输出的时候都输出x的值（所以++x和x的结果总是一样的）。</p>
<p>​    为什么会是这个样子呢？参见某高手解释吧：</p>
<p>​    对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d %d\n&quot;</span>,a++, ++a, a++, ++a, a++, ++a );  </span><br></pre></td></tr></table></figure>

<p>输出<code>6 7 4 7 2 7</code></p>
<p>a++的值在运算过程中就能确定；</p>
<p> 而所有++a或者a（如果有）的值是所有对a的值产生影响的运算之后最终的值。</p>
<h2 id="⼿写字符串函数-strcat，strcpy，strncpy，memset，memcpy实现"><a href="#⼿写字符串函数-strcat，strcpy，strncpy，memset，memcpy实现" class="headerlink" title="⼿写字符串函数 strcat，strcpy，strncpy，memset，memcpy实现"></a>⼿写字符串函数 <strong>strcat</strong>，<strong>strcpy</strong>，<strong>strncpy</strong>，<strong>memset</strong>，<strong>memcpy</strong>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把 src 所指向的字符串复制到 dest，注意：dest定义的空间应该⽐src⼤。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);<span class="comment">//优化点1：检查输⼊参数</span></span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>) *(dest++) = *(src++);</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//优化点2：⼿动地将最后的&#x27;\0&#x27;补上</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑内存重叠的字符串拷⻉函数 优化的点</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memmove</span>(dest, src, <span class="built_in">strlen</span>(src) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 将⽬的字符串的起始位置先保存，最后要返回它的头指针</span></span><br><span class="line"><span class="comment">//2. 先找到dest的结束位置,再把src拷⻉到dest中，记得在最后要加上&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*dest != <span class="string">&#x27;\0&#x27;</span>)dest++;</span><br><span class="line">    <span class="keyword">while</span> (*src != <span class="string">&#x27;\0&#x27;</span>)*(dest++) = *(src++);</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 str1 所指向的字符串和 str2 所指向的字符串进⾏⽐较。</span></span><br><span class="line"><span class="comment">//该函数返回值如下：</span></span><br><span class="line"><span class="comment">//如果返回值 &lt; 0，则表示 str1 ⼩于 str2。</span></span><br><span class="line"><span class="comment">//如果返回值 &gt; 0，则表示 str1 ⼤于 str2。</span></span><br><span class="line"><span class="comment">//如果返回值 = 0，则表示 str1 等于 str2。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(s1 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(s2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (*s1 != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *s2 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s1 != *s2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s1-*s2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s1++, s2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当有⼀个字符串已经⾛到结尾</span></span><br><span class="line">    <span class="keyword">if</span> (*s1 !=<span class="string">&#x27;\0&#x27;</span>&amp;&amp; *s2==<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*s1 ==<span class="string">&#x27;\0&#x27;</span>&amp;&amp; *s2!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*s2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟实现memcpy函数 从存储区 str2 复制 n 个字符到存储区 dst。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> *ret = dest;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(dest != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">assert</span>(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="comment">//因为void* 不能直接解引⽤，所以需要强转成char*再解引⽤</span></span><br><span class="line"><span class="comment">//此处的void*实现了泛型编程</span></span><br><span class="line">        *(<span class="type">char</span> *) dest = *(<span class="type">char</span> *) src;</span><br><span class="line">        dest = (<span class="type">char</span> *) dest + <span class="number">1</span>;</span><br><span class="line">        src = (<span class="type">char</span> *) src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑内存重叠的memcpy函数 优化的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p1 = (<span class="type">char</span> *) dest;</span><br><span class="line">    <span class="type">char</span> *p2 = (<span class="type">char</span> *) src;</span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; p2) &#123;<span class="comment">//p1低地址p2⾼地址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != num; ++i) *(p1++) = *(p2++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从后往前赋值</span></span><br><span class="line">        p1 += num - <span class="number">1</span>;</span><br><span class="line">        p2 += num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != num; ++i) *(p1--) = *(p2--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.memcpy和memmove相同点</strong><br> 都是用于从src拷贝count个字节到dest。</p>
<p><strong>2.memcpy和memmove区别</strong><br> 如果目标区域和源区域有重叠的话：<br> memcpy不能够确保源串所在重叠区域在拷贝之前被覆盖。<br> memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后src内容会被更改，当目标区域与源区域没有重叠则和memcpy函数功能相同。</p>
<p> 但当源内存和目标内存存在重叠时，memcpy会出现错误，而memmove能正确地实施拷贝，但这也增加了一点点开销。</p>
<p><strong>memmove的处理措施：</strong><br> （1）当源内存的首地址等于目标内存的首地址时，不进行任何拷贝<br> （2）当源内存的首地址大于目标内存的首地址时，实行正向拷贝<br> （3）当源内存的首地址小于目标内存的首地址时，实行反向拷贝</p>
<h3 id="memcmp函数"><a href="#memcmp函数" class="headerlink" title="memcmp函数"></a>memcmp函数</h3><p>通过输入字节数n，比较前后两个数组从首地址开始的n个字节</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int arr1[5] = &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">	int arr2[5] = &#123; 1,2,3,4,0x11223305 &#125;;</span><br><span class="line">	int ret = memcmp(arr1, arr2, 16);</span><br><span class="line">	printf(&quot;%d&quot;, ret);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr1在内存中的样子</p>
<p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533402.png" alt="img"></p>
<p>arr2在内存中的样子 </p>
<p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533645.png"></p>
<p> 当比较16个字节时，相等</p>
<p> 当比较17个字节时，依然是相等</p>
<p>原因是：在第17个字节处刚好相等（这里是小端字节序）</p>
<p> <img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533376.png" alt="img"></p>
<p>当比较18个字节时结果是-1</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071533321.png" alt="img"></p>
<p>原因是在第18个字节处出现了不一样，arr2是33，arr1是00</p>
<h2 id="C或C-中的位域（bit-field）"><a href="#C或C-中的位域（bit-field）" class="headerlink" title="C或C++中的位域（bit field）"></a>C或C++中的位域（bit field）</h2><blockquote>
<p><strong>位段</strong>（或称“位域”，Bit field）为一种数据结构，可以把数据以位元的形式紧凑的储存，并允许程序员对此结构的位元进行操作。这种数据结构的好处：<br>可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。位段可以很方便的访问一个值的部分内容从而可以简化程序源代码。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>只可以在struct或者class中使用。具体用法如下：</p>
<p>比如，我们需要定义一个结构体来储存一些信息，我们可以这样写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR2</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ch;    <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> font;  <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  size;  <span class="comment">//32位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR2</span> ch2;</span><br></pre></td></tr></table></figure>

<p>其实上面的写法已经使得储存空间很紧凑了，但是我们可以用bit field进一步减少空间占用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ch   : <span class="number">8</span>;    <span class="comment">//8位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> font : <span class="number">6</span>;    <span class="comment">//6位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size : <span class="number">18</span>;   <span class="comment">//18位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CHAR</span> ch1;</span><br></pre></td></tr></table></figure>

<p>可以看出，第一种写法需要使用48bit的空间来储存信息，但第二种写法（bit field）只需要30bit的空间就可以储存相同的信息。<strong>当然这种写法的前提是，我们知道将要储存数据的范围。</strong></p>
<h3 id="位域的大小"><a href="#位域的大小" class="headerlink" title="位域的大小"></a><strong>位域的大小</strong></h3><p>例如以下位域：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> a: <span class="number">1</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span>  : <span class="number">3</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> b: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该位域结构体中间有一个未命名的位域，占据 3  Bits，仅起填充作用，并无实际意义。 填充使得该结构总共使用了 8 Bits。但 C 语言使用 unsigned int  作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。  有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。文章以下均默认 unsigned int 为  32 Bits。</p>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014609638/article/details/106987131/">https://blog.csdn.net/u014609638/article/details/106987131/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a)c=a;</span><br><span class="line"><span class="keyword">decltype</span>(a=b)d=a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>b</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int &amp;</td>
<td>4</td>
</tr>
</tbody></table>
<p>a是一个变量，所以decltype返回的类型就是int</p>
<p>而a=b是一个左值表达式，decltype接受的是左值表达式，返回左值引用；接受的是右值表达式，返回右值的类型，所以d的类型是int &amp;，又因为decltype里的表达式不会真的被计算，所以a还是3。又因为d是引用a，所以++d同时也会改变a</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table>
<thead>
<tr>
<th><strong>优先级</strong></th>
<th><strong>运算符</strong></th>
<th><strong>名称或含义</strong></th>
<th><strong>使用形式</strong></th>
<th><strong>结合方向</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[]</td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td></td>
</tr>
<tr>
<td></td>
<td>()</td>
<td>圆括号</td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>.</td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>-&gt;</td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>负号运算符</td>
<td>-表达式</td>
<td>右到左</td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>(类型)</td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>++</td>
<td>前置自增运算符</td>
<td>++变量名</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>++</td>
<td>后置自增运算符</td>
<td>变量名++</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>–</td>
<td>前置自减运算符</td>
<td>–变量名</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>–</td>
<td>后置自减运算符</td>
<td>变量名–</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>*</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>&amp;</td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>!</td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>~</td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td></td>
<td>单目运算符</td>
</tr>
<tr>
<td></td>
<td>sizeof</td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>/</td>
<td>除</td>
<td>表达式/表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>*</td>
<td>乘</td>
<td>表达式*表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>%</td>
<td>余数（取模）</td>
<td>整型表达式/整型表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td>4</td>
<td>+</td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>减</td>
<td>表达式-表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;</td>
<td>左移</td>
<td>变量</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>&gt;&gt;</td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td>6</td>
<td>&gt;</td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>&gt;=</td>
<td>大于等于</td>
<td>表达式&gt;=表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
<td>表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>&lt;=</td>
<td>小于等于</td>
<td>表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td>7</td>
<td>==</td>
<td>等于</td>
<td>表达式==表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td>!=</td>
<td>不等于</td>
<td>表达式!= 表达式</td>
<td></td>
<td>双目运算符</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>按位或</td>
<td>表达式|表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>逻辑或</td>
<td>表达式||表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>条件运算符</td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
<td>三目运算符</td>
</tr>
<tr>
<td>14</td>
<td>=</td>
<td>赋值运算符</td>
<td>变量=表达式</td>
<td>右到左</td>
<td></td>
</tr>
<tr>
<td></td>
<td>/=</td>
<td>除后赋值</td>
<td>变量/=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>*=</td>
<td>乘后赋值</td>
<td>变量*=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>%=</td>
<td>取模后赋值</td>
<td>变量%=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>+=</td>
<td>加后赋值</td>
<td>变量+=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>-=</td>
<td>减后赋值</td>
<td>变量-=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
<td>变量</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
<td>变量&gt;&gt;=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&amp;=</td>
<td>按位与后赋值</td>
<td>变量&amp;=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>^=</td>
<td>按位异或后赋值</td>
<td>变量^=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>|=</td>
<td>按位或后赋值</td>
<td>变量|=表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>,</td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>从左向右顺序运算</td>
</tr>
</tbody></table>
<h3 id="左结合和右结合"><a href="#左结合和右结合" class="headerlink" title="左结合和右结合"></a>左结合和右结合</h3><p>a=b+c+d </p>
<p>=是右结合的，所以先计算(b+c+d)，然后再赋值给a<br> +是左结合的，所以先计算(b+c)，然后再计算(b+c)+d </p>
<h2 id="C-中-一个-号-和-两个-号-的用法和作用"><a href="#C-中-一个-号-和-两个-号-的用法和作用" class="headerlink" title="C++中#(一个#号)和##(两个#号)的用法和作用"></a>C++中#(一个#号)和##(两个#号)的用法和作用</h2><p>C/C++ 的宏中，#的功能是将其后面的宏参数进行字符串化操作，简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> WARNIF(EXP) \</span></span><br><span class="line"><span class="meta">do&#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (EXP) \</span></span><br><span class="line"><span class="meta">    &#123;    \    </span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> #EXP <span class="string">&quot;\n&quot;</span>); \</span><br><span class="line">    &#125;   \    </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)    </span><br><span class="line">在实际使用中会出现下面所示的替换过程：</span><br><span class="line"><span class="built_in">WARN_IF</span>(div == <span class="number">0</span>); 被替换成以下代码</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (div == <span class="number">0</span>) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;warning:&quot;</span> <span class="string">&quot;div == 0&quot;</span> <span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<p>##连接符号由两个井号组成，其功能是在带参数的宏定义中将两个子串联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define MERGE1(x,y) x##y</span><br><span class="line">#define MERGE2(x, y)         x##y##x</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int aaabbb=1;</span><br><span class="line">    int aaabbbaaa = 20;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;classname = &quot; &lt;&lt; MERGE1(aaa,bbb) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;aaabbbccc = &quot; &lt;&lt; MERGE2(aaa, bbb) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各种阅读程序题"><a href="#各种阅读程序题" class="headerlink" title="各种阅读程序题"></a>各种阅读程序题</h2><p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061809858.png" alt="image-20220506180917624"></p>
<p>答案为-6</p>
<ul>
<li>前缀++和–的优先级比*作为乘号时高（和*作为取指针指向值时相同）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205061815592.png" alt="image-20220506181515336"></p>
<p>答案为32</p>
<ul>
<li>++l先+了再返回结果，模拟一遍即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        x = y = z = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> xx, <span class="type">int</span> yy = <span class="string">&#x27;A&#x27;</span>, <span class="type">int</span> zz = <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = x + yy;</span><br><span class="line">        z = x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> xx=<span class="number">65</span>,<span class="type">int</span> yy=<span class="number">66</span>):<span class="built_in">Base</span>(xx,yy)&#123;</span><br><span class="line">        y=xx;</span><br><span class="line">        x=yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出就是66 65，不涉及继承和其他奇怪的操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071534208.png" alt="image-20220507153437974"></p>
<p>不难理解答案是-1</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071538504.png" alt="image-20220507153813260"></p>
<p>答案是3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr=(<span class="type">int</span> *)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;*(ptr<span class="number">-6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是5</p>
<p>首先注意，虽然a和&amp;a[0]的地址相同但是&amp;a+1和&amp;a[0]+1(a+1)的含义是不同的</p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644470.png" alt="image-20220507164400287"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071644743.png" alt="image-20220507164415561"></p>
<p><img src="https://cdn.jsdelivr.net/gh/reinhart-l/FigureBed/2021/202205071626248.png" alt="image-20220507162648006"></p>
<p>一个int是4个字节，所以&amp;a+1相当于+了4*10。再-6*4，就是a[4]的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp =[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a&lt;b;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;<span class="built_in">q</span>(cmp);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这是大根堆</p>
<p>输出853</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> s=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *pt=&amp;s;</span><br><span class="line">    cout&lt;&lt;*((<span class="type">int</span> *)pt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为5</p>
<p>因为结构体不像数组，例如<code>int a[10]</code>, a就是指向数组首地址的指针，而这个地方<code>struct node *pt=&amp;s;</code> ，pt只是结构体s的首地址，而并不是指针，所以要加一个(int *)把这个地址转换为指针，才能对指针+1之后再解引用，如果不加<code>int *</code>会报错</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C++编译的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">2.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.2.</span> <span class="toc-text">const 的指针与引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89-define-%E5%92%8C-const-%E5%B8%B8%E9%87%8F"><span class="toc-number">2.0.4.</span> <span class="toc-text">宏定义 #define 和 const 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%EF%BC%8Cdefine%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%8Ctypedef%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">2.0.5.</span> <span class="toc-text">typedef作用于编译阶段，define作用于预处理阶段，typedef用来定义类型的别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">构造函数的执行顺序？析构函数的执行顺序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB-%E5%9F%BA%E7%B1%BB-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">3.0.1.</span> <span class="toc-text">虚基类 基类 派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.0.2.</span> <span class="toc-text">在一个类中创建另一个类的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B-%E5%B9%B6%E4%B8%94%E6%9C%89%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.0.3.</span> <span class="toc-text">在一个类中创建另一个类的实例 并且有基类的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">构造函数的扩展过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">5.</span> <span class="toc-text">什么情况下会调用拷贝构造函数(三种情况)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">C++移动构造函数（移动语义的具体实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">7.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">7.0.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">inline 内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">9.0.1.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">9.0.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9-inline-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.0.3.</span> <span class="toc-text">编译器对 inline 函数的处理步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.0.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">10.1.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">10.1.2.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">10.1.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E3%80%81%E8%A6%86%E7%9B%96%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">C++中函数重载、隐藏、覆盖和重写的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88Function-Overload%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">1.函数重载（Function Overload）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E7%94%A8%E6%B3%95"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.2用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%EF%BC%88Function-Hiding%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">2.函数隐藏（Function Hiding）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%94%A8%E6%B3%95%E7%94%A8%E4%BE%8B"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2用法用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.2.3.</span> <span class="toc-text">2.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%EF%BC%88Function-Override%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">3.函数覆盖与函数重写（Function Override）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%AE%9A%E4%B9%89"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E4%B8%8E%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2虚函数重写与协变返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.3注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">11.4.</span> <span class="toc-text">4.总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">11.5.</span> <span class="toc-text">动态联编与静态联编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">12.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">12.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">12.2.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E7%BC%96%E8%AF%91%E6%9C%9F-%E6%97%A9%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="toc-number">12.2.1.</span> <span class="toc-text">静态多态（编译期&#x2F;早绑定）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88%EF%BC%88%E6%B3%9B%E5%9E%8B%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">12.2.1.1.</span> <span class="toc-text">void * 指针（泛型指针）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%88%E8%BF%90%E8%A1%8C%E6%9C%9F-%E6%99%9A%E7%BB%91%E5%AE%9A%EF%BC%89"><span class="toc-number">12.2.2.</span> <span class="toc-text">动态多态（运行期&#x2F;晚绑定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88virtual%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89%E5%90%97%EF%BC%9F"><span class="toc-number">12.2.3.</span> <span class="toc-text">虚函数（virtual）可以是内联函数（inline）吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">虚函数内联使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">12.2.3.2.</span> <span class="toc-text">动态多态使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.4.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">12.2.5.</span> <span class="toc-text">析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.6.</span> <span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.7.</span> <span class="toc-text">虚函数、纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">12.2.8.</span> <span class="toc-text">虚函数指针、虚函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">12.2.9.</span> <span class="toc-text">虚继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.10.</span> <span class="toc-text">虚继承、虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.11.</span> <span class="toc-text">模板类、成员模板、虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B1%BB%E3%80%81%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">12.2.12.</span> <span class="toc-text">抽象类、接口类、聚合类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">12.3.</span> <span class="toc-text">计算下面几个类的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">关于虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8A%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%9A%E6%80%81%E8%A1%8C%E4%B8%BA%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BADerive-3-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">虚函数上的缺省参数是不会有多态行为的，所以以下代码输出Derive:3+2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.2.</span> <span class="toc-text">为什么构造函数不能是虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9F-1"><span class="toc-number">12.5.</span> <span class="toc-text">构造函数的扩展过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">13.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assert"><span class="toc-number">14.</span> <span class="toc-text">assert()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-number">15.</span> <span class="toc-text">extern “C”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">15.0.1.</span> <span class="toc-text">C++中的链接属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">extern的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">16.1.</span> <span class="toc-text">非常量全局变量的外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">16.2.</span> <span class="toc-text">常量全局变量的外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D-%E5%92%8Cextern-%E2%80%9CC-%E2%80%9D%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">16.3.</span> <span class="toc-text">extern “C” 和extern “C++”函数声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">17.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E5%92%8C-typedef-struct"><span class="toc-number">18.</span> <span class="toc-text">struct 和 typedef struct</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD"><span class="toc-number">18.0.1.</span> <span class="toc-text">C 中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD-1"><span class="toc-number">18.0.2.</span> <span class="toc-text">C++ 中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-struct-%E5%92%8C-class"><span class="toc-number">18.1.</span> <span class="toc-text">C++ 中 struct 和 class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">18.1.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-%E8%81%94%E5%90%88"><span class="toc-number">18.2.</span> <span class="toc-text">union 联合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit%EF%BC%88%E6%98%BE%E5%BC%8F%EF%BC%89%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">19.</span> <span class="toc-text">explicit（显式）关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">20.</span> <span class="toc-text">C++ 的四种强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E2%BD%A4%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">21.</span> <span class="toc-text">C++ 中的指针参数传递和引⽤参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">22.</span> <span class="toc-text">简单说⼀下函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">:: 范围解析运算符（不能被重载）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">23.0.1.</span> <span class="toc-text">分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">24.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">24.0.1.</span> <span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-amp"><span class="toc-number">24.0.2.</span> <span class="toc-text">左值引用&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-amp-amp"><span class="toc-number">24.0.3.</span> <span class="toc-text">右值引用&amp;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">24.0.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">24.0.5.</span> <span class="toc-text">引用折叠</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E7%AE%A1%E7%90%86"><span class="toc-number">25.</span> <span class="toc-text">内存分配和管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E3%80%81calloc%E3%80%81realloc%E3%80%81alloca"><span class="toc-number">25.0.1.</span> <span class="toc-text">malloc、calloc、realloc、alloca</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc%E3%80%81free"><span class="toc-number">25.0.2.</span> <span class="toc-text">malloc、free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E3%80%81delete"><span class="toc-number">25.0.3.</span> <span class="toc-text">new、delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D-new"><span class="toc-number">25.0.4.</span> <span class="toc-text">定位 new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new%E4%B8%8Emalloc%E5%88%9B%E5%BB%BA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.0.5.</span> <span class="toc-text">new与malloc创建位置的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-this-%E5%90%88%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">delete this 合法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">27.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%88STL%EF%BC%89%E4%B8%AD"><span class="toc-number">27.0.1.</span> <span class="toc-text">C++ 标准库（STL）中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11"><span class="toc-number">27.0.2.</span> <span class="toc-text">C++ 11</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81auto-ptr%EF%BC%88C-98-%E7%9A%84%E2%BD%85%E6%A1%88%EF%BC%8CC11-%E5%B7%B2%E6%8A%9B%E5%BC%83%EF%BC%89%E9%87%87%E2%BD%A4%E6%89%80%E6%9C%89%E6%9D%83%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">27.0.3.</span> <span class="toc-text">1、auto_ptr（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81unique-ptr%EF%BC%88%E6%9B%BF%E6%8D%A2-auto-ptr-%EF%BC%89"><span class="toc-number">27.0.4.</span> <span class="toc-text">2、unique_ptr（替换 auto_ptr ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81shared-ptr%EF%BC%88%E5%85%B1%E4%BA%AB%E5%9E%8B%EF%BC%8C%E5%BC%BA%E5%BC%95%E2%BD%A4%EF%BC%89"><span class="toc-number">27.0.5.</span> <span class="toc-text">3、shared_ptr（共享型，强引⽤）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81weak-ptr%EF%BC%88%E5%BC%B1%E5%BC%95%E2%BD%A4%EF%BC%89"><span class="toc-number">27.0.6.</span> <span class="toc-text">4、weak_ptr（弱引⽤）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#share-ptr%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">27.0.7.</span> <span class="toc-text">share_ptr的线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%86%99share-ptr"><span class="toc-number">27.0.8.</span> <span class="toc-text">手写share_ptr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">28.</span> <span class="toc-text">内存泄漏的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">28.1.</span> <span class="toc-text">内存泄漏检测工具的实现原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E4%B8%AD%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">c++中函数被调用的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-number">30.</span> <span class="toc-text">C++ 中内存分配情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">30.0.0.1.</span> <span class="toc-text">全局&#x2F;静态存储区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-number">30.0.0.2.</span> <span class="toc-text">代码区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.0.0.3.</span> <span class="toc-text">栈和堆的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">31.</span> <span class="toc-text">成员初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">32.</span> <span class="toc-text">c++11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">C++ 模板是什么，底层怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%86%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%A8-main-%E5%87%BD%E6%95%B0%E6%89%A7%E2%BE%8F%E5%89%8D%E5%85%88%E8%BF%90%E2%BE%8F"><span class="toc-number">34.</span> <span class="toc-text">请你来写个函数在 main 函数执⾏前先运⾏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E2%BC%80%E4%B8%8B-fork-%E5%87%BD%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">请你来说⼀下 fork 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8B-printf-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">简单说⼀下 printf 实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%BC%BF%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-strcat%EF%BC%8Cstrcpy%EF%BC%8Cstrncpy%EF%BC%8Cmemset%EF%BC%8Cmemcpy%E5%AE%9E%E7%8E%B0"><span class="toc-number">37.</span> <span class="toc-text">⼿写字符串函数 strcat，strcpy，strncpy，memset，memcpy实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memcmp%E5%87%BD%E6%95%B0"><span class="toc-number">37.1.</span> <span class="toc-text">memcmp函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E6%88%96C-%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%9F%9F%EF%BC%88bit-field%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">C或C++中的位域（bit field）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">38.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">38.2.</span> <span class="toc-text">位域的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">39.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">40.</span> <span class="toc-text">运算符优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%BB%93%E5%90%88%E5%92%8C%E5%8F%B3%E7%BB%93%E5%90%88"><span class="toc-number">40.1.</span> <span class="toc-text">左结合和右结合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD-%E4%B8%80%E4%B8%AA-%E5%8F%B7-%E5%92%8C-%E4%B8%A4%E4%B8%AA-%E5%8F%B7-%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">41.</span> <span class="toc-text">C++中#(一个#号)和##(两个#号)的用法和作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%98%85%E8%AF%BB%E7%A8%8B%E5%BA%8F%E9%A2%98"><span class="toc-number">42.</span> <span class="toc-text">各种阅读程序题</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&text=c++知识点"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&is_video=false&description=c++知识点"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=c++知识点&body=Check out this article: http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&title=c++知识点"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&name=c++知识点&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/11/08/c++%E7%9F%A5%E8%AF%86%E7%82%B9/&t=c++知识点"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
      <div class="footer-left">
        Copyright &copy;
        
        
        2022-2024
        Reinhart
      </div>
      <div class="footer-right">
        <nav>
          <ul>
            <!--
          --><li><a href="/">Home</a></li><!--
        --><!--
          --><li><a href="/search/">Search</a></li><!--
        --><!--
          --><li><a href="/about/">About</a></li><!--
        --><!--
          --><li><a href="/archives/">Writing</a></li><!--
        -->
          </ul>
          <ul>
            
              <!-- 不蒜子统计 -->
              <span class="site-pv">
                <i class="fa fa-eye"></i> 
                  <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
              </span>
              <span class="post-meta-divider">|</span>
              <span class="site-uv">
                <i class="fa fa-user"></i> 
                  <span class="busuanzi-user" id="busuanzi_value_site_uv"></span>
              </span>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            
          </ul>
        </nav>
      </div>
      
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?8f0c35c575c71287b5578dafdd00a358";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'reinhart';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
